<!DOCTYPE HTML>
<html lang="en">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/**</a>
<span class="sourceLineNo">002</span><a id="line.2"> * Licensed to the Apache Software Foundation (ASF) under one or more</a>
<span class="sourceLineNo">003</span><a id="line.3"> * contributor license agreements.  See the NOTICE file distributed with</a>
<span class="sourceLineNo">004</span><a id="line.4"> * this work for additional information regarding copyright ownership.</a>
<span class="sourceLineNo">005</span><a id="line.5"> * The ASF licenses this file to You under the Apache License, Version 2.0</a>
<span class="sourceLineNo">006</span><a id="line.6"> * (the "License"); you may not use this file except in compliance with</a>
<span class="sourceLineNo">007</span><a id="line.7"> * the License.  You may obtain a copy of the License at</a>
<span class="sourceLineNo">008</span><a id="line.8"> *</a>
<span class="sourceLineNo">009</span><a id="line.9"> *      http://www.apache.org/licenses/LICENSE-2.0</a>
<span class="sourceLineNo">010</span><a id="line.10"> *</a>
<span class="sourceLineNo">011</span><a id="line.11"> * Unless required by applicable law or agreed to in writing, software</a>
<span class="sourceLineNo">012</span><a id="line.12"> * distributed under the License is distributed on an "AS IS" BASIS,</a>
<span class="sourceLineNo">013</span><a id="line.13"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</a>
<span class="sourceLineNo">014</span><a id="line.14"> * See the License for the specific language governing permissions and</a>
<span class="sourceLineNo">015</span><a id="line.15"> * limitations under the License.</a>
<span class="sourceLineNo">016</span><a id="line.16"> */</a>
<span class="sourceLineNo">017</span><a id="line.17">package org.apache.activemq.store.kahadb;</a>
<span class="sourceLineNo">018</span><a id="line.18"></a>
<span class="sourceLineNo">019</span><a id="line.19">import static org.apache.activemq.store.kahadb.disk.journal.Location.NOT_SET;</a>
<span class="sourceLineNo">020</span><a id="line.20"></a>
<span class="sourceLineNo">021</span><a id="line.21">import java.io.ByteArrayInputStream;</a>
<span class="sourceLineNo">022</span><a id="line.22">import java.io.ByteArrayOutputStream;</a>
<span class="sourceLineNo">023</span><a id="line.23">import java.io.DataInput;</a>
<span class="sourceLineNo">024</span><a id="line.24">import java.io.DataOutput;</a>
<span class="sourceLineNo">025</span><a id="line.25">import java.io.EOFException;</a>
<span class="sourceLineNo">026</span><a id="line.26">import java.io.File;</a>
<span class="sourceLineNo">027</span><a id="line.27">import java.io.IOException;</a>
<span class="sourceLineNo">028</span><a id="line.28">import java.io.InputStream;</a>
<span class="sourceLineNo">029</span><a id="line.29">import java.io.InterruptedIOException;</a>
<span class="sourceLineNo">030</span><a id="line.30">import java.io.InvalidClassException;</a>
<span class="sourceLineNo">031</span><a id="line.31">import java.io.ObjectInputStream;</a>
<span class="sourceLineNo">032</span><a id="line.32">import java.io.ObjectOutputStream;</a>
<span class="sourceLineNo">033</span><a id="line.33">import java.io.ObjectStreamClass;</a>
<span class="sourceLineNo">034</span><a id="line.34">import java.io.OutputStream;</a>
<span class="sourceLineNo">035</span><a id="line.35">import java.util.ArrayList;</a>
<span class="sourceLineNo">036</span><a id="line.36">import java.util.Arrays;</a>
<span class="sourceLineNo">037</span><a id="line.37">import java.util.Collection;</a>
<span class="sourceLineNo">038</span><a id="line.38">import java.util.Collections;</a>
<span class="sourceLineNo">039</span><a id="line.39">import java.util.Date;</a>
<span class="sourceLineNo">040</span><a id="line.40">import java.util.HashMap;</a>
<span class="sourceLineNo">041</span><a id="line.41">import java.util.HashSet;</a>
<span class="sourceLineNo">042</span><a id="line.42">import java.util.Iterator;</a>
<span class="sourceLineNo">043</span><a id="line.43">import java.util.LinkedHashMap;</a>
<span class="sourceLineNo">044</span><a id="line.44">import java.util.LinkedHashSet;</a>
<span class="sourceLineNo">045</span><a id="line.45">import java.util.LinkedList;</a>
<span class="sourceLineNo">046</span><a id="line.46">import java.util.List;</a>
<span class="sourceLineNo">047</span><a id="line.47">import java.util.Map;</a>
<span class="sourceLineNo">048</span><a id="line.48">import java.util.Map.Entry;</a>
<span class="sourceLineNo">049</span><a id="line.49">import java.util.Set;</a>
<span class="sourceLineNo">050</span><a id="line.50">import java.util.SortedSet;</a>
<span class="sourceLineNo">051</span><a id="line.51">import java.util.TreeSet;</a>
<span class="sourceLineNo">052</span><a id="line.52">import java.util.concurrent.ConcurrentHashMap;</a>
<span class="sourceLineNo">053</span><a id="line.53">import java.util.concurrent.ConcurrentMap;</a>
<span class="sourceLineNo">054</span><a id="line.54">import java.util.concurrent.Executors;</a>
<span class="sourceLineNo">055</span><a id="line.55">import java.util.concurrent.ScheduledExecutorService;</a>
<span class="sourceLineNo">056</span><a id="line.56">import java.util.concurrent.ThreadFactory;</a>
<span class="sourceLineNo">057</span><a id="line.57">import java.util.concurrent.TimeUnit;</a>
<span class="sourceLineNo">058</span><a id="line.58">import java.util.concurrent.atomic.AtomicBoolean;</a>
<span class="sourceLineNo">059</span><a id="line.59">import java.util.concurrent.atomic.AtomicLong;</a>
<span class="sourceLineNo">060</span><a id="line.60">import java.util.concurrent.atomic.AtomicReference;</a>
<span class="sourceLineNo">061</span><a id="line.61">import java.util.concurrent.locks.ReentrantReadWriteLock;</a>
<span class="sourceLineNo">062</span><a id="line.62"></a>
<span class="sourceLineNo">063</span><a id="line.63">import org.apache.activemq.ActiveMQMessageAuditNoSync;</a>
<span class="sourceLineNo">064</span><a id="line.64">import org.apache.activemq.broker.BrokerService;</a>
<span class="sourceLineNo">065</span><a id="line.65">import org.apache.activemq.broker.BrokerServiceAware;</a>
<span class="sourceLineNo">066</span><a id="line.66">import org.apache.activemq.broker.region.Destination;</a>
<span class="sourceLineNo">067</span><a id="line.67">import org.apache.activemq.broker.region.Queue;</a>
<span class="sourceLineNo">068</span><a id="line.68">import org.apache.activemq.broker.region.Topic;</a>
<span class="sourceLineNo">069</span><a id="line.69">import org.apache.activemq.command.TransactionId;</a>
<span class="sourceLineNo">070</span><a id="line.70">import org.apache.activemq.openwire.OpenWireFormat;</a>
<span class="sourceLineNo">071</span><a id="line.71">import org.apache.activemq.protobuf.Buffer;</a>
<span class="sourceLineNo">072</span><a id="line.72">import org.apache.activemq.store.MessageStore;</a>
<span class="sourceLineNo">073</span><a id="line.73">import org.apache.activemq.store.MessageStoreStatistics;</a>
<span class="sourceLineNo">074</span><a id="line.74">import org.apache.activemq.store.MessageStoreSubscriptionStatistics;</a>
<span class="sourceLineNo">075</span><a id="line.75">import org.apache.activemq.store.PersistenceAdapterStatistics;</a>
<span class="sourceLineNo">076</span><a id="line.76">import org.apache.activemq.store.TopicMessageStore;</a>
<span class="sourceLineNo">077</span><a id="line.77">import org.apache.activemq.store.kahadb.data.KahaAckMessageFileMapCommand;</a>
<span class="sourceLineNo">078</span><a id="line.78">import org.apache.activemq.store.kahadb.data.KahaAddMessageCommand;</a>
<span class="sourceLineNo">079</span><a id="line.79">import org.apache.activemq.store.kahadb.data.KahaCommitCommand;</a>
<span class="sourceLineNo">080</span><a id="line.80">import org.apache.activemq.store.kahadb.data.KahaDestination;</a>
<span class="sourceLineNo">081</span><a id="line.81">import org.apache.activemq.store.kahadb.data.KahaEntryType;</a>
<span class="sourceLineNo">082</span><a id="line.82">import org.apache.activemq.store.kahadb.data.KahaPrepareCommand;</a>
<span class="sourceLineNo">083</span><a id="line.83">import org.apache.activemq.store.kahadb.data.KahaProducerAuditCommand;</a>
<span class="sourceLineNo">084</span><a id="line.84">import org.apache.activemq.store.kahadb.data.KahaRemoveDestinationCommand;</a>
<span class="sourceLineNo">085</span><a id="line.85">import org.apache.activemq.store.kahadb.data.KahaRemoveMessageCommand;</a>
<span class="sourceLineNo">086</span><a id="line.86">import org.apache.activemq.store.kahadb.data.KahaRewrittenDataFileCommand;</a>
<span class="sourceLineNo">087</span><a id="line.87">import org.apache.activemq.store.kahadb.data.KahaRollbackCommand;</a>
<span class="sourceLineNo">088</span><a id="line.88">import org.apache.activemq.store.kahadb.data.KahaSubscriptionCommand;</a>
<span class="sourceLineNo">089</span><a id="line.89">import org.apache.activemq.store.kahadb.data.KahaTraceCommand;</a>
<span class="sourceLineNo">090</span><a id="line.90">import org.apache.activemq.store.kahadb.data.KahaTransactionInfo;</a>
<span class="sourceLineNo">091</span><a id="line.91">import org.apache.activemq.store.kahadb.data.KahaUpdateMessageCommand;</a>
<span class="sourceLineNo">092</span><a id="line.92">import org.apache.activemq.store.kahadb.disk.index.BTreeIndex;</a>
<span class="sourceLineNo">093</span><a id="line.93">import org.apache.activemq.store.kahadb.disk.index.BTreeVisitor;</a>
<span class="sourceLineNo">094</span><a id="line.94">import org.apache.activemq.store.kahadb.disk.index.ListIndex;</a>
<span class="sourceLineNo">095</span><a id="line.95">import org.apache.activemq.store.kahadb.disk.journal.DataFile;</a>
<span class="sourceLineNo">096</span><a id="line.96">import org.apache.activemq.store.kahadb.disk.journal.Journal;</a>
<span class="sourceLineNo">097</span><a id="line.97">import org.apache.activemq.store.kahadb.disk.journal.Journal.JournalDiskSyncStrategy;</a>
<span class="sourceLineNo">098</span><a id="line.98">import org.apache.activemq.store.kahadb.disk.journal.Location;</a>
<span class="sourceLineNo">099</span><a id="line.99">import org.apache.activemq.store.kahadb.disk.journal.TargetedDataFileAppender;</a>
<span class="sourceLineNo">100</span><a id="line.100">import org.apache.activemq.store.kahadb.disk.page.Page;</a>
<span class="sourceLineNo">101</span><a id="line.101">import org.apache.activemq.store.kahadb.disk.page.PageFile;</a>
<span class="sourceLineNo">102</span><a id="line.102">import org.apache.activemq.store.kahadb.disk.page.Transaction;</a>
<span class="sourceLineNo">103</span><a id="line.103">import org.apache.activemq.store.kahadb.disk.util.LocationMarshaller;</a>
<span class="sourceLineNo">104</span><a id="line.104">import org.apache.activemq.store.kahadb.disk.util.LongMarshaller;</a>
<span class="sourceLineNo">105</span><a id="line.105">import org.apache.activemq.store.kahadb.disk.util.Marshaller;</a>
<span class="sourceLineNo">106</span><a id="line.106">import org.apache.activemq.store.kahadb.disk.util.Sequence;</a>
<span class="sourceLineNo">107</span><a id="line.107">import org.apache.activemq.store.kahadb.disk.util.SequenceSet;</a>
<span class="sourceLineNo">108</span><a id="line.108">import org.apache.activemq.store.kahadb.disk.util.StringMarshaller;</a>
<span class="sourceLineNo">109</span><a id="line.109">import org.apache.activemq.store.kahadb.disk.util.VariableMarshaller;</a>
<span class="sourceLineNo">110</span><a id="line.110">import org.apache.activemq.util.ByteSequence;</a>
<span class="sourceLineNo">111</span><a id="line.111">import org.apache.activemq.util.DataByteArrayInputStream;</a>
<span class="sourceLineNo">112</span><a id="line.112">import org.apache.activemq.util.DataByteArrayOutputStream;</a>
<span class="sourceLineNo">113</span><a id="line.113">import org.apache.activemq.util.IOExceptionSupport;</a>
<span class="sourceLineNo">114</span><a id="line.114">import org.apache.activemq.util.IOHelper;</a>
<span class="sourceLineNo">115</span><a id="line.115">import org.apache.activemq.util.ServiceStopper;</a>
<span class="sourceLineNo">116</span><a id="line.116">import org.apache.activemq.util.ServiceSupport;</a>
<span class="sourceLineNo">117</span><a id="line.117">import org.apache.activemq.util.ThreadPoolUtils;</a>
<span class="sourceLineNo">118</span><a id="line.118">import org.slf4j.Logger;</a>
<span class="sourceLineNo">119</span><a id="line.119">import org.slf4j.LoggerFactory;</a>
<span class="sourceLineNo">120</span><a id="line.120">import org.slf4j.MDC;</a>
<span class="sourceLineNo">121</span><a id="line.121"></a>
<span class="sourceLineNo">122</span><a id="line.122">public abstract class MessageDatabase extends ServiceSupport implements BrokerServiceAware {</a>
<span class="sourceLineNo">123</span><a id="line.123"></a>
<span class="sourceLineNo">124</span><a id="line.124">    protected BrokerService brokerService;</a>
<span class="sourceLineNo">125</span><a id="line.125"></a>
<span class="sourceLineNo">126</span><a id="line.126">    public static final String PROPERTY_LOG_SLOW_ACCESS_TIME = "org.apache.activemq.store.kahadb.LOG_SLOW_ACCESS_TIME";</a>
<span class="sourceLineNo">127</span><a id="line.127">    public static final int LOG_SLOW_ACCESS_TIME = Integer.getInteger(PROPERTY_LOG_SLOW_ACCESS_TIME, 0);</a>
<span class="sourceLineNo">128</span><a id="line.128">    public static final File DEFAULT_DIRECTORY = new File("KahaDB");</a>
<span class="sourceLineNo">129</span><a id="line.129">    protected static final Buffer UNMATCHED;</a>
<span class="sourceLineNo">130</span><a id="line.130">    static {</a>
<span class="sourceLineNo">131</span><a id="line.131">        UNMATCHED = new Buffer(new byte[]{});</a>
<span class="sourceLineNo">132</span><a id="line.132">    }</a>
<span class="sourceLineNo">133</span><a id="line.133">    private static final Logger LOG = LoggerFactory.getLogger(MessageDatabase.class);</a>
<span class="sourceLineNo">134</span><a id="line.134"></a>
<span class="sourceLineNo">135</span><a id="line.135">    static final int CLOSED_STATE = 1;</a>
<span class="sourceLineNo">136</span><a id="line.136">    static final int OPEN_STATE = 2;</a>
<span class="sourceLineNo">137</span><a id="line.137">    static final long NOT_ACKED = -1;</a>
<span class="sourceLineNo">138</span><a id="line.138"></a>
<span class="sourceLineNo">139</span><a id="line.139">    static final int VERSION = 7;</a>
<span class="sourceLineNo">140</span><a id="line.140"></a>
<span class="sourceLineNo">141</span><a id="line.141">    static final byte COMPACTED_JOURNAL_FILE = DataFile.STANDARD_LOG_FILE + 1;</a>
<span class="sourceLineNo">142</span><a id="line.142"></a>
<span class="sourceLineNo">143</span><a id="line.143">    protected class Metadata {</a>
<span class="sourceLineNo">144</span><a id="line.144">        protected Page&lt;Metadata&gt; page;</a>
<span class="sourceLineNo">145</span><a id="line.145">        protected int state;</a>
<span class="sourceLineNo">146</span><a id="line.146">        protected BTreeIndex&lt;String, StoredDestination&gt; destinations;</a>
<span class="sourceLineNo">147</span><a id="line.147">        protected Location lastUpdate;</a>
<span class="sourceLineNo">148</span><a id="line.148">        protected Location firstInProgressTransactionLocation;</a>
<span class="sourceLineNo">149</span><a id="line.149">        protected Location producerSequenceIdTrackerLocation = null;</a>
<span class="sourceLineNo">150</span><a id="line.150">        protected Location ackMessageFileMapLocation = null;</a>
<span class="sourceLineNo">151</span><a id="line.151">        protected transient ActiveMQMessageAuditNoSync producerSequenceIdTracker = new ActiveMQMessageAuditNoSync();</a>
<span class="sourceLineNo">152</span><a id="line.152">        protected transient Map&lt;Integer, Set&lt;Integer&gt;&gt; ackMessageFileMap = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">153</span><a id="line.153">        protected transient AtomicBoolean ackMessageFileMapDirtyFlag = new AtomicBoolean(false);</a>
<span class="sourceLineNo">154</span><a id="line.154">        protected int version = VERSION;</a>
<span class="sourceLineNo">155</span><a id="line.155">        protected int openwireVersion = OpenWireFormat.DEFAULT_STORE_VERSION;</a>
<span class="sourceLineNo">156</span><a id="line.156"></a>
<span class="sourceLineNo">157</span><a id="line.157">        public void read(DataInput is) throws IOException {</a>
<span class="sourceLineNo">158</span><a id="line.158">            state = is.readInt();</a>
<span class="sourceLineNo">159</span><a id="line.159">            destinations = new BTreeIndex&lt;&gt;(pageFile, is.readLong());</a>
<span class="sourceLineNo">160</span><a id="line.160">            if (is.readBoolean()) {</a>
<span class="sourceLineNo">161</span><a id="line.161">                lastUpdate = LocationMarshaller.INSTANCE.readPayload(is);</a>
<span class="sourceLineNo">162</span><a id="line.162">            } else {</a>
<span class="sourceLineNo">163</span><a id="line.163">                lastUpdate = null;</a>
<span class="sourceLineNo">164</span><a id="line.164">            }</a>
<span class="sourceLineNo">165</span><a id="line.165">            if (is.readBoolean()) {</a>
<span class="sourceLineNo">166</span><a id="line.166">                firstInProgressTransactionLocation = LocationMarshaller.INSTANCE.readPayload(is);</a>
<span class="sourceLineNo">167</span><a id="line.167">            } else {</a>
<span class="sourceLineNo">168</span><a id="line.168">                firstInProgressTransactionLocation = null;</a>
<span class="sourceLineNo">169</span><a id="line.169">            }</a>
<span class="sourceLineNo">170</span><a id="line.170">            try {</a>
<span class="sourceLineNo">171</span><a id="line.171">                if (is.readBoolean()) {</a>
<span class="sourceLineNo">172</span><a id="line.172">                    producerSequenceIdTrackerLocation = LocationMarshaller.INSTANCE.readPayload(is);</a>
<span class="sourceLineNo">173</span><a id="line.173">                } else {</a>
<span class="sourceLineNo">174</span><a id="line.174">                    producerSequenceIdTrackerLocation = null;</a>
<span class="sourceLineNo">175</span><a id="line.175">                }</a>
<span class="sourceLineNo">176</span><a id="line.176">            } catch (EOFException expectedOnUpgrade) {</a>
<span class="sourceLineNo">177</span><a id="line.177">            }</a>
<span class="sourceLineNo">178</span><a id="line.178">            try {</a>
<span class="sourceLineNo">179</span><a id="line.179">                version = is.readInt();</a>
<span class="sourceLineNo">180</span><a id="line.180">            } catch (EOFException expectedOnUpgrade) {</a>
<span class="sourceLineNo">181</span><a id="line.181">                version = 1;</a>
<span class="sourceLineNo">182</span><a id="line.182">            }</a>
<span class="sourceLineNo">183</span><a id="line.183">            if (version &gt;= 5 &amp;&amp; is.readBoolean()) {</a>
<span class="sourceLineNo">184</span><a id="line.184">                ackMessageFileMapLocation = LocationMarshaller.INSTANCE.readPayload(is);</a>
<span class="sourceLineNo">185</span><a id="line.185">            } else {</a>
<span class="sourceLineNo">186</span><a id="line.186">                ackMessageFileMapLocation = null;</a>
<span class="sourceLineNo">187</span><a id="line.187">            }</a>
<span class="sourceLineNo">188</span><a id="line.188">            try {</a>
<span class="sourceLineNo">189</span><a id="line.189">                openwireVersion = is.readInt();</a>
<span class="sourceLineNo">190</span><a id="line.190">            } catch (EOFException expectedOnUpgrade) {</a>
<span class="sourceLineNo">191</span><a id="line.191">                openwireVersion = OpenWireFormat.DEFAULT_LEGACY_VERSION;</a>
<span class="sourceLineNo">192</span><a id="line.192">            }</a>
<span class="sourceLineNo">193</span><a id="line.193"></a>
<span class="sourceLineNo">194</span><a id="line.194">            LOG.info("KahaDB is version " + version);</a>
<span class="sourceLineNo">195</span><a id="line.195">        }</a>
<span class="sourceLineNo">196</span><a id="line.196"></a>
<span class="sourceLineNo">197</span><a id="line.197">        public void write(DataOutput os) throws IOException {</a>
<span class="sourceLineNo">198</span><a id="line.198">            os.writeInt(state);</a>
<span class="sourceLineNo">199</span><a id="line.199">            os.writeLong(destinations.getPageId());</a>
<span class="sourceLineNo">200</span><a id="line.200"></a>
<span class="sourceLineNo">201</span><a id="line.201">            if (lastUpdate != null) {</a>
<span class="sourceLineNo">202</span><a id="line.202">                os.writeBoolean(true);</a>
<span class="sourceLineNo">203</span><a id="line.203">                LocationMarshaller.INSTANCE.writePayload(lastUpdate, os);</a>
<span class="sourceLineNo">204</span><a id="line.204">            } else {</a>
<span class="sourceLineNo">205</span><a id="line.205">                os.writeBoolean(false);</a>
<span class="sourceLineNo">206</span><a id="line.206">            }</a>
<span class="sourceLineNo">207</span><a id="line.207"></a>
<span class="sourceLineNo">208</span><a id="line.208">            if (firstInProgressTransactionLocation != null) {</a>
<span class="sourceLineNo">209</span><a id="line.209">                os.writeBoolean(true);</a>
<span class="sourceLineNo">210</span><a id="line.210">                LocationMarshaller.INSTANCE.writePayload(firstInProgressTransactionLocation, os);</a>
<span class="sourceLineNo">211</span><a id="line.211">            } else {</a>
<span class="sourceLineNo">212</span><a id="line.212">                os.writeBoolean(false);</a>
<span class="sourceLineNo">213</span><a id="line.213">            }</a>
<span class="sourceLineNo">214</span><a id="line.214"></a>
<span class="sourceLineNo">215</span><a id="line.215">            if (producerSequenceIdTrackerLocation != null) {</a>
<span class="sourceLineNo">216</span><a id="line.216">                os.writeBoolean(true);</a>
<span class="sourceLineNo">217</span><a id="line.217">                LocationMarshaller.INSTANCE.writePayload(producerSequenceIdTrackerLocation, os);</a>
<span class="sourceLineNo">218</span><a id="line.218">            } else {</a>
<span class="sourceLineNo">219</span><a id="line.219">                os.writeBoolean(false);</a>
<span class="sourceLineNo">220</span><a id="line.220">            }</a>
<span class="sourceLineNo">221</span><a id="line.221">            os.writeInt(VERSION);</a>
<span class="sourceLineNo">222</span><a id="line.222">            if (ackMessageFileMapLocation != null) {</a>
<span class="sourceLineNo">223</span><a id="line.223">                os.writeBoolean(true);</a>
<span class="sourceLineNo">224</span><a id="line.224">                LocationMarshaller.INSTANCE.writePayload(ackMessageFileMapLocation, os);</a>
<span class="sourceLineNo">225</span><a id="line.225">            } else {</a>
<span class="sourceLineNo">226</span><a id="line.226">                os.writeBoolean(false);</a>
<span class="sourceLineNo">227</span><a id="line.227">            }</a>
<span class="sourceLineNo">228</span><a id="line.228">            os.writeInt(this.openwireVersion);</a>
<span class="sourceLineNo">229</span><a id="line.229">        }</a>
<span class="sourceLineNo">230</span><a id="line.230">    }</a>
<span class="sourceLineNo">231</span><a id="line.231"></a>
<span class="sourceLineNo">232</span><a id="line.232">    class MetadataMarshaller extends VariableMarshaller&lt;Metadata&gt; {</a>
<span class="sourceLineNo">233</span><a id="line.233">        @Override</a>
<span class="sourceLineNo">234</span><a id="line.234">        public Metadata readPayload(DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">235</span><a id="line.235">            Metadata rc = createMetadata();</a>
<span class="sourceLineNo">236</span><a id="line.236">            rc.read(dataIn);</a>
<span class="sourceLineNo">237</span><a id="line.237">            return rc;</a>
<span class="sourceLineNo">238</span><a id="line.238">        }</a>
<span class="sourceLineNo">239</span><a id="line.239"></a>
<span class="sourceLineNo">240</span><a id="line.240">        @Override</a>
<span class="sourceLineNo">241</span><a id="line.241">        public void writePayload(Metadata object, DataOutput dataOut) throws IOException {</a>
<span class="sourceLineNo">242</span><a id="line.242">            object.write(dataOut);</a>
<span class="sourceLineNo">243</span><a id="line.243">        }</a>
<span class="sourceLineNo">244</span><a id="line.244">    }</a>
<span class="sourceLineNo">245</span><a id="line.245"></a>
<span class="sourceLineNo">246</span><a id="line.246">    public enum PurgeRecoveredXATransactionStrategy {</a>
<span class="sourceLineNo">247</span><a id="line.247">        NEVER,</a>
<span class="sourceLineNo">248</span><a id="line.248">        COMMIT,</a>
<span class="sourceLineNo">249</span><a id="line.249">        ROLLBACK;</a>
<span class="sourceLineNo">250</span><a id="line.250">    }</a>
<span class="sourceLineNo">251</span><a id="line.251"></a>
<span class="sourceLineNo">252</span><a id="line.252">    protected PageFile pageFile;</a>
<span class="sourceLineNo">253</span><a id="line.253">    protected Journal journal;</a>
<span class="sourceLineNo">254</span><a id="line.254">    protected Metadata metadata = new Metadata();</a>
<span class="sourceLineNo">255</span><a id="line.255">    protected final PersistenceAdapterStatistics persistenceAdapterStatistics = new PersistenceAdapterStatistics();</a>
<span class="sourceLineNo">256</span><a id="line.256"></a>
<span class="sourceLineNo">257</span><a id="line.257">    protected MetadataMarshaller metadataMarshaller = new MetadataMarshaller();</a>
<span class="sourceLineNo">258</span><a id="line.258"></a>
<span class="sourceLineNo">259</span><a id="line.259">    protected boolean failIfDatabaseIsLocked;</a>
<span class="sourceLineNo">260</span><a id="line.260"></a>
<span class="sourceLineNo">261</span><a id="line.261">    protected boolean deleteAllMessages;</a>
<span class="sourceLineNo">262</span><a id="line.262">    protected File directory = DEFAULT_DIRECTORY;</a>
<span class="sourceLineNo">263</span><a id="line.263">    protected File indexDirectory = null;</a>
<span class="sourceLineNo">264</span><a id="line.264">    protected ScheduledExecutorService scheduler;</a>
<span class="sourceLineNo">265</span><a id="line.265">    private final Object schedulerLock = new Object();</a>
<span class="sourceLineNo">266</span><a id="line.266"></a>
<span class="sourceLineNo">267</span><a id="line.267">    protected JournalDiskSyncStrategy journalDiskSyncStrategy = JournalDiskSyncStrategy.ALWAYS;</a>
<span class="sourceLineNo">268</span><a id="line.268">    protected boolean archiveDataLogs;</a>
<span class="sourceLineNo">269</span><a id="line.269">    protected File directoryArchive;</a>
<span class="sourceLineNo">270</span><a id="line.270">    protected AtomicLong journalSize = new AtomicLong(0);</a>
<span class="sourceLineNo">271</span><a id="line.271">    long journalDiskSyncInterval = 1000;</a>
<span class="sourceLineNo">272</span><a id="line.272">    long checkpointInterval = 5*1000;</a>
<span class="sourceLineNo">273</span><a id="line.273">    long cleanupInterval = 30*1000;</a>
<span class="sourceLineNo">274</span><a id="line.274">    boolean cleanupOnStop = true;</a>
<span class="sourceLineNo">275</span><a id="line.275">    int journalMaxFileLength = Journal.DEFAULT_MAX_FILE_LENGTH;</a>
<span class="sourceLineNo">276</span><a id="line.276">    int journalMaxWriteBatchSize = Journal.DEFAULT_MAX_WRITE_BATCH_SIZE;</a>
<span class="sourceLineNo">277</span><a id="line.277">    boolean enableIndexWriteAsync = false;</a>
<span class="sourceLineNo">278</span><a id="line.278">    int setIndexWriteBatchSize = PageFile.DEFAULT_WRITE_BATCH_SIZE;</a>
<span class="sourceLineNo">279</span><a id="line.279">    private String preallocationScope = Journal.PreallocationScope.ENTIRE_JOURNAL.name();</a>
<span class="sourceLineNo">280</span><a id="line.280">    private String preallocationStrategy = Journal.PreallocationStrategy.SPARSE_FILE.name();</a>
<span class="sourceLineNo">281</span><a id="line.281"></a>
<span class="sourceLineNo">282</span><a id="line.282">    protected AtomicBoolean opened = new AtomicBoolean();</a>
<span class="sourceLineNo">283</span><a id="line.283">    private boolean ignoreMissingJournalfiles = false;</a>
<span class="sourceLineNo">284</span><a id="line.284">    private int indexCacheSize = 10000;</a>
<span class="sourceLineNo">285</span><a id="line.285">    private boolean checkForCorruptJournalFiles = false;</a>
<span class="sourceLineNo">286</span><a id="line.286">    protected PurgeRecoveredXATransactionStrategy purgeRecoveredXATransactionStrategy = PurgeRecoveredXATransactionStrategy.NEVER;</a>
<span class="sourceLineNo">287</span><a id="line.287">    private boolean checksumJournalFiles = true;</a>
<span class="sourceLineNo">288</span><a id="line.288">    protected boolean forceRecoverIndex = false;</a>
<span class="sourceLineNo">289</span><a id="line.289">    private boolean archiveCorruptedIndex = false;</a>
<span class="sourceLineNo">290</span><a id="line.290">    private boolean useIndexLFRUEviction = false;</a>
<span class="sourceLineNo">291</span><a id="line.291">    private float indexLFUEvictionFactor = 0.2f;</a>
<span class="sourceLineNo">292</span><a id="line.292">    private boolean enableIndexDiskSyncs = true;</a>
<span class="sourceLineNo">293</span><a id="line.293">    private boolean enableIndexRecoveryFile = true;</a>
<span class="sourceLineNo">294</span><a id="line.294">    private boolean enableIndexPageCaching = true;</a>
<span class="sourceLineNo">295</span><a id="line.295">    ReentrantReadWriteLock checkpointLock = new ReentrantReadWriteLock();</a>
<span class="sourceLineNo">296</span><a id="line.296"></a>
<span class="sourceLineNo">297</span><a id="line.297">    private boolean enableAckCompaction = true;</a>
<span class="sourceLineNo">298</span><a id="line.298">    private int compactAcksAfterNoGC = 10;</a>
<span class="sourceLineNo">299</span><a id="line.299">    private boolean compactAcksIgnoresStoreGrowth = false;</a>
<span class="sourceLineNo">300</span><a id="line.300">    private int checkPointCyclesWithNoGC;</a>
<span class="sourceLineNo">301</span><a id="line.301">    private int journalLogOnLastCompactionCheck;</a>
<span class="sourceLineNo">302</span><a id="line.302">    private boolean enableSubscriptionStatistics = false;</a>
<span class="sourceLineNo">303</span><a id="line.303"></a>
<span class="sourceLineNo">304</span><a id="line.304">    //only set when using JournalDiskSyncStrategy.PERIODIC</a>
<span class="sourceLineNo">305</span><a id="line.305">    protected final AtomicReference&lt;Location&gt; lastAsyncJournalUpdate = new AtomicReference&lt;&gt;();</a>
<span class="sourceLineNo">306</span><a id="line.306"></a>
<span class="sourceLineNo">307</span><a id="line.307">    @Override</a>
<span class="sourceLineNo">308</span><a id="line.308">    public void doStart() throws Exception {</a>
<span class="sourceLineNo">309</span><a id="line.309">        load();</a>
<span class="sourceLineNo">310</span><a id="line.310">    }</a>
<span class="sourceLineNo">311</span><a id="line.311"></a>
<span class="sourceLineNo">312</span><a id="line.312">    @Override</a>
<span class="sourceLineNo">313</span><a id="line.313">    public void doStop(ServiceStopper stopper) throws Exception {</a>
<span class="sourceLineNo">314</span><a id="line.314">        unload();</a>
<span class="sourceLineNo">315</span><a id="line.315">    }</a>
<span class="sourceLineNo">316</span><a id="line.316"></a>
<span class="sourceLineNo">317</span><a id="line.317">    public void allowIOResumption() {</a>
<span class="sourceLineNo">318</span><a id="line.318">        if (pageFile != null) {</a>
<span class="sourceLineNo">319</span><a id="line.319">            pageFile.allowIOResumption();</a>
<span class="sourceLineNo">320</span><a id="line.320">        }</a>
<span class="sourceLineNo">321</span><a id="line.321">        if (journal != null) {</a>
<span class="sourceLineNo">322</span><a id="line.322">            journal.allowIOResumption();</a>
<span class="sourceLineNo">323</span><a id="line.323">        }</a>
<span class="sourceLineNo">324</span><a id="line.324">    }</a>
<span class="sourceLineNo">325</span><a id="line.325"></a>
<span class="sourceLineNo">326</span><a id="line.326">    private void loadPageFile() throws IOException {</a>
<span class="sourceLineNo">327</span><a id="line.327">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">328</span><a id="line.328">        try {</a>
<span class="sourceLineNo">329</span><a id="line.329">            final PageFile pageFile = getPageFile();</a>
<span class="sourceLineNo">330</span><a id="line.330">            pageFile.load();</a>
<span class="sourceLineNo">331</span><a id="line.331">            pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">332</span><a id="line.332">                @Override</a>
<span class="sourceLineNo">333</span><a id="line.333">                public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">334</span><a id="line.334">                    if (pageFile.getPageCount() == 0) {</a>
<span class="sourceLineNo">335</span><a id="line.335">                        // First time this is created.. Initialize the metadata</a>
<span class="sourceLineNo">336</span><a id="line.336">                        Page&lt;Metadata&gt; page = tx.allocate();</a>
<span class="sourceLineNo">337</span><a id="line.337">                        assert page.getPageId() == 0;</a>
<span class="sourceLineNo">338</span><a id="line.338">                        page.set(metadata);</a>
<span class="sourceLineNo">339</span><a id="line.339">                        metadata.page = page;</a>
<span class="sourceLineNo">340</span><a id="line.340">                        metadata.state = CLOSED_STATE;</a>
<span class="sourceLineNo">341</span><a id="line.341">                        metadata.destinations = new BTreeIndex&lt;&gt;(pageFile, tx.allocate().getPageId());</a>
<span class="sourceLineNo">342</span><a id="line.342"></a>
<span class="sourceLineNo">343</span><a id="line.343">                        tx.store(metadata.page, metadataMarshaller, true);</a>
<span class="sourceLineNo">344</span><a id="line.344">                    } else {</a>
<span class="sourceLineNo">345</span><a id="line.345">                        Page&lt;Metadata&gt; page = tx.load(0, metadataMarshaller);</a>
<span class="sourceLineNo">346</span><a id="line.346">                        metadata = page.get();</a>
<span class="sourceLineNo">347</span><a id="line.347">                        metadata.page = page;</a>
<span class="sourceLineNo">348</span><a id="line.348">                    }</a>
<span class="sourceLineNo">349</span><a id="line.349">                    metadata.destinations.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">350</span><a id="line.350">                    metadata.destinations.setValueMarshaller(new StoredDestinationMarshaller());</a>
<span class="sourceLineNo">351</span><a id="line.351">                    metadata.destinations.load(tx);</a>
<span class="sourceLineNo">352</span><a id="line.352">                }</a>
<span class="sourceLineNo">353</span><a id="line.353">            });</a>
<span class="sourceLineNo">354</span><a id="line.354">            // Load up all the destinations since we need to scan all the indexes to figure out which journal files can be deleted.</a>
<span class="sourceLineNo">355</span><a id="line.355">            // Perhaps we should just keep an index of file</a>
<span class="sourceLineNo">356</span><a id="line.356">            storedDestinations.clear();</a>
<span class="sourceLineNo">357</span><a id="line.357">            pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">358</span><a id="line.358">                @Override</a>
<span class="sourceLineNo">359</span><a id="line.359">                public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">360</span><a id="line.360">                    for (Iterator&lt;Entry&lt;String, StoredDestination&gt;&gt; iterator = metadata.destinations.iterator(tx); iterator.hasNext();) {</a>
<span class="sourceLineNo">361</span><a id="line.361">                        Entry&lt;String, StoredDestination&gt; entry = iterator.next();</a>
<span class="sourceLineNo">362</span><a id="line.362">                        StoredDestination sd = loadStoredDestination(tx, entry.getKey(), entry.getValue().subscriptions!=null);</a>
<span class="sourceLineNo">363</span><a id="line.363">                        storedDestinations.put(entry.getKey(), sd);</a>
<span class="sourceLineNo">364</span><a id="line.364"></a>
<span class="sourceLineNo">365</span><a id="line.365">                        if (checkForCorruptJournalFiles) {</a>
<span class="sourceLineNo">366</span><a id="line.366">                            // sanity check the index also</a>
<span class="sourceLineNo">367</span><a id="line.367">                            if (!entry.getValue().locationIndex.isEmpty(tx)) {</a>
<span class="sourceLineNo">368</span><a id="line.368">                                if (entry.getValue().orderIndex.nextMessageId &lt;= 0) {</a>
<span class="sourceLineNo">369</span><a id="line.369">                                    throw new IOException("Detected uninitialized orderIndex nextMessageId with pending messages for " + entry.getKey());</a>
<span class="sourceLineNo">370</span><a id="line.370">                                }</a>
<span class="sourceLineNo">371</span><a id="line.371">                            }</a>
<span class="sourceLineNo">372</span><a id="line.372">                        }</a>
<span class="sourceLineNo">373</span><a id="line.373">                    }</a>
<span class="sourceLineNo">374</span><a id="line.374">                }</a>
<span class="sourceLineNo">375</span><a id="line.375">            });</a>
<span class="sourceLineNo">376</span><a id="line.376">            pageFile.flush();</a>
<span class="sourceLineNo">377</span><a id="line.377">        } finally {</a>
<span class="sourceLineNo">378</span><a id="line.378">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">379</span><a id="line.379">        }</a>
<span class="sourceLineNo">380</span><a id="line.380">    }</a>
<span class="sourceLineNo">381</span><a id="line.381"></a>
<span class="sourceLineNo">382</span><a id="line.382">    private void startCheckpoint() {</a>
<span class="sourceLineNo">383</span><a id="line.383">        if (checkpointInterval == 0 &amp;&amp; cleanupInterval == 0) {</a>
<span class="sourceLineNo">384</span><a id="line.384">            LOG.info("periodic checkpoint/cleanup disabled, will occur on clean " + (getCleanupOnStop() ? "shutdown/" : "") + "restart");</a>
<span class="sourceLineNo">385</span><a id="line.385">            return;</a>
<span class="sourceLineNo">386</span><a id="line.386">        }</a>
<span class="sourceLineNo">387</span><a id="line.387">        synchronized (schedulerLock) {</a>
<span class="sourceLineNo">388</span><a id="line.388">            if (scheduler == null || scheduler.isShutdown()) {</a>
<span class="sourceLineNo">389</span><a id="line.389">                scheduler = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</a>
<span class="sourceLineNo">390</span><a id="line.390"></a>
<span class="sourceLineNo">391</span><a id="line.391">                    @Override</a>
<span class="sourceLineNo">392</span><a id="line.392">                    public Thread newThread(Runnable r) {</a>
<span class="sourceLineNo">393</span><a id="line.393">                        Thread schedulerThread = new Thread(r);</a>
<span class="sourceLineNo">394</span><a id="line.394"></a>
<span class="sourceLineNo">395</span><a id="line.395">                        schedulerThread.setName("ActiveMQ Journal Checkpoint Worker");</a>
<span class="sourceLineNo">396</span><a id="line.396">                        schedulerThread.setDaemon(true);</a>
<span class="sourceLineNo">397</span><a id="line.397"></a>
<span class="sourceLineNo">398</span><a id="line.398">                        return schedulerThread;</a>
<span class="sourceLineNo">399</span><a id="line.399">                    }</a>
<span class="sourceLineNo">400</span><a id="line.400">                });</a>
<span class="sourceLineNo">401</span><a id="line.401"></a>
<span class="sourceLineNo">402</span><a id="line.402">                // Short intervals for check-point and cleanups</a>
<span class="sourceLineNo">403</span><a id="line.403">                long delay;</a>
<span class="sourceLineNo">404</span><a id="line.404">                if (journal.isJournalDiskSyncPeriodic()) {</a>
<span class="sourceLineNo">405</span><a id="line.405">                    delay = Math.min(journalDiskSyncInterval &gt; 0 ? journalDiskSyncInterval : checkpointInterval, 500);</a>
<span class="sourceLineNo">406</span><a id="line.406">                } else {</a>
<span class="sourceLineNo">407</span><a id="line.407">                    delay = Math.min(checkpointInterval &gt; 0 ? checkpointInterval : cleanupInterval, 500);</a>
<span class="sourceLineNo">408</span><a id="line.408">                }</a>
<span class="sourceLineNo">409</span><a id="line.409"></a>
<span class="sourceLineNo">410</span><a id="line.410">                scheduler.scheduleWithFixedDelay(new CheckpointRunner(), 0, delay, TimeUnit.MILLISECONDS);</a>
<span class="sourceLineNo">411</span><a id="line.411">            }</a>
<span class="sourceLineNo">412</span><a id="line.412">        }</a>
<span class="sourceLineNo">413</span><a id="line.413">    }</a>
<span class="sourceLineNo">414</span><a id="line.414"></a>
<span class="sourceLineNo">415</span><a id="line.415">    private final class CheckpointRunner implements Runnable {</a>
<span class="sourceLineNo">416</span><a id="line.416"></a>
<span class="sourceLineNo">417</span><a id="line.417">        private long lastCheckpoint = System.currentTimeMillis();</a>
<span class="sourceLineNo">418</span><a id="line.418">        private long lastCleanup = System.currentTimeMillis();</a>
<span class="sourceLineNo">419</span><a id="line.419">        private long lastSync = System.currentTimeMillis();</a>
<span class="sourceLineNo">420</span><a id="line.420">        private Location lastAsyncUpdate = null;</a>
<span class="sourceLineNo">421</span><a id="line.421"></a>
<span class="sourceLineNo">422</span><a id="line.422">        @Override</a>
<span class="sourceLineNo">423</span><a id="line.423">        public void run() {</a>
<span class="sourceLineNo">424</span><a id="line.424">            try {</a>
<span class="sourceLineNo">425</span><a id="line.425">                // Decide on cleanup vs full checkpoint here.</a>
<span class="sourceLineNo">426</span><a id="line.426">                if (opened.get()) {</a>
<span class="sourceLineNo">427</span><a id="line.427">                    long now = System.currentTimeMillis();</a>
<span class="sourceLineNo">428</span><a id="line.428">                    if (journal.isJournalDiskSyncPeriodic() &amp;&amp;</a>
<span class="sourceLineNo">429</span><a id="line.429">                            journalDiskSyncInterval &gt; 0 &amp;&amp; (now - lastSync &gt;= journalDiskSyncInterval)) {</a>
<span class="sourceLineNo">430</span><a id="line.430">                        Location currentUpdate = lastAsyncJournalUpdate.get();</a>
<span class="sourceLineNo">431</span><a id="line.431">                        if (currentUpdate != null &amp;&amp; !currentUpdate.equals(lastAsyncUpdate)) {</a>
<span class="sourceLineNo">432</span><a id="line.432">                            lastAsyncUpdate = currentUpdate;</a>
<span class="sourceLineNo">433</span><a id="line.433">                            if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">434</span><a id="line.434">                                LOG.trace("Writing trace command to trigger journal sync");</a>
<span class="sourceLineNo">435</span><a id="line.435">                            }</a>
<span class="sourceLineNo">436</span><a id="line.436">                            store(new KahaTraceCommand(), true, null, null);</a>
<span class="sourceLineNo">437</span><a id="line.437">                        }</a>
<span class="sourceLineNo">438</span><a id="line.438">                        lastSync = now;</a>
<span class="sourceLineNo">439</span><a id="line.439">                    }</a>
<span class="sourceLineNo">440</span><a id="line.440">                    if (cleanupInterval &gt; 0 &amp;&amp; (now - lastCleanup &gt;= cleanupInterval)) {</a>
<span class="sourceLineNo">441</span><a id="line.441">                        checkpointCleanup(true);</a>
<span class="sourceLineNo">442</span><a id="line.442">                        lastCleanup = now;</a>
<span class="sourceLineNo">443</span><a id="line.443">                        lastCheckpoint = now;</a>
<span class="sourceLineNo">444</span><a id="line.444">                    } else if (checkpointInterval &gt; 0 &amp;&amp; (now - lastCheckpoint &gt;= checkpointInterval)) {</a>
<span class="sourceLineNo">445</span><a id="line.445">                        checkpointCleanup(false);</a>
<span class="sourceLineNo">446</span><a id="line.446">                        lastCheckpoint = now;</a>
<span class="sourceLineNo">447</span><a id="line.447">                    }</a>
<span class="sourceLineNo">448</span><a id="line.448">                }</a>
<span class="sourceLineNo">449</span><a id="line.449">            } catch (IOException ioe) {</a>
<span class="sourceLineNo">450</span><a id="line.450">                LOG.error("Checkpoint failed", ioe);</a>
<span class="sourceLineNo">451</span><a id="line.451">                brokerService.handleIOException(ioe);</a>
<span class="sourceLineNo">452</span><a id="line.452">            } catch (Throwable e) {</a>
<span class="sourceLineNo">453</span><a id="line.453">                LOG.error("Checkpoint failed", e);</a>
<span class="sourceLineNo">454</span><a id="line.454">                brokerService.handleIOException(IOExceptionSupport.create(e));</a>
<span class="sourceLineNo">455</span><a id="line.455">            }</a>
<span class="sourceLineNo">456</span><a id="line.456">        }</a>
<span class="sourceLineNo">457</span><a id="line.457">    }</a>
<span class="sourceLineNo">458</span><a id="line.458"></a>
<span class="sourceLineNo">459</span><a id="line.459">    public void open() throws IOException {</a>
<span class="sourceLineNo">460</span><a id="line.460">        if( opened.compareAndSet(false, true) ) {</a>
<span class="sourceLineNo">461</span><a id="line.461">            getJournal().start();</a>
<span class="sourceLineNo">462</span><a id="line.462">            try {</a>
<span class="sourceLineNo">463</span><a id="line.463">                loadPageFile();</a>
<span class="sourceLineNo">464</span><a id="line.464">            } catch (Throwable t) {</a>
<span class="sourceLineNo">465</span><a id="line.465">                LOG.warn("Index corrupted. Recovering the index through journal replay. Cause:" + t);</a>
<span class="sourceLineNo">466</span><a id="line.466">                if (LOG.isDebugEnabled()) {</a>
<span class="sourceLineNo">467</span><a id="line.467">                    LOG.debug("Index load failure", t);</a>
<span class="sourceLineNo">468</span><a id="line.468">                }</a>
<span class="sourceLineNo">469</span><a id="line.469">                // try to recover index</a>
<span class="sourceLineNo">470</span><a id="line.470">                try {</a>
<span class="sourceLineNo">471</span><a id="line.471">                    pageFile.unload();</a>
<span class="sourceLineNo">472</span><a id="line.472">                } catch (Exception ignore) {}</a>
<span class="sourceLineNo">473</span><a id="line.473">                if (archiveCorruptedIndex) {</a>
<span class="sourceLineNo">474</span><a id="line.474">                    pageFile.archive();</a>
<span class="sourceLineNo">475</span><a id="line.475">                } else {</a>
<span class="sourceLineNo">476</span><a id="line.476">                    pageFile.delete();</a>
<span class="sourceLineNo">477</span><a id="line.477">                }</a>
<span class="sourceLineNo">478</span><a id="line.478">                metadata = createMetadata();</a>
<span class="sourceLineNo">479</span><a id="line.479">                //The metadata was recreated after a detect corruption so we need to</a>
<span class="sourceLineNo">480</span><a id="line.480">                //reconfigure anything that was configured on the old metadata on startup</a>
<span class="sourceLineNo">481</span><a id="line.481">                configureMetadata();</a>
<span class="sourceLineNo">482</span><a id="line.482">                pageFile = null;</a>
<span class="sourceLineNo">483</span><a id="line.483">                loadPageFile();</a>
<span class="sourceLineNo">484</span><a id="line.484">            }</a>
<span class="sourceLineNo">485</span><a id="line.485">            recover();</a>
<span class="sourceLineNo">486</span><a id="line.486">            startCheckpoint();</a>
<span class="sourceLineNo">487</span><a id="line.487">        }</a>
<span class="sourceLineNo">488</span><a id="line.488">    }</a>
<span class="sourceLineNo">489</span><a id="line.489"></a>
<span class="sourceLineNo">490</span><a id="line.490">    public void load() throws IOException {</a>
<span class="sourceLineNo">491</span><a id="line.491">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">492</span><a id="line.492">        try {</a>
<span class="sourceLineNo">493</span><a id="line.493">            IOHelper.mkdirs(directory);</a>
<span class="sourceLineNo">494</span><a id="line.494">            if (deleteAllMessages) {</a>
<span class="sourceLineNo">495</span><a id="line.495">                getJournal().setCheckForCorruptionOnStartup(false);</a>
<span class="sourceLineNo">496</span><a id="line.496">                getJournal().start();</a>
<span class="sourceLineNo">497</span><a id="line.497">                getJournal().delete();</a>
<span class="sourceLineNo">498</span><a id="line.498">                getJournal().close();</a>
<span class="sourceLineNo">499</span><a id="line.499">                journal = null;</a>
<span class="sourceLineNo">500</span><a id="line.500">                getPageFile().delete();</a>
<span class="sourceLineNo">501</span><a id="line.501">                LOG.info("Persistence store purged.");</a>
<span class="sourceLineNo">502</span><a id="line.502">                deleteAllMessages = false;</a>
<span class="sourceLineNo">503</span><a id="line.503">            }</a>
<span class="sourceLineNo">504</span><a id="line.504"></a>
<span class="sourceLineNo">505</span><a id="line.505">            open();</a>
<span class="sourceLineNo">506</span><a id="line.506">            store(new KahaTraceCommand().setMessage("LOADED " + new Date()));</a>
<span class="sourceLineNo">507</span><a id="line.507">        } finally {</a>
<span class="sourceLineNo">508</span><a id="line.508">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">509</span><a id="line.509">        }</a>
<span class="sourceLineNo">510</span><a id="line.510">    }</a>
<span class="sourceLineNo">511</span><a id="line.511"></a>
<span class="sourceLineNo">512</span><a id="line.512">    public void close() throws IOException, InterruptedException {</a>
<span class="sourceLineNo">513</span><a id="line.513">        if (opened.compareAndSet(true, false)) {</a>
<span class="sourceLineNo">514</span><a id="line.514">            checkpointLock.writeLock().lock();</a>
<span class="sourceLineNo">515</span><a id="line.515">            try {</a>
<span class="sourceLineNo">516</span><a id="line.516">                if (metadata.page != null) {</a>
<span class="sourceLineNo">517</span><a id="line.517">                    checkpointUpdate(getCleanupOnStop());</a>
<span class="sourceLineNo">518</span><a id="line.518">                }</a>
<span class="sourceLineNo">519</span><a id="line.519">                pageFile.unload();</a>
<span class="sourceLineNo">520</span><a id="line.520">                metadata = createMetadata();</a>
<span class="sourceLineNo">521</span><a id="line.521">            } finally {</a>
<span class="sourceLineNo">522</span><a id="line.522">                checkpointLock.writeLock().unlock();</a>
<span class="sourceLineNo">523</span><a id="line.523">            }</a>
<span class="sourceLineNo">524</span><a id="line.524">            journal.close();</a>
<span class="sourceLineNo">525</span><a id="line.525">            synchronized(schedulerLock) {</a>
<span class="sourceLineNo">526</span><a id="line.526">                if (scheduler != null) {</a>
<span class="sourceLineNo">527</span><a id="line.527">                    ThreadPoolUtils.shutdownGraceful(scheduler, -1);</a>
<span class="sourceLineNo">528</span><a id="line.528">                    scheduler = null;</a>
<span class="sourceLineNo">529</span><a id="line.529">                }</a>
<span class="sourceLineNo">530</span><a id="line.530">            }</a>
<span class="sourceLineNo">531</span><a id="line.531">            // clear the cache and journalSize on shutdown of the store</a>
<span class="sourceLineNo">532</span><a id="line.532">            storeCache.clear();</a>
<span class="sourceLineNo">533</span><a id="line.533">            journalSize.set(0);</a>
<span class="sourceLineNo">534</span><a id="line.534">        }</a>
<span class="sourceLineNo">535</span><a id="line.535">    }</a>
<span class="sourceLineNo">536</span><a id="line.536"></a>
<span class="sourceLineNo">537</span><a id="line.537">    public void unload() throws IOException, InterruptedException {</a>
<span class="sourceLineNo">538</span><a id="line.538">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">539</span><a id="line.539">        try {</a>
<span class="sourceLineNo">540</span><a id="line.540">            if( pageFile != null &amp;&amp; pageFile.isLoaded() ) {</a>
<span class="sourceLineNo">541</span><a id="line.541">                metadata.state = CLOSED_STATE;</a>
<span class="sourceLineNo">542</span><a id="line.542">                metadata.firstInProgressTransactionLocation = getInProgressTxLocationRange()[0];</a>
<span class="sourceLineNo">543</span><a id="line.543"></a>
<span class="sourceLineNo">544</span><a id="line.544">                if (metadata.page != null) {</a>
<span class="sourceLineNo">545</span><a id="line.545">                    pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">546</span><a id="line.546">                        @Override</a>
<span class="sourceLineNo">547</span><a id="line.547">                        public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">548</span><a id="line.548">                            tx.store(metadata.page, metadataMarshaller, true);</a>
<span class="sourceLineNo">549</span><a id="line.549">                        }</a>
<span class="sourceLineNo">550</span><a id="line.550">                    });</a>
<span class="sourceLineNo">551</span><a id="line.551">                }</a>
<span class="sourceLineNo">552</span><a id="line.552">            }</a>
<span class="sourceLineNo">553</span><a id="line.553">        } finally {</a>
<span class="sourceLineNo">554</span><a id="line.554">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">555</span><a id="line.555">        }</a>
<span class="sourceLineNo">556</span><a id="line.556">        close();</a>
<span class="sourceLineNo">557</span><a id="line.557">    }</a>
<span class="sourceLineNo">558</span><a id="line.558"></a>
<span class="sourceLineNo">559</span><a id="line.559">    // public for testing</a>
<span class="sourceLineNo">560</span><a id="line.560">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">561</span><a id="line.561">    public Location[] getInProgressTxLocationRange() {</a>
<span class="sourceLineNo">562</span><a id="line.562">        Location[] range = new Location[]{null, null};</a>
<span class="sourceLineNo">563</span><a id="line.563">        synchronized (inflightTransactions) {</a>
<span class="sourceLineNo">564</span><a id="line.564">            if (!inflightTransactions.isEmpty()) {</a>
<span class="sourceLineNo">565</span><a id="line.565">                for (List&lt;Operation&gt; ops : inflightTransactions.values()) {</a>
<span class="sourceLineNo">566</span><a id="line.566">                    if (!ops.isEmpty()) {</a>
<span class="sourceLineNo">567</span><a id="line.567">                        trackMaxAndMin(range, ops);</a>
<span class="sourceLineNo">568</span><a id="line.568">                    }</a>
<span class="sourceLineNo">569</span><a id="line.569">                }</a>
<span class="sourceLineNo">570</span><a id="line.570">            }</a>
<span class="sourceLineNo">571</span><a id="line.571">            if (!preparedTransactions.isEmpty()) {</a>
<span class="sourceLineNo">572</span><a id="line.572">                for (List&lt;Operation&gt; ops : preparedTransactions.values()) {</a>
<span class="sourceLineNo">573</span><a id="line.573">                    if (!ops.isEmpty()) {</a>
<span class="sourceLineNo">574</span><a id="line.574">                        trackMaxAndMin(range, ops);</a>
<span class="sourceLineNo">575</span><a id="line.575">                    }</a>
<span class="sourceLineNo">576</span><a id="line.576">                }</a>
<span class="sourceLineNo">577</span><a id="line.577">            }</a>
<span class="sourceLineNo">578</span><a id="line.578">        }</a>
<span class="sourceLineNo">579</span><a id="line.579">        return range;</a>
<span class="sourceLineNo">580</span><a id="line.580">    }</a>
<span class="sourceLineNo">581</span><a id="line.581"></a>
<span class="sourceLineNo">582</span><a id="line.582">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">583</span><a id="line.583">    private void trackMaxAndMin(Location[] range, List&lt;Operation&gt; ops) {</a>
<span class="sourceLineNo">584</span><a id="line.584">        Location t = ops.get(0).getLocation();</a>
<span class="sourceLineNo">585</span><a id="line.585">        if (range[0] == null || t.compareTo(range[0]) &lt;= 0) {</a>
<span class="sourceLineNo">586</span><a id="line.586">            range[0] = t;</a>
<span class="sourceLineNo">587</span><a id="line.587">        }</a>
<span class="sourceLineNo">588</span><a id="line.588">        t = ops.get(ops.size() -1).getLocation();</a>
<span class="sourceLineNo">589</span><a id="line.589">        if (range[1] == null || t.compareTo(range[1]) &gt;= 0) {</a>
<span class="sourceLineNo">590</span><a id="line.590">            range[1] = t;</a>
<span class="sourceLineNo">591</span><a id="line.591">        }</a>
<span class="sourceLineNo">592</span><a id="line.592">    }</a>
<span class="sourceLineNo">593</span><a id="line.593"></a>
<span class="sourceLineNo">594</span><a id="line.594">    class TranInfo {</a>
<span class="sourceLineNo">595</span><a id="line.595">        TransactionId id;</a>
<span class="sourceLineNo">596</span><a id="line.596">        Location location;</a>
<span class="sourceLineNo">597</span><a id="line.597"></a>
<span class="sourceLineNo">598</span><a id="line.598">        class opCount {</a>
<span class="sourceLineNo">599</span><a id="line.599">            int add;</a>
<span class="sourceLineNo">600</span><a id="line.600">            int remove;</a>
<span class="sourceLineNo">601</span><a id="line.601">        }</a>
<span class="sourceLineNo">602</span><a id="line.602">        HashMap&lt;KahaDestination, opCount&gt; destinationOpCount = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">603</span><a id="line.603"></a>
<span class="sourceLineNo">604</span><a id="line.604">        @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">605</span><a id="line.605">        public void track(Operation operation) {</a>
<span class="sourceLineNo">606</span><a id="line.606">            if (location == null ) {</a>
<span class="sourceLineNo">607</span><a id="line.607">                location = operation.getLocation();</a>
<span class="sourceLineNo">608</span><a id="line.608">            }</a>
<span class="sourceLineNo">609</span><a id="line.609">            KahaDestination destination;</a>
<span class="sourceLineNo">610</span><a id="line.610">            boolean isAdd = false;</a>
<span class="sourceLineNo">611</span><a id="line.611">            if (operation instanceof AddOperation) {</a>
<span class="sourceLineNo">612</span><a id="line.612">                AddOperation add = (AddOperation) operation;</a>
<span class="sourceLineNo">613</span><a id="line.613">                destination = add.getCommand().getDestination();</a>
<span class="sourceLineNo">614</span><a id="line.614">                isAdd = true;</a>
<span class="sourceLineNo">615</span><a id="line.615">            } else {</a>
<span class="sourceLineNo">616</span><a id="line.616">                RemoveOperation removeOpperation = (RemoveOperation) operation;</a>
<span class="sourceLineNo">617</span><a id="line.617">                destination = removeOpperation.getCommand().getDestination();</a>
<span class="sourceLineNo">618</span><a id="line.618">            }</a>
<span class="sourceLineNo">619</span><a id="line.619">            opCount opCount = destinationOpCount.get(destination);</a>
<span class="sourceLineNo">620</span><a id="line.620">            if (opCount == null) {</a>
<span class="sourceLineNo">621</span><a id="line.621">                opCount = new opCount();</a>
<span class="sourceLineNo">622</span><a id="line.622">                destinationOpCount.put(destination, opCount);</a>
<span class="sourceLineNo">623</span><a id="line.623">            }</a>
<span class="sourceLineNo">624</span><a id="line.624">            if (isAdd) {</a>
<span class="sourceLineNo">625</span><a id="line.625">                opCount.add++;</a>
<span class="sourceLineNo">626</span><a id="line.626">            } else {</a>
<span class="sourceLineNo">627</span><a id="line.627">                opCount.remove++;</a>
<span class="sourceLineNo">628</span><a id="line.628">            }</a>
<span class="sourceLineNo">629</span><a id="line.629">        }</a>
<span class="sourceLineNo">630</span><a id="line.630"></a>
<span class="sourceLineNo">631</span><a id="line.631">        @Override</a>
<span class="sourceLineNo">632</span><a id="line.632">        public String toString() {</a>
<span class="sourceLineNo">633</span><a id="line.633">           StringBuffer buffer = new StringBuffer();</a>
<span class="sourceLineNo">634</span><a id="line.634">           buffer.append(location).append(";").append(id).append(";\n");</a>
<span class="sourceLineNo">635</span><a id="line.635">           for (Entry&lt;KahaDestination, opCount&gt; op : destinationOpCount.entrySet()) {</a>
<span class="sourceLineNo">636</span><a id="line.636">               buffer.append(op.getKey()).append('+').append(op.getValue().add).append(',').append('-').append(op.getValue().remove).append(';');</a>
<span class="sourceLineNo">637</span><a id="line.637">           }</a>
<span class="sourceLineNo">638</span><a id="line.638">           return buffer.toString();</a>
<span class="sourceLineNo">639</span><a id="line.639">        }</a>
<span class="sourceLineNo">640</span><a id="line.640">    }</a>
<span class="sourceLineNo">641</span><a id="line.641"></a>
<span class="sourceLineNo">642</span><a id="line.642">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">643</span><a id="line.643">    public String getTransactions() {</a>
<span class="sourceLineNo">644</span><a id="line.644"></a>
<span class="sourceLineNo">645</span><a id="line.645">        ArrayList&lt;TranInfo&gt; infos = new ArrayList&lt;&gt;();</a>
<span class="sourceLineNo">646</span><a id="line.646">        synchronized (inflightTransactions) {</a>
<span class="sourceLineNo">647</span><a id="line.647">            if (!inflightTransactions.isEmpty()) {</a>
<span class="sourceLineNo">648</span><a id="line.648">                for (Entry&lt;TransactionId, List&lt;Operation&gt;&gt; entry : inflightTransactions.entrySet()) {</a>
<span class="sourceLineNo">649</span><a id="line.649">                    TranInfo info = new TranInfo();</a>
<span class="sourceLineNo">650</span><a id="line.650">                    info.id = entry.getKey();</a>
<span class="sourceLineNo">651</span><a id="line.651">                    for (Operation operation : entry.getValue()) {</a>
<span class="sourceLineNo">652</span><a id="line.652">                        info.track(operation);</a>
<span class="sourceLineNo">653</span><a id="line.653">                    }</a>
<span class="sourceLineNo">654</span><a id="line.654">                    infos.add(info);</a>
<span class="sourceLineNo">655</span><a id="line.655">                }</a>
<span class="sourceLineNo">656</span><a id="line.656">            }</a>
<span class="sourceLineNo">657</span><a id="line.657">        }</a>
<span class="sourceLineNo">658</span><a id="line.658">        synchronized (preparedTransactions) {</a>
<span class="sourceLineNo">659</span><a id="line.659">            if (!preparedTransactions.isEmpty()) {</a>
<span class="sourceLineNo">660</span><a id="line.660">                for (Entry&lt;TransactionId, List&lt;Operation&gt;&gt; entry : preparedTransactions.entrySet()) {</a>
<span class="sourceLineNo">661</span><a id="line.661">                    TranInfo info = new TranInfo();</a>
<span class="sourceLineNo">662</span><a id="line.662">                    info.id = entry.getKey();</a>
<span class="sourceLineNo">663</span><a id="line.663">                    for (Operation operation : entry.getValue()) {</a>
<span class="sourceLineNo">664</span><a id="line.664">                        info.track(operation);</a>
<span class="sourceLineNo">665</span><a id="line.665">                    }</a>
<span class="sourceLineNo">666</span><a id="line.666">                    infos.add(info);</a>
<span class="sourceLineNo">667</span><a id="line.667">                }</a>
<span class="sourceLineNo">668</span><a id="line.668">            }</a>
<span class="sourceLineNo">669</span><a id="line.669">        }</a>
<span class="sourceLineNo">670</span><a id="line.670">        return infos.toString();</a>
<span class="sourceLineNo">671</span><a id="line.671">    }</a>
<span class="sourceLineNo">672</span><a id="line.672"></a>
<span class="sourceLineNo">673</span><a id="line.673">    public String getPreparedTransaction(TransactionId transactionId) {</a>
<span class="sourceLineNo">674</span><a id="line.674">        String result = "";</a>
<span class="sourceLineNo">675</span><a id="line.675">        synchronized (preparedTransactions) {</a>
<span class="sourceLineNo">676</span><a id="line.676">            List&lt;Operation&gt; operations = preparedTransactions.get(transactionId);</a>
<span class="sourceLineNo">677</span><a id="line.677">            if (operations != null) {</a>
<span class="sourceLineNo">678</span><a id="line.678">                TranInfo info = new TranInfo();</a>
<span class="sourceLineNo">679</span><a id="line.679">                info.id = transactionId;</a>
<span class="sourceLineNo">680</span><a id="line.680">                for (Operation operation : preparedTransactions.get(transactionId)) {</a>
<span class="sourceLineNo">681</span><a id="line.681">                    info.track(operation);</a>
<span class="sourceLineNo">682</span><a id="line.682">                }</a>
<span class="sourceLineNo">683</span><a id="line.683">                result = info.toString();</a>
<span class="sourceLineNo">684</span><a id="line.684">            }</a>
<span class="sourceLineNo">685</span><a id="line.685">        }</a>
<span class="sourceLineNo">686</span><a id="line.686">        return result;</a>
<span class="sourceLineNo">687</span><a id="line.687">    }</a>
<span class="sourceLineNo">688</span><a id="line.688"></a>
<span class="sourceLineNo">689</span><a id="line.689">    /**</a>
<span class="sourceLineNo">690</span><a id="line.690">     * Move all the messages that were in the journal into long term storage. We</a>
<span class="sourceLineNo">691</span><a id="line.691">     * just replay and do a checkpoint.</a>
<span class="sourceLineNo">692</span><a id="line.692">     *</a>
<span class="sourceLineNo">693</span><a id="line.693">     * @throws IOException</a>
<span class="sourceLineNo">694</span><a id="line.694">     * @throws IOException</a>
<span class="sourceLineNo">695</span><a id="line.695">     * @throws IllegalStateException</a>
<span class="sourceLineNo">696</span><a id="line.696">     */</a>
<span class="sourceLineNo">697</span><a id="line.697">    private void recover() throws IllegalStateException, IOException {</a>
<span class="sourceLineNo">698</span><a id="line.698">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">699</span><a id="line.699">        try {</a>
<span class="sourceLineNo">700</span><a id="line.700"></a>
<span class="sourceLineNo">701</span><a id="line.701">            long start = System.currentTimeMillis();</a>
<span class="sourceLineNo">702</span><a id="line.702">            boolean requiresJournalReplay = recoverProducerAudit();</a>
<span class="sourceLineNo">703</span><a id="line.703">            requiresJournalReplay |= recoverAckMessageFileMap();</a>
<span class="sourceLineNo">704</span><a id="line.704">            Location lastIndoubtPosition = getRecoveryPosition();</a>
<span class="sourceLineNo">705</span><a id="line.705">            Location recoveryPosition = requiresJournalReplay ? journal.getNextLocation(null) : lastIndoubtPosition;</a>
<span class="sourceLineNo">706</span><a id="line.706">            if (recoveryPosition != null) {</a>
<span class="sourceLineNo">707</span><a id="line.707">                int redoCounter = 0;</a>
<span class="sourceLineNo">708</span><a id="line.708">                int dataFileRotationTracker = recoveryPosition.getDataFileId();</a>
<span class="sourceLineNo">709</span><a id="line.709">                LOG.info("Recovering from the journal @" + recoveryPosition);</a>
<span class="sourceLineNo">710</span><a id="line.710">                while (recoveryPosition != null) {</a>
<span class="sourceLineNo">711</span><a id="line.711">                    try {</a>
<span class="sourceLineNo">712</span><a id="line.712">                        JournalCommand&lt;?&gt; message = load(recoveryPosition);</a>
<span class="sourceLineNo">713</span><a id="line.713">                        metadata.lastUpdate = recoveryPosition;</a>
<span class="sourceLineNo">714</span><a id="line.714">                        process(message, recoveryPosition, lastIndoubtPosition);</a>
<span class="sourceLineNo">715</span><a id="line.715">                        redoCounter++;</a>
<span class="sourceLineNo">716</span><a id="line.716">                    } catch (IOException failedRecovery) {</a>
<span class="sourceLineNo">717</span><a id="line.717">                        if (isIgnoreMissingJournalfiles()) {</a>
<span class="sourceLineNo">718</span><a id="line.718">                            LOG.debug("Failed to recover data at position:" + recoveryPosition, failedRecovery);</a>
<span class="sourceLineNo">719</span><a id="line.719">                            // track this dud location</a>
<span class="sourceLineNo">720</span><a id="line.720">                            journal.corruptRecoveryLocation(recoveryPosition);</a>
<span class="sourceLineNo">721</span><a id="line.721">                        } else {</a>
<span class="sourceLineNo">722</span><a id="line.722">                            throw new IOException("Failed to recover data at position:" + recoveryPosition, failedRecovery);</a>
<span class="sourceLineNo">723</span><a id="line.723">                        }</a>
<span class="sourceLineNo">724</span><a id="line.724">                    }</a>
<span class="sourceLineNo">725</span><a id="line.725">                    recoveryPosition = journal.getNextLocation(recoveryPosition);</a>
<span class="sourceLineNo">726</span><a id="line.726">                    // hold on to the minimum number of open files during recovery</a>
<span class="sourceLineNo">727</span><a id="line.727">                    if (recoveryPosition != null &amp;&amp; dataFileRotationTracker != recoveryPosition.getDataFileId()) {</a>
<span class="sourceLineNo">728</span><a id="line.728">                        dataFileRotationTracker = recoveryPosition.getDataFileId();</a>
<span class="sourceLineNo">729</span><a id="line.729">                        journal.cleanup();</a>
<span class="sourceLineNo">730</span><a id="line.730">                    }</a>
<span class="sourceLineNo">731</span><a id="line.731">                    if (LOG.isInfoEnabled() &amp;&amp; redoCounter % 100000 == 0) {</a>
<span class="sourceLineNo">732</span><a id="line.732">                        LOG.info("@" + recoveryPosition + ", " + redoCounter + " entries recovered ..");</a>
<span class="sourceLineNo">733</span><a id="line.733">                    }</a>
<span class="sourceLineNo">734</span><a id="line.734">                }</a>
<span class="sourceLineNo">735</span><a id="line.735">                if (LOG.isInfoEnabled()) {</a>
<span class="sourceLineNo">736</span><a id="line.736">                    long end = System.currentTimeMillis();</a>
<span class="sourceLineNo">737</span><a id="line.737">                    LOG.info("Recovery replayed " + redoCounter + " operations from the journal in " + ((end - start) / 1000.0f) + " seconds.");</a>
<span class="sourceLineNo">738</span><a id="line.738">                }</a>
<span class="sourceLineNo">739</span><a id="line.739">            }</a>
<span class="sourceLineNo">740</span><a id="line.740"></a>
<span class="sourceLineNo">741</span><a id="line.741">            // We may have to undo some index updates.</a>
<span class="sourceLineNo">742</span><a id="line.742">            pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">743</span><a id="line.743">                @Override</a>
<span class="sourceLineNo">744</span><a id="line.744">                public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">745</span><a id="line.745">                    recoverIndex(tx);</a>
<span class="sourceLineNo">746</span><a id="line.746">                }</a>
<span class="sourceLineNo">747</span><a id="line.747">            });</a>
<span class="sourceLineNo">748</span><a id="line.748"></a>
<span class="sourceLineNo">749</span><a id="line.749">            // rollback any recovered inflight local transactions, and discard any inflight XA transactions.</a>
<span class="sourceLineNo">750</span><a id="line.750">            Set&lt;TransactionId&gt; toRollback = new HashSet&lt;&gt;();</a>
<span class="sourceLineNo">751</span><a id="line.751">            Set&lt;TransactionId&gt; toDiscard = new HashSet&lt;&gt;();</a>
<span class="sourceLineNo">752</span><a id="line.752">            synchronized (inflightTransactions) {</a>
<span class="sourceLineNo">753</span><a id="line.753">                for (Iterator&lt;TransactionId&gt; it = inflightTransactions.keySet().iterator(); it.hasNext(); ) {</a>
<span class="sourceLineNo">754</span><a id="line.754">                    TransactionId id = it.next();</a>
<span class="sourceLineNo">755</span><a id="line.755">                    if (id.isLocalTransaction()) {</a>
<span class="sourceLineNo">756</span><a id="line.756">                        toRollback.add(id);</a>
<span class="sourceLineNo">757</span><a id="line.757">                    } else {</a>
<span class="sourceLineNo">758</span><a id="line.758">                        toDiscard.add(id);</a>
<span class="sourceLineNo">759</span><a id="line.759">                    }</a>
<span class="sourceLineNo">760</span><a id="line.760">                }</a>
<span class="sourceLineNo">761</span><a id="line.761">                for (TransactionId tx: toRollback) {</a>
<span class="sourceLineNo">762</span><a id="line.762">                    if (LOG.isDebugEnabled()) {</a>
<span class="sourceLineNo">763</span><a id="line.763">                        LOG.debug("rolling back recovered indoubt local transaction " + tx);</a>
<span class="sourceLineNo">764</span><a id="line.764">                    }</a>
<span class="sourceLineNo">765</span><a id="line.765">                    store(new KahaRollbackCommand().setTransactionInfo(TransactionIdConversion.convertToLocal(tx)), false, null, null);</a>
<span class="sourceLineNo">766</span><a id="line.766">                }</a>
<span class="sourceLineNo">767</span><a id="line.767">                for (TransactionId tx: toDiscard) {</a>
<span class="sourceLineNo">768</span><a id="line.768">                    if (LOG.isDebugEnabled()) {</a>
<span class="sourceLineNo">769</span><a id="line.769">                        LOG.debug("discarding recovered in-flight XA transaction " + tx);</a>
<span class="sourceLineNo">770</span><a id="line.770">                    }</a>
<span class="sourceLineNo">771</span><a id="line.771">                    inflightTransactions.remove(tx);</a>
<span class="sourceLineNo">772</span><a id="line.772">                }</a>
<span class="sourceLineNo">773</span><a id="line.773">            }</a>
<span class="sourceLineNo">774</span><a id="line.774"></a>
<span class="sourceLineNo">775</span><a id="line.775">            synchronized (preparedTransactions) {</a>
<span class="sourceLineNo">776</span><a id="line.776">                Set&lt;TransactionId&gt; txIds = new LinkedHashSet&lt;TransactionId&gt;(preparedTransactions.keySet());</a>
<span class="sourceLineNo">777</span><a id="line.777">                for (TransactionId txId : txIds) {</a>
<span class="sourceLineNo">778</span><a id="line.778">                    switch (purgeRecoveredXATransactionStrategy){</a>
<span class="sourceLineNo">779</span><a id="line.779">                        case NEVER:</a>
<span class="sourceLineNo">780</span><a id="line.780">                            LOG.warn("Recovered prepared XA TX: [{}]", txId);</a>
<span class="sourceLineNo">781</span><a id="line.781">                            break;</a>
<span class="sourceLineNo">782</span><a id="line.782">                        case COMMIT:</a>
<span class="sourceLineNo">783</span><a id="line.783">                            store(new KahaCommitCommand().setTransactionInfo(TransactionIdConversion.convert(txId)), false, null, null);</a>
<span class="sourceLineNo">784</span><a id="line.784">                            LOG.warn("Recovered and Committing prepared XA TX: [{}]", txId);</a>
<span class="sourceLineNo">785</span><a id="line.785">                            break;</a>
<span class="sourceLineNo">786</span><a id="line.786">                        case ROLLBACK:</a>
<span class="sourceLineNo">787</span><a id="line.787">                            store(new KahaRollbackCommand().setTransactionInfo(TransactionIdConversion.convert(txId)), false, null, null);</a>
<span class="sourceLineNo">788</span><a id="line.788">                            LOG.warn("Recovered and Rolling Back prepared XA TX: [{}]", txId);</a>
<span class="sourceLineNo">789</span><a id="line.789">                            break;</a>
<span class="sourceLineNo">790</span><a id="line.790">                    }</a>
<span class="sourceLineNo">791</span><a id="line.791">                }</a>
<span class="sourceLineNo">792</span><a id="line.792">            }</a>
<span class="sourceLineNo">793</span><a id="line.793"></a>
<span class="sourceLineNo">794</span><a id="line.794">        } finally {</a>
<span class="sourceLineNo">795</span><a id="line.795">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">796</span><a id="line.796">        }</a>
<span class="sourceLineNo">797</span><a id="line.797">    }</a>
<span class="sourceLineNo">798</span><a id="line.798"></a>
<span class="sourceLineNo">799</span><a id="line.799">    @SuppressWarnings("unused")</a>
<span class="sourceLineNo">800</span><a id="line.800">    private KahaTransactionInfo createLocalTransactionInfo(TransactionId tx) {</a>
<span class="sourceLineNo">801</span><a id="line.801">        return TransactionIdConversion.convertToLocal(tx);</a>
<span class="sourceLineNo">802</span><a id="line.802">    }</a>
<span class="sourceLineNo">803</span><a id="line.803"></a>
<span class="sourceLineNo">804</span><a id="line.804">    private Location minimum(Location x,</a>
<span class="sourceLineNo">805</span><a id="line.805">                             Location y) {</a>
<span class="sourceLineNo">806</span><a id="line.806">        Location min = null;</a>
<span class="sourceLineNo">807</span><a id="line.807">        if (x != null) {</a>
<span class="sourceLineNo">808</span><a id="line.808">            min = x;</a>
<span class="sourceLineNo">809</span><a id="line.809">            if (y != null) {</a>
<span class="sourceLineNo">810</span><a id="line.810">                int compare = y.compareTo(x);</a>
<span class="sourceLineNo">811</span><a id="line.811">                if (compare &lt; 0) {</a>
<span class="sourceLineNo">812</span><a id="line.812">                    min = y;</a>
<span class="sourceLineNo">813</span><a id="line.813">                }</a>
<span class="sourceLineNo">814</span><a id="line.814">            }</a>
<span class="sourceLineNo">815</span><a id="line.815">        } else {</a>
<span class="sourceLineNo">816</span><a id="line.816">            min = y;</a>
<span class="sourceLineNo">817</span><a id="line.817">        }</a>
<span class="sourceLineNo">818</span><a id="line.818">        return min;</a>
<span class="sourceLineNo">819</span><a id="line.819">    }</a>
<span class="sourceLineNo">820</span><a id="line.820"></a>
<span class="sourceLineNo">821</span><a id="line.821">    private boolean recoverProducerAudit() throws IOException {</a>
<span class="sourceLineNo">822</span><a id="line.822">        boolean requiresReplay = true;</a>
<span class="sourceLineNo">823</span><a id="line.823">        if (metadata.producerSequenceIdTrackerLocation != null) {</a>
<span class="sourceLineNo">824</span><a id="line.824">            try {</a>
<span class="sourceLineNo">825</span><a id="line.825">                KahaProducerAuditCommand audit = (KahaProducerAuditCommand) load(metadata.producerSequenceIdTrackerLocation);</a>
<span class="sourceLineNo">826</span><a id="line.826">                ObjectInputStream objectIn = new MessageDatabaseObjectInputStream(audit.getAudit().newInput());</a>
<span class="sourceLineNo">827</span><a id="line.827">                int maxNumProducers = getMaxFailoverProducersToTrack();</a>
<span class="sourceLineNo">828</span><a id="line.828">                int maxAuditDepth = getFailoverProducersAuditDepth();</a>
<span class="sourceLineNo">829</span><a id="line.829">                metadata.producerSequenceIdTracker = (ActiveMQMessageAuditNoSync) objectIn.readObject();</a>
<span class="sourceLineNo">830</span><a id="line.830">                metadata.producerSequenceIdTracker.setAuditDepth(maxAuditDepth);</a>
<span class="sourceLineNo">831</span><a id="line.831">                metadata.producerSequenceIdTracker.setMaximumNumberOfProducersToTrack(maxNumProducers);</a>
<span class="sourceLineNo">832</span><a id="line.832">                requiresReplay = false;</a>
<span class="sourceLineNo">833</span><a id="line.833">            } catch (Exception e) {</a>
<span class="sourceLineNo">834</span><a id="line.834">                LOG.warn("Cannot recover message audit", e);</a>
<span class="sourceLineNo">835</span><a id="line.835">            }</a>
<span class="sourceLineNo">836</span><a id="line.836">        }</a>
<span class="sourceLineNo">837</span><a id="line.837">        // got no audit stored so got to recreate via replay from start of the journal</a>
<span class="sourceLineNo">838</span><a id="line.838">        return requiresReplay;</a>
<span class="sourceLineNo">839</span><a id="line.839">    }</a>
<span class="sourceLineNo">840</span><a id="line.840"></a>
<span class="sourceLineNo">841</span><a id="line.841">    @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">842</span><a id="line.842">    private boolean recoverAckMessageFileMap() throws IOException {</a>
<span class="sourceLineNo">843</span><a id="line.843">        boolean requiresReplay = true;</a>
<span class="sourceLineNo">844</span><a id="line.844">        if (metadata.ackMessageFileMapLocation != null) {</a>
<span class="sourceLineNo">845</span><a id="line.845">            try {</a>
<span class="sourceLineNo">846</span><a id="line.846">                KahaAckMessageFileMapCommand audit = (KahaAckMessageFileMapCommand) load(metadata.ackMessageFileMapLocation);</a>
<span class="sourceLineNo">847</span><a id="line.847">                ObjectInputStream objectIn = new MessageDatabaseObjectInputStream(audit.getAckMessageFileMap().newInput());</a>
<span class="sourceLineNo">848</span><a id="line.848">                metadata.ackMessageFileMap = (Map&lt;Integer, Set&lt;Integer&gt;&gt;) objectIn.readObject();</a>
<span class="sourceLineNo">849</span><a id="line.849">                metadata.ackMessageFileMapDirtyFlag.lazySet(true);</a>
<span class="sourceLineNo">850</span><a id="line.850">                requiresReplay = false;</a>
<span class="sourceLineNo">851</span><a id="line.851">            } catch (Exception e) {</a>
<span class="sourceLineNo">852</span><a id="line.852">                LOG.warn("Cannot recover ackMessageFileMap", e);</a>
<span class="sourceLineNo">853</span><a id="line.853">            }</a>
<span class="sourceLineNo">854</span><a id="line.854">        }</a>
<span class="sourceLineNo">855</span><a id="line.855">        // got no ackMessageFileMap stored so got to recreate via replay from start of the journal</a>
<span class="sourceLineNo">856</span><a id="line.856">        return requiresReplay;</a>
<span class="sourceLineNo">857</span><a id="line.857">    }</a>
<span class="sourceLineNo">858</span><a id="line.858"></a>
<span class="sourceLineNo">859</span><a id="line.859">    protected void recoverIndex(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">860</span><a id="line.860">        long start = System.currentTimeMillis();</a>
<span class="sourceLineNo">861</span><a id="line.861">        // It is possible index updates got applied before the journal updates..</a>
<span class="sourceLineNo">862</span><a id="line.862">        // in that case we need to removed references to messages that are not in the journal</a>
<span class="sourceLineNo">863</span><a id="line.863">        final Location lastAppendLocation = journal.getLastAppendLocation();</a>
<span class="sourceLineNo">864</span><a id="line.864">        long undoCounter=0;</a>
<span class="sourceLineNo">865</span><a id="line.865"></a>
<span class="sourceLineNo">866</span><a id="line.866">        // Go through all the destinations to see if they have messages past the lastAppendLocation</a>
<span class="sourceLineNo">867</span><a id="line.867">        for (String key : storedDestinations.keySet()) {</a>
<span class="sourceLineNo">868</span><a id="line.868">            StoredDestination sd = storedDestinations.get(key);</a>
<span class="sourceLineNo">869</span><a id="line.869"></a>
<span class="sourceLineNo">870</span><a id="line.870">            final ArrayList&lt;Long&gt; matches = new ArrayList&lt;&gt;();</a>
<span class="sourceLineNo">871</span><a id="line.871">            // Find all the Locations that are &gt;= than the last Append Location.</a>
<span class="sourceLineNo">872</span><a id="line.872">            sd.locationIndex.visit(tx, new BTreeVisitor.GTEVisitor&lt;Location, Long&gt;(lastAppendLocation) {</a>
<span class="sourceLineNo">873</span><a id="line.873">                @Override</a>
<span class="sourceLineNo">874</span><a id="line.874">                protected void matched(Location key, Long value) {</a>
<span class="sourceLineNo">875</span><a id="line.875">                    matches.add(value);</a>
<span class="sourceLineNo">876</span><a id="line.876">                }</a>
<span class="sourceLineNo">877</span><a id="line.877">            });</a>
<span class="sourceLineNo">878</span><a id="line.878"></a>
<span class="sourceLineNo">879</span><a id="line.879">            for (Long sequenceId : matches) {</a>
<span class="sourceLineNo">880</span><a id="line.880">                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);</a>
<span class="sourceLineNo">881</span><a id="line.881">                if (keys != null) {</a>
<span class="sourceLineNo">882</span><a id="line.882">                    sd.locationIndex.remove(tx, keys.location);</a>
<span class="sourceLineNo">883</span><a id="line.883">                    sd.messageIdIndex.remove(tx, keys.messageId);</a>
<span class="sourceLineNo">884</span><a id="line.884">                    metadata.producerSequenceIdTracker.rollback(keys.messageId);</a>
<span class="sourceLineNo">885</span><a id="line.885">                    undoCounter++;</a>
<span class="sourceLineNo">886</span><a id="line.886">                    decrementAndSubSizeToStoreStat(tx, key, sd, keys.location.getSize());</a>
<span class="sourceLineNo">887</span><a id="line.887">                    // TODO: do we need to modify the ack positions for the pub sub case?</a>
<span class="sourceLineNo">888</span><a id="line.888">                }</a>
<span class="sourceLineNo">889</span><a id="line.889">            }</a>
<span class="sourceLineNo">890</span><a id="line.890">        }</a>
<span class="sourceLineNo">891</span><a id="line.891"></a>
<span class="sourceLineNo">892</span><a id="line.892">        if (undoCounter &gt; 0) {</a>
<span class="sourceLineNo">893</span><a id="line.893">            // The rolledback operations are basically in flight journal writes.  To avoid getting</a>
<span class="sourceLineNo">894</span><a id="line.894">            // these the end user should do sync writes to the journal.</a>
<span class="sourceLineNo">895</span><a id="line.895">            if (LOG.isInfoEnabled()) {</a>
<span class="sourceLineNo">896</span><a id="line.896">                long end = System.currentTimeMillis();</a>
<span class="sourceLineNo">897</span><a id="line.897">                LOG.info("Rolled back " + undoCounter + " messages from the index in " + ((end - start) / 1000.0f) + " seconds.");</a>
<span class="sourceLineNo">898</span><a id="line.898">            }</a>
<span class="sourceLineNo">899</span><a id="line.899">        }</a>
<span class="sourceLineNo">900</span><a id="line.900"></a>
<span class="sourceLineNo">901</span><a id="line.901">        undoCounter = 0;</a>
<span class="sourceLineNo">902</span><a id="line.902">        start = System.currentTimeMillis();</a>
<span class="sourceLineNo">903</span><a id="line.903"></a>
<span class="sourceLineNo">904</span><a id="line.904">        // Lets be extra paranoid here and verify that all the datafiles being referenced</a>
<span class="sourceLineNo">905</span><a id="line.905">        // by the indexes still exists.</a>
<span class="sourceLineNo">906</span><a id="line.906"></a>
<span class="sourceLineNo">907</span><a id="line.907">        final SequenceSet ss = new SequenceSet();</a>
<span class="sourceLineNo">908</span><a id="line.908">        for (StoredDestination sd : storedDestinations.values()) {</a>
<span class="sourceLineNo">909</span><a id="line.909">            // Use a visitor to cut down the number of pages that we load</a>
<span class="sourceLineNo">910</span><a id="line.910">            sd.locationIndex.visit(tx, new BTreeVisitor&lt;Location, Long&gt;() {</a>
<span class="sourceLineNo">911</span><a id="line.911">                int last=-1;</a>
<span class="sourceLineNo">912</span><a id="line.912"></a>
<span class="sourceLineNo">913</span><a id="line.913">                @Override</a>
<span class="sourceLineNo">914</span><a id="line.914">                public boolean isInterestedInKeysBetween(Location first, Location second) {</a>
<span class="sourceLineNo">915</span><a id="line.915">                    if( first==null ) {</a>
<span class="sourceLineNo">916</span><a id="line.916">                        return !ss.contains(0, second.getDataFileId());</a>
<span class="sourceLineNo">917</span><a id="line.917">                    } else if( second==null ) {</a>
<span class="sourceLineNo">918</span><a id="line.918">                        return true;</a>
<span class="sourceLineNo">919</span><a id="line.919">                    } else {</a>
<span class="sourceLineNo">920</span><a id="line.920">                        return !ss.contains(first.getDataFileId(), second.getDataFileId());</a>
<span class="sourceLineNo">921</span><a id="line.921">                    }</a>
<span class="sourceLineNo">922</span><a id="line.922">                }</a>
<span class="sourceLineNo">923</span><a id="line.923"></a>
<span class="sourceLineNo">924</span><a id="line.924">                @Override</a>
<span class="sourceLineNo">925</span><a id="line.925">                public void visit(List&lt;Location&gt; keys, List&lt;Long&gt; values) {</a>
<span class="sourceLineNo">926</span><a id="line.926">                    for (Location l : keys) {</a>
<span class="sourceLineNo">927</span><a id="line.927">                        int fileId = l.getDataFileId();</a>
<span class="sourceLineNo">928</span><a id="line.928">                        if( last != fileId ) {</a>
<span class="sourceLineNo">929</span><a id="line.929">                            ss.add(fileId);</a>
<span class="sourceLineNo">930</span><a id="line.930">                            last = fileId;</a>
<span class="sourceLineNo">931</span><a id="line.931">                        }</a>
<span class="sourceLineNo">932</span><a id="line.932">                    }</a>
<span class="sourceLineNo">933</span><a id="line.933">                }</a>
<span class="sourceLineNo">934</span><a id="line.934"></a>
<span class="sourceLineNo">935</span><a id="line.935">            });</a>
<span class="sourceLineNo">936</span><a id="line.936">        }</a>
<span class="sourceLineNo">937</span><a id="line.937">        HashSet&lt;Integer&gt; missingJournalFiles = new HashSet&lt;&gt;();</a>
<span class="sourceLineNo">938</span><a id="line.938">        while (!ss.isEmpty()) {</a>
<span class="sourceLineNo">939</span><a id="line.939">            missingJournalFiles.add((int) ss.removeFirst());</a>
<span class="sourceLineNo">940</span><a id="line.940">        }</a>
<span class="sourceLineNo">941</span><a id="line.941"></a>
<span class="sourceLineNo">942</span><a id="line.942">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : metadata.ackMessageFileMap.entrySet()) {</a>
<span class="sourceLineNo">943</span><a id="line.943">            missingJournalFiles.add(entry.getKey());</a>
<span class="sourceLineNo">944</span><a id="line.944">            for (Integer i : entry.getValue()) {</a>
<span class="sourceLineNo">945</span><a id="line.945">                missingJournalFiles.add(i);</a>
<span class="sourceLineNo">946</span><a id="line.946">            }</a>
<span class="sourceLineNo">947</span><a id="line.947">        }</a>
<span class="sourceLineNo">948</span><a id="line.948"></a>
<span class="sourceLineNo">949</span><a id="line.949">        missingJournalFiles.removeAll(journal.getFileMap().keySet());</a>
<span class="sourceLineNo">950</span><a id="line.950"></a>
<span class="sourceLineNo">951</span><a id="line.951">        if (!missingJournalFiles.isEmpty()) {</a>
<span class="sourceLineNo">952</span><a id="line.952">            LOG.warn("Some journal files are missing: " + missingJournalFiles);</a>
<span class="sourceLineNo">953</span><a id="line.953">        }</a>
<span class="sourceLineNo">954</span><a id="line.954"></a>
<span class="sourceLineNo">955</span><a id="line.955">        ArrayList&lt;BTreeVisitor.Predicate&lt;Location&gt;&gt; knownCorruption = new ArrayList&lt;&gt;();</a>
<span class="sourceLineNo">956</span><a id="line.956">        ArrayList&lt;BTreeVisitor.Predicate&lt;Location&gt;&gt; missingPredicates = new ArrayList&lt;&gt;();</a>
<span class="sourceLineNo">957</span><a id="line.957">        for (Integer missing : missingJournalFiles) {</a>
<span class="sourceLineNo">958</span><a id="line.958">            missingPredicates.add(new BTreeVisitor.BetweenVisitor&lt;Location, Long&gt;(new Location(missing, 0), new Location(missing + 1, 0)));</a>
<span class="sourceLineNo">959</span><a id="line.959">        }</a>
<span class="sourceLineNo">960</span><a id="line.960"></a>
<span class="sourceLineNo">961</span><a id="line.961">        if (checkForCorruptJournalFiles) {</a>
<span class="sourceLineNo">962</span><a id="line.962">            Collection&lt;DataFile&gt; dataFiles = journal.getFileMap().values();</a>
<span class="sourceLineNo">963</span><a id="line.963">            for (DataFile dataFile : dataFiles) {</a>
<span class="sourceLineNo">964</span><a id="line.964">                int id = dataFile.getDataFileId();</a>
<span class="sourceLineNo">965</span><a id="line.965">                // eof to next file id</a>
<span class="sourceLineNo">966</span><a id="line.966">                missingPredicates.add(new BTreeVisitor.BetweenVisitor&lt;Location, Long&gt;(new Location(id, dataFile.getLength()), new Location(id + 1, 0)));</a>
<span class="sourceLineNo">967</span><a id="line.967">                Sequence seq = dataFile.getCorruptedBlocks().getHead();</a>
<span class="sourceLineNo">968</span><a id="line.968">                while (seq != null) {</a>
<span class="sourceLineNo">969</span><a id="line.969">                    BTreeVisitor.BetweenVisitor&lt;Location, Long&gt; visitor =</a>
<span class="sourceLineNo">970</span><a id="line.970">                        new BTreeVisitor.BetweenVisitor&lt;&gt;(new Location(id, (int) seq.getFirst()), new Location(id, (int) seq.getLast() + 1));</a>
<span class="sourceLineNo">971</span><a id="line.971">                    missingPredicates.add(visitor);</a>
<span class="sourceLineNo">972</span><a id="line.972">                    knownCorruption.add(visitor);</a>
<span class="sourceLineNo">973</span><a id="line.973">                    seq = seq.getNext();</a>
<span class="sourceLineNo">974</span><a id="line.974">                }</a>
<span class="sourceLineNo">975</span><a id="line.975">            }</a>
<span class="sourceLineNo">976</span><a id="line.976">        }</a>
<span class="sourceLineNo">977</span><a id="line.977"></a>
<span class="sourceLineNo">978</span><a id="line.978">        if (!missingPredicates.isEmpty()) {</a>
<span class="sourceLineNo">979</span><a id="line.979">            for (Entry&lt;String, StoredDestination&gt; sdEntry : storedDestinations.entrySet()) {</a>
<span class="sourceLineNo">980</span><a id="line.980">                final StoredDestination sd = sdEntry.getValue();</a>
<span class="sourceLineNo">981</span><a id="line.981">                final LinkedHashMap&lt;Long, Location&gt; matches = new LinkedHashMap&lt;&gt;();</a>
<span class="sourceLineNo">982</span><a id="line.982">                sd.locationIndex.visit(tx, new BTreeVisitor.OrVisitor&lt;Location, Long&gt;(missingPredicates) {</a>
<span class="sourceLineNo">983</span><a id="line.983">                    @Override</a>
<span class="sourceLineNo">984</span><a id="line.984">                    protected void matched(Location key, Long value) {</a>
<span class="sourceLineNo">985</span><a id="line.985">                        matches.put(value, key);</a>
<span class="sourceLineNo">986</span><a id="line.986">                    }</a>
<span class="sourceLineNo">987</span><a id="line.987">                });</a>
<span class="sourceLineNo">988</span><a id="line.988"></a>
<span class="sourceLineNo">989</span><a id="line.989">                // If some message references are affected by the missing data files...</a>
<span class="sourceLineNo">990</span><a id="line.990">                if (!matches.isEmpty()) {</a>
<span class="sourceLineNo">991</span><a id="line.991"></a>
<span class="sourceLineNo">992</span><a id="line.992">                    // We either 'gracefully' recover dropping the missing messages or</a>
<span class="sourceLineNo">993</span><a id="line.993">                    // we error out.</a>
<span class="sourceLineNo">994</span><a id="line.994">                    if( ignoreMissingJournalfiles ) {</a>
<span class="sourceLineNo">995</span><a id="line.995">                        // Update the index to remove the references to the missing data</a>
<span class="sourceLineNo">996</span><a id="line.996">                        for (Long sequenceId : matches.keySet()) {</a>
<span class="sourceLineNo">997</span><a id="line.997">                            MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);</a>
<span class="sourceLineNo">998</span><a id="line.998">                            sd.locationIndex.remove(tx, keys.location);</a>
<span class="sourceLineNo">999</span><a id="line.999">                            sd.messageIdIndex.remove(tx, keys.messageId);</a>
<span class="sourceLineNo">1000</span><a id="line.1000">                            LOG.info("[" + sdEntry.getKey() + "] dropped: " + keys.messageId + " at corrupt location: " + keys.location);</a>
<span class="sourceLineNo">1001</span><a id="line.1001">                            undoCounter++;</a>
<span class="sourceLineNo">1002</span><a id="line.1002">                            decrementAndSubSizeToStoreStat(tx, sdEntry.getKey(), sdEntry.getValue(), keys.location.getSize());</a>
<span class="sourceLineNo">1003</span><a id="line.1003">                            // TODO: do we need to modify the ack positions for the pub sub case?</a>
<span class="sourceLineNo">1004</span><a id="line.1004">                        }</a>
<span class="sourceLineNo">1005</span><a id="line.1005">                    } else {</a>
<span class="sourceLineNo">1006</span><a id="line.1006">                        LOG.error("[" + sdEntry.getKey() + "] references corrupt locations: " + matches);</a>
<span class="sourceLineNo">1007</span><a id="line.1007">                        throw new IOException("Detected missing/corrupt journal files referenced by:[" + sdEntry.getKey() + "] " +matches.size()+" messages affected.");</a>
<span class="sourceLineNo">1008</span><a id="line.1008">                    }</a>
<span class="sourceLineNo">1009</span><a id="line.1009">                }</a>
<span class="sourceLineNo">1010</span><a id="line.1010">            }</a>
<span class="sourceLineNo">1011</span><a id="line.1011">        }</a>
<span class="sourceLineNo">1012</span><a id="line.1012"></a>
<span class="sourceLineNo">1013</span><a id="line.1013">        if (!ignoreMissingJournalfiles) {</a>
<span class="sourceLineNo">1014</span><a id="line.1014">            if (!knownCorruption.isEmpty()) {</a>
<span class="sourceLineNo">1015</span><a id="line.1015">                LOG.error("Detected corrupt journal files. " + knownCorruption);</a>
<span class="sourceLineNo">1016</span><a id="line.1016">                throw new IOException("Detected corrupt journal files. " + knownCorruption);</a>
<span class="sourceLineNo">1017</span><a id="line.1017">            }</a>
<span class="sourceLineNo">1018</span><a id="line.1018"></a>
<span class="sourceLineNo">1019</span><a id="line.1019">            if (!missingJournalFiles.isEmpty()) {</a>
<span class="sourceLineNo">1020</span><a id="line.1020">                LOG.error("Detected missing journal files. " + missingJournalFiles);</a>
<span class="sourceLineNo">1021</span><a id="line.1021">                throw new IOException("Detected missing journal files. " + missingJournalFiles);</a>
<span class="sourceLineNo">1022</span><a id="line.1022">            }</a>
<span class="sourceLineNo">1023</span><a id="line.1023">        }</a>
<span class="sourceLineNo">1024</span><a id="line.1024"></a>
<span class="sourceLineNo">1025</span><a id="line.1025">        if (undoCounter &gt; 0) {</a>
<span class="sourceLineNo">1026</span><a id="line.1026">            // The rolledback operations are basically in flight journal writes.  To avoid getting these the end user</a>
<span class="sourceLineNo">1027</span><a id="line.1027">            // should do sync writes to the journal.</a>
<span class="sourceLineNo">1028</span><a id="line.1028">            if (LOG.isInfoEnabled()) {</a>
<span class="sourceLineNo">1029</span><a id="line.1029">                long end = System.currentTimeMillis();</a>
<span class="sourceLineNo">1030</span><a id="line.1030">                LOG.info("Detected missing/corrupt journal files.  Dropped " + undoCounter + " messages from the index in " + ((end - start) / 1000.0f) + " seconds.");</a>
<span class="sourceLineNo">1031</span><a id="line.1031">            }</a>
<span class="sourceLineNo">1032</span><a id="line.1032">        }</a>
<span class="sourceLineNo">1033</span><a id="line.1033">    }</a>
<span class="sourceLineNo">1034</span><a id="line.1034"></a>
<span class="sourceLineNo">1035</span><a id="line.1035">    private Location nextRecoveryPosition;</a>
<span class="sourceLineNo">1036</span><a id="line.1036">    private Location lastRecoveryPosition;</a>
<span class="sourceLineNo">1037</span><a id="line.1037"></a>
<span class="sourceLineNo">1038</span><a id="line.1038">    public void incrementalRecover() throws IOException {</a>
<span class="sourceLineNo">1039</span><a id="line.1039">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1040</span><a id="line.1040">        try {</a>
<span class="sourceLineNo">1041</span><a id="line.1041">            if( nextRecoveryPosition == null ) {</a>
<span class="sourceLineNo">1042</span><a id="line.1042">                if( lastRecoveryPosition==null ) {</a>
<span class="sourceLineNo">1043</span><a id="line.1043">                    nextRecoveryPosition = getRecoveryPosition();</a>
<span class="sourceLineNo">1044</span><a id="line.1044">                } else {</a>
<span class="sourceLineNo">1045</span><a id="line.1045">                    nextRecoveryPosition = journal.getNextLocation(lastRecoveryPosition);</a>
<span class="sourceLineNo">1046</span><a id="line.1046">                }</a>
<span class="sourceLineNo">1047</span><a id="line.1047">            }</a>
<span class="sourceLineNo">1048</span><a id="line.1048">            while (nextRecoveryPosition != null) {</a>
<span class="sourceLineNo">1049</span><a id="line.1049">                lastRecoveryPosition = nextRecoveryPosition;</a>
<span class="sourceLineNo">1050</span><a id="line.1050">                metadata.lastUpdate = lastRecoveryPosition;</a>
<span class="sourceLineNo">1051</span><a id="line.1051">                JournalCommand&lt;?&gt; message = load(lastRecoveryPosition);</a>
<span class="sourceLineNo">1052</span><a id="line.1052">                process(message, lastRecoveryPosition, (IndexAware) null);</a>
<span class="sourceLineNo">1053</span><a id="line.1053">                nextRecoveryPosition = journal.getNextLocation(lastRecoveryPosition);</a>
<span class="sourceLineNo">1054</span><a id="line.1054">            }</a>
<span class="sourceLineNo">1055</span><a id="line.1055">        } finally {</a>
<span class="sourceLineNo">1056</span><a id="line.1056">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1057</span><a id="line.1057">        }</a>
<span class="sourceLineNo">1058</span><a id="line.1058">    }</a>
<span class="sourceLineNo">1059</span><a id="line.1059"></a>
<span class="sourceLineNo">1060</span><a id="line.1060">    public Location getLastUpdatePosition() throws IOException {</a>
<span class="sourceLineNo">1061</span><a id="line.1061">        return metadata.lastUpdate;</a>
<span class="sourceLineNo">1062</span><a id="line.1062">    }</a>
<span class="sourceLineNo">1063</span><a id="line.1063"></a>
<span class="sourceLineNo">1064</span><a id="line.1064">    private Location getRecoveryPosition() throws IOException {</a>
<span class="sourceLineNo">1065</span><a id="line.1065"></a>
<span class="sourceLineNo">1066</span><a id="line.1066">        if (!this.forceRecoverIndex) {</a>
<span class="sourceLineNo">1067</span><a id="line.1067"></a>
<span class="sourceLineNo">1068</span><a id="line.1068">            // If we need to recover the transactions..</a>
<span class="sourceLineNo">1069</span><a id="line.1069">            if (metadata.firstInProgressTransactionLocation != null) {</a>
<span class="sourceLineNo">1070</span><a id="line.1070">                return metadata.firstInProgressTransactionLocation;</a>
<span class="sourceLineNo">1071</span><a id="line.1071">            }</a>
<span class="sourceLineNo">1072</span><a id="line.1072"></a>
<span class="sourceLineNo">1073</span><a id="line.1073">            // Perhaps there were no transactions...</a>
<span class="sourceLineNo">1074</span><a id="line.1074">            if( metadata.lastUpdate!=null) {</a>
<span class="sourceLineNo">1075</span><a id="line.1075">                // Start replay at the record after the last one recorded in the index file.</a>
<span class="sourceLineNo">1076</span><a id="line.1076">                return getNextInitializedLocation(metadata.lastUpdate);</a>
<span class="sourceLineNo">1077</span><a id="line.1077">            }</a>
<span class="sourceLineNo">1078</span><a id="line.1078">        }</a>
<span class="sourceLineNo">1079</span><a id="line.1079">        // This loads the first position.</a>
<span class="sourceLineNo">1080</span><a id="line.1080">        return journal.getNextLocation(null);</a>
<span class="sourceLineNo">1081</span><a id="line.1081">    }</a>
<span class="sourceLineNo">1082</span><a id="line.1082"></a>
<span class="sourceLineNo">1083</span><a id="line.1083">    private Location getNextInitializedLocation(Location location) throws IOException {</a>
<span class="sourceLineNo">1084</span><a id="line.1084">        Location mayNotBeInitialized = journal.getNextLocation(location);</a>
<span class="sourceLineNo">1085</span><a id="line.1085">        if (location.getSize() == NOT_SET &amp;&amp; mayNotBeInitialized != null &amp;&amp; mayNotBeInitialized.getSize() != NOT_SET) {</a>
<span class="sourceLineNo">1086</span><a id="line.1086">            // need to init size and type to skip</a>
<span class="sourceLineNo">1087</span><a id="line.1087">            return journal.getNextLocation(mayNotBeInitialized);</a>
<span class="sourceLineNo">1088</span><a id="line.1088">        } else {</a>
<span class="sourceLineNo">1089</span><a id="line.1089">            return mayNotBeInitialized;</a>
<span class="sourceLineNo">1090</span><a id="line.1090">        }</a>
<span class="sourceLineNo">1091</span><a id="line.1091">    }</a>
<span class="sourceLineNo">1092</span><a id="line.1092"></a>
<span class="sourceLineNo">1093</span><a id="line.1093">    protected void checkpointCleanup(final boolean cleanup) throws IOException {</a>
<span class="sourceLineNo">1094</span><a id="line.1094">        long start;</a>
<span class="sourceLineNo">1095</span><a id="line.1095">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1096</span><a id="line.1096">        try {</a>
<span class="sourceLineNo">1097</span><a id="line.1097">            start = System.currentTimeMillis();</a>
<span class="sourceLineNo">1098</span><a id="line.1098">            if( !opened.get() ) {</a>
<span class="sourceLineNo">1099</span><a id="line.1099">                return;</a>
<span class="sourceLineNo">1100</span><a id="line.1100">            }</a>
<span class="sourceLineNo">1101</span><a id="line.1101">        } finally {</a>
<span class="sourceLineNo">1102</span><a id="line.1102">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1103</span><a id="line.1103">        }</a>
<span class="sourceLineNo">1104</span><a id="line.1104">        checkpointUpdate(cleanup);</a>
<span class="sourceLineNo">1105</span><a id="line.1105">        long totalTimeMillis = System.currentTimeMillis() - start;</a>
<span class="sourceLineNo">1106</span><a id="line.1106">        if (LOG_SLOW_ACCESS_TIME &gt; 0 &amp;&amp; totalTimeMillis &gt; LOG_SLOW_ACCESS_TIME) {</a>
<span class="sourceLineNo">1107</span><a id="line.1107">            if (LOG.isInfoEnabled()) {</a>
<span class="sourceLineNo">1108</span><a id="line.1108">                LOG.info("Slow KahaDB access: cleanup took " + totalTimeMillis);</a>
<span class="sourceLineNo">1109</span><a id="line.1109">            }</a>
<span class="sourceLineNo">1110</span><a id="line.1110">            persistenceAdapterStatistics.addSlowCleanupTime(totalTimeMillis);</a>
<span class="sourceLineNo">1111</span><a id="line.1111">        }</a>
<span class="sourceLineNo">1112</span><a id="line.1112">    }</a>
<span class="sourceLineNo">1113</span><a id="line.1113"></a>
<span class="sourceLineNo">1114</span><a id="line.1114">    public ByteSequence toByteSequence(JournalCommand&lt;?&gt; data) throws IOException {</a>
<span class="sourceLineNo">1115</span><a id="line.1115">        int size = data.serializedSizeFramed();</a>
<span class="sourceLineNo">1116</span><a id="line.1116">        DataByteArrayOutputStream os = new DataByteArrayOutputStream(size + 1);</a>
<span class="sourceLineNo">1117</span><a id="line.1117">        os.writeByte(data.type().getNumber());</a>
<span class="sourceLineNo">1118</span><a id="line.1118">        data.writeFramed(os);</a>
<span class="sourceLineNo">1119</span><a id="line.1119">        return os.toByteSequence();</a>
<span class="sourceLineNo">1120</span><a id="line.1120">    }</a>
<span class="sourceLineNo">1121</span><a id="line.1121"></a>
<span class="sourceLineNo">1122</span><a id="line.1122">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">1123</span><a id="line.1123">    // Methods call by the broker to update and query the store.</a>
<span class="sourceLineNo">1124</span><a id="line.1124">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">1125</span><a id="line.1125">    public Location store(JournalCommand&lt;?&gt; data) throws IOException {</a>
<span class="sourceLineNo">1126</span><a id="line.1126">        return store(data, false, null,null);</a>
<span class="sourceLineNo">1127</span><a id="line.1127">    }</a>
<span class="sourceLineNo">1128</span><a id="line.1128"></a>
<span class="sourceLineNo">1129</span><a id="line.1129">    public Location store(JournalCommand&lt;?&gt; data, Runnable onJournalStoreComplete) throws IOException {</a>
<span class="sourceLineNo">1130</span><a id="line.1130">        return store(data, false, null, null, onJournalStoreComplete);</a>
<span class="sourceLineNo">1131</span><a id="line.1131">    }</a>
<span class="sourceLineNo">1132</span><a id="line.1132"></a>
<span class="sourceLineNo">1133</span><a id="line.1133">    public Location store(JournalCommand&lt;?&gt; data, boolean sync, IndexAware before,Runnable after) throws IOException {</a>
<span class="sourceLineNo">1134</span><a id="line.1134">        return store(data, sync, before, after, null);</a>
<span class="sourceLineNo">1135</span><a id="line.1135">    }</a>
<span class="sourceLineNo">1136</span><a id="line.1136"></a>
<span class="sourceLineNo">1137</span><a id="line.1137">    /**</a>
<span class="sourceLineNo">1138</span><a id="line.1138">     * All updated are are funneled through this method. The updates are converted</a>
<span class="sourceLineNo">1139</span><a id="line.1139">     * to a JournalMessage which is logged to the journal and then the data from</a>
<span class="sourceLineNo">1140</span><a id="line.1140">     * the JournalMessage is used to update the index just like it would be done</a>
<span class="sourceLineNo">1141</span><a id="line.1141">     * during a recovery process.</a>
<span class="sourceLineNo">1142</span><a id="line.1142">     */</a>
<span class="sourceLineNo">1143</span><a id="line.1143">    public Location store(JournalCommand&lt;?&gt; data, boolean sync, IndexAware before, Runnable after, Runnable onJournalStoreComplete) throws IOException {</a>
<span class="sourceLineNo">1144</span><a id="line.1144">        try {</a>
<span class="sourceLineNo">1145</span><a id="line.1145">            ByteSequence sequence = toByteSequence(data);</a>
<span class="sourceLineNo">1146</span><a id="line.1146">            Location location;</a>
<span class="sourceLineNo">1147</span><a id="line.1147"></a>
<span class="sourceLineNo">1148</span><a id="line.1148">            checkpointLock.readLock().lock();</a>
<span class="sourceLineNo">1149</span><a id="line.1149">            try {</a>
<span class="sourceLineNo">1150</span><a id="line.1150"></a>
<span class="sourceLineNo">1151</span><a id="line.1151">                long start = System.currentTimeMillis();</a>
<span class="sourceLineNo">1152</span><a id="line.1152">                location = onJournalStoreComplete == null ? journal.write(sequence, sync) : journal.write(sequence, onJournalStoreComplete) ;</a>
<span class="sourceLineNo">1153</span><a id="line.1153">                long start2 = System.currentTimeMillis();</a>
<span class="sourceLineNo">1154</span><a id="line.1154">                //Track the last async update so we know if we need to sync at the next checkpoint</a>
<span class="sourceLineNo">1155</span><a id="line.1155">                if (!sync &amp;&amp; journal.isJournalDiskSyncPeriodic()) {</a>
<span class="sourceLineNo">1156</span><a id="line.1156">                    lastAsyncJournalUpdate.set(location);</a>
<span class="sourceLineNo">1157</span><a id="line.1157">                }</a>
<span class="sourceLineNo">1158</span><a id="line.1158">                process(data, location, before);</a>
<span class="sourceLineNo">1159</span><a id="line.1159"></a>
<span class="sourceLineNo">1160</span><a id="line.1160">                long end = System.currentTimeMillis();</a>
<span class="sourceLineNo">1161</span><a id="line.1161">                long totalTimeMillis = end - start;</a>
<span class="sourceLineNo">1162</span><a id="line.1162">                if (LOG_SLOW_ACCESS_TIME &gt; 0 &amp;&amp; totalTimeMillis &gt; LOG_SLOW_ACCESS_TIME) {</a>
<span class="sourceLineNo">1163</span><a id="line.1163">                    if (LOG.isInfoEnabled()) {</a>
<span class="sourceLineNo">1164</span><a id="line.1164">                        LOG.info("Slow KahaDB access: Journal append took: "+(start2-start)+" ms, Index update took "+(end-start2)+" ms");</a>
<span class="sourceLineNo">1165</span><a id="line.1165">                    }</a>
<span class="sourceLineNo">1166</span><a id="line.1166">                    persistenceAdapterStatistics.addSlowWriteTime(totalTimeMillis);</a>
<span class="sourceLineNo">1167</span><a id="line.1167">                }</a>
<span class="sourceLineNo">1168</span><a id="line.1168"></a>
<span class="sourceLineNo">1169</span><a id="line.1169">                persistenceAdapterStatistics.addWriteTime(totalTimeMillis);</a>
<span class="sourceLineNo">1170</span><a id="line.1170"></a>
<span class="sourceLineNo">1171</span><a id="line.1171">            } finally {</a>
<span class="sourceLineNo">1172</span><a id="line.1172">                checkpointLock.readLock().unlock();</a>
<span class="sourceLineNo">1173</span><a id="line.1173">            }</a>
<span class="sourceLineNo">1174</span><a id="line.1174"></a>
<span class="sourceLineNo">1175</span><a id="line.1175">            if (after != null) {</a>
<span class="sourceLineNo">1176</span><a id="line.1176">                after.run();</a>
<span class="sourceLineNo">1177</span><a id="line.1177">            }</a>
<span class="sourceLineNo">1178</span><a id="line.1178"></a>
<span class="sourceLineNo">1179</span><a id="line.1179">            return location;</a>
<span class="sourceLineNo">1180</span><a id="line.1180">        } catch (IOException ioe) {</a>
<span class="sourceLineNo">1181</span><a id="line.1181">            LOG.error("KahaDB failed to store to Journal, command of type: " + data.type(), ioe);</a>
<span class="sourceLineNo">1182</span><a id="line.1182">            brokerService.handleIOException(ioe);</a>
<span class="sourceLineNo">1183</span><a id="line.1183">            throw ioe;</a>
<span class="sourceLineNo">1184</span><a id="line.1184">        }</a>
<span class="sourceLineNo">1185</span><a id="line.1185">    }</a>
<span class="sourceLineNo">1186</span><a id="line.1186"></a>
<span class="sourceLineNo">1187</span><a id="line.1187">    /**</a>
<span class="sourceLineNo">1188</span><a id="line.1188">     * Loads a previously stored JournalMessage</a>
<span class="sourceLineNo">1189</span><a id="line.1189">     *</a>
<span class="sourceLineNo">1190</span><a id="line.1190">     * @param location</a>
<span class="sourceLineNo">1191</span><a id="line.1191">     * @return</a>
<span class="sourceLineNo">1192</span><a id="line.1192">     * @throws IOException</a>
<span class="sourceLineNo">1193</span><a id="line.1193">     */</a>
<span class="sourceLineNo">1194</span><a id="line.1194">    public JournalCommand&lt;?&gt; load(Location location) throws IOException {</a>
<span class="sourceLineNo">1195</span><a id="line.1195">        long start = System.currentTimeMillis();</a>
<span class="sourceLineNo">1196</span><a id="line.1196">        ByteSequence data = journal.read(location);</a>
<span class="sourceLineNo">1197</span><a id="line.1197">        long totalTimeMillis = System.currentTimeMillis() - start;</a>
<span class="sourceLineNo">1198</span><a id="line.1198">        if( LOG_SLOW_ACCESS_TIME&gt;0 &amp;&amp; totalTimeMillis &gt; LOG_SLOW_ACCESS_TIME) {</a>
<span class="sourceLineNo">1199</span><a id="line.1199">            if (LOG.isInfoEnabled()) {</a>
<span class="sourceLineNo">1200</span><a id="line.1200">                LOG.info("Slow KahaDB access: Journal read took: "+ totalTimeMillis +" ms");</a>
<span class="sourceLineNo">1201</span><a id="line.1201">            }</a>
<span class="sourceLineNo">1202</span><a id="line.1202">            persistenceAdapterStatistics.addSlowReadTime(totalTimeMillis);</a>
<span class="sourceLineNo">1203</span><a id="line.1203">        }</a>
<span class="sourceLineNo">1204</span><a id="line.1204"></a>
<span class="sourceLineNo">1205</span><a id="line.1205">        persistenceAdapterStatistics.addReadTime(totalTimeMillis);</a>
<span class="sourceLineNo">1206</span><a id="line.1206"></a>
<span class="sourceLineNo">1207</span><a id="line.1207">        DataByteArrayInputStream is = new DataByteArrayInputStream(data);</a>
<span class="sourceLineNo">1208</span><a id="line.1208">        byte readByte = is.readByte();</a>
<span class="sourceLineNo">1209</span><a id="line.1209">        KahaEntryType type = KahaEntryType.valueOf(readByte);</a>
<span class="sourceLineNo">1210</span><a id="line.1210">        if( type == null ) {</a>
<span class="sourceLineNo">1211</span><a id="line.1211">            try {</a>
<span class="sourceLineNo">1212</span><a id="line.1212">                is.close();</a>
<span class="sourceLineNo">1213</span><a id="line.1213">            } catch (IOException e) {}</a>
<span class="sourceLineNo">1214</span><a id="line.1214">            throw new IOException("Could not load journal record, null type information from: " + readByte + " at location: "+location);</a>
<span class="sourceLineNo">1215</span><a id="line.1215">        }</a>
<span class="sourceLineNo">1216</span><a id="line.1216">        JournalCommand&lt;?&gt; message = (JournalCommand&lt;?&gt;)type.createMessage();</a>
<span class="sourceLineNo">1217</span><a id="line.1217">        message.mergeFramed(is);</a>
<span class="sourceLineNo">1218</span><a id="line.1218">        return message;</a>
<span class="sourceLineNo">1219</span><a id="line.1219">    }</a>
<span class="sourceLineNo">1220</span><a id="line.1220"></a>
<span class="sourceLineNo">1221</span><a id="line.1221">    /**</a>
<span class="sourceLineNo">1222</span><a id="line.1222">     * do minimal recovery till we reach the last inDoubtLocation</a>
<span class="sourceLineNo">1223</span><a id="line.1223">     * @param data</a>
<span class="sourceLineNo">1224</span><a id="line.1224">     * @param location</a>
<span class="sourceLineNo">1225</span><a id="line.1225">     * @param inDoubtlocation</a>
<span class="sourceLineNo">1226</span><a id="line.1226">     * @throws IOException</a>
<span class="sourceLineNo">1227</span><a id="line.1227">     */</a>
<span class="sourceLineNo">1228</span><a id="line.1228">    void process(JournalCommand&lt;?&gt; data, final Location location, final Location inDoubtlocation) throws IOException {</a>
<span class="sourceLineNo">1229</span><a id="line.1229">        if (inDoubtlocation != null &amp;&amp; location.compareTo(inDoubtlocation) &gt;= 0) {</a>
<span class="sourceLineNo">1230</span><a id="line.1230">            initMessageStore(data);</a>
<span class="sourceLineNo">1231</span><a id="line.1231">            process(data, location, (IndexAware) null);</a>
<span class="sourceLineNo">1232</span><a id="line.1232">        } else {</a>
<span class="sourceLineNo">1233</span><a id="line.1233">            // just recover producer audit</a>
<span class="sourceLineNo">1234</span><a id="line.1234">            data.visit(new Visitor() {</a>
<span class="sourceLineNo">1235</span><a id="line.1235">                @Override</a>
<span class="sourceLineNo">1236</span><a id="line.1236">                public void visit(KahaAddMessageCommand command) throws IOException {</a>
<span class="sourceLineNo">1237</span><a id="line.1237">                    metadata.producerSequenceIdTracker.isDuplicate(command.getMessageId());</a>
<span class="sourceLineNo">1238</span><a id="line.1238">                }</a>
<span class="sourceLineNo">1239</span><a id="line.1239">            });</a>
<span class="sourceLineNo">1240</span><a id="line.1240">        }</a>
<span class="sourceLineNo">1241</span><a id="line.1241">    }</a>
<span class="sourceLineNo">1242</span><a id="line.1242"></a>
<span class="sourceLineNo">1243</span><a id="line.1243">    private void initMessageStore(JournalCommand&lt;?&gt; data) throws IOException {</a>
<span class="sourceLineNo">1244</span><a id="line.1244">        data.visit(new Visitor() {</a>
<span class="sourceLineNo">1245</span><a id="line.1245">            @Override</a>
<span class="sourceLineNo">1246</span><a id="line.1246">            public void visit(KahaAddMessageCommand command) throws IOException {</a>
<span class="sourceLineNo">1247</span><a id="line.1247">                final KahaDestination destination = command.getDestination();</a>
<span class="sourceLineNo">1248</span><a id="line.1248">                if (!storedDestinations.containsKey(key(destination))) {</a>
<span class="sourceLineNo">1249</span><a id="line.1249">                    pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">1250</span><a id="line.1250">                        @Override</a>
<span class="sourceLineNo">1251</span><a id="line.1251">                        public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1252</span><a id="line.1252">                            getStoredDestination(destination, tx);</a>
<span class="sourceLineNo">1253</span><a id="line.1253">                        }</a>
<span class="sourceLineNo">1254</span><a id="line.1254">                    });</a>
<span class="sourceLineNo">1255</span><a id="line.1255">                }</a>
<span class="sourceLineNo">1256</span><a id="line.1256">            }</a>
<span class="sourceLineNo">1257</span><a id="line.1257">        });</a>
<span class="sourceLineNo">1258</span><a id="line.1258">    }</a>
<span class="sourceLineNo">1259</span><a id="line.1259"></a>
<span class="sourceLineNo">1260</span><a id="line.1260">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">1261</span><a id="line.1261">    // Journaled record processing methods. Once the record is journaled,</a>
<span class="sourceLineNo">1262</span><a id="line.1262">    // these methods handle applying the index updates. These may be called</a>
<span class="sourceLineNo">1263</span><a id="line.1263">    // from the recovery method too so they need to be idempotent</a>
<span class="sourceLineNo">1264</span><a id="line.1264">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">1265</span><a id="line.1265"></a>
<span class="sourceLineNo">1266</span><a id="line.1266">    void process(JournalCommand&lt;?&gt; data, final Location location, final IndexAware onSequenceAssignedCallback) throws IOException {</a>
<span class="sourceLineNo">1267</span><a id="line.1267">        data.visit(new Visitor() {</a>
<span class="sourceLineNo">1268</span><a id="line.1268">            @Override</a>
<span class="sourceLineNo">1269</span><a id="line.1269">            public void visit(KahaAddMessageCommand command) throws IOException {</a>
<span class="sourceLineNo">1270</span><a id="line.1270">                process(command, location, onSequenceAssignedCallback);</a>
<span class="sourceLineNo">1271</span><a id="line.1271">            }</a>
<span class="sourceLineNo">1272</span><a id="line.1272"></a>
<span class="sourceLineNo">1273</span><a id="line.1273">            @Override</a>
<span class="sourceLineNo">1274</span><a id="line.1274">            public void visit(KahaRemoveMessageCommand command) throws IOException {</a>
<span class="sourceLineNo">1275</span><a id="line.1275">                process(command, location);</a>
<span class="sourceLineNo">1276</span><a id="line.1276">            }</a>
<span class="sourceLineNo">1277</span><a id="line.1277"></a>
<span class="sourceLineNo">1278</span><a id="line.1278">            @Override</a>
<span class="sourceLineNo">1279</span><a id="line.1279">            public void visit(KahaPrepareCommand command) throws IOException {</a>
<span class="sourceLineNo">1280</span><a id="line.1280">                process(command, location);</a>
<span class="sourceLineNo">1281</span><a id="line.1281">            }</a>
<span class="sourceLineNo">1282</span><a id="line.1282"></a>
<span class="sourceLineNo">1283</span><a id="line.1283">            @Override</a>
<span class="sourceLineNo">1284</span><a id="line.1284">            public void visit(KahaCommitCommand command) throws IOException {</a>
<span class="sourceLineNo">1285</span><a id="line.1285">                process(command, location, onSequenceAssignedCallback);</a>
<span class="sourceLineNo">1286</span><a id="line.1286">            }</a>
<span class="sourceLineNo">1287</span><a id="line.1287"></a>
<span class="sourceLineNo">1288</span><a id="line.1288">            @Override</a>
<span class="sourceLineNo">1289</span><a id="line.1289">            public void visit(KahaRollbackCommand command) throws IOException {</a>
<span class="sourceLineNo">1290</span><a id="line.1290">                process(command, location);</a>
<span class="sourceLineNo">1291</span><a id="line.1291">            }</a>
<span class="sourceLineNo">1292</span><a id="line.1292"></a>
<span class="sourceLineNo">1293</span><a id="line.1293">            @Override</a>
<span class="sourceLineNo">1294</span><a id="line.1294">            public void visit(KahaRemoveDestinationCommand command) throws IOException {</a>
<span class="sourceLineNo">1295</span><a id="line.1295">                process(command, location);</a>
<span class="sourceLineNo">1296</span><a id="line.1296">            }</a>
<span class="sourceLineNo">1297</span><a id="line.1297"></a>
<span class="sourceLineNo">1298</span><a id="line.1298">            @Override</a>
<span class="sourceLineNo">1299</span><a id="line.1299">            public void visit(KahaSubscriptionCommand command) throws IOException {</a>
<span class="sourceLineNo">1300</span><a id="line.1300">                process(command, location);</a>
<span class="sourceLineNo">1301</span><a id="line.1301">            }</a>
<span class="sourceLineNo">1302</span><a id="line.1302"></a>
<span class="sourceLineNo">1303</span><a id="line.1303">            @Override</a>
<span class="sourceLineNo">1304</span><a id="line.1304">            public void visit(KahaProducerAuditCommand command) throws IOException {</a>
<span class="sourceLineNo">1305</span><a id="line.1305">                processLocation(location);</a>
<span class="sourceLineNo">1306</span><a id="line.1306">            }</a>
<span class="sourceLineNo">1307</span><a id="line.1307"></a>
<span class="sourceLineNo">1308</span><a id="line.1308">            @Override</a>
<span class="sourceLineNo">1309</span><a id="line.1309">            public void visit(KahaAckMessageFileMapCommand command) throws IOException {</a>
<span class="sourceLineNo">1310</span><a id="line.1310">                processLocation(location);</a>
<span class="sourceLineNo">1311</span><a id="line.1311">            }</a>
<span class="sourceLineNo">1312</span><a id="line.1312"></a>
<span class="sourceLineNo">1313</span><a id="line.1313">            @Override</a>
<span class="sourceLineNo">1314</span><a id="line.1314">            public void visit(KahaTraceCommand command) {</a>
<span class="sourceLineNo">1315</span><a id="line.1315">                processLocation(location);</a>
<span class="sourceLineNo">1316</span><a id="line.1316">            }</a>
<span class="sourceLineNo">1317</span><a id="line.1317"></a>
<span class="sourceLineNo">1318</span><a id="line.1318">            @Override</a>
<span class="sourceLineNo">1319</span><a id="line.1319">            public void visit(KahaUpdateMessageCommand command) throws IOException {</a>
<span class="sourceLineNo">1320</span><a id="line.1320">                process(command, location);</a>
<span class="sourceLineNo">1321</span><a id="line.1321">            }</a>
<span class="sourceLineNo">1322</span><a id="line.1322"></a>
<span class="sourceLineNo">1323</span><a id="line.1323">            @Override</a>
<span class="sourceLineNo">1324</span><a id="line.1324">            public void visit(KahaRewrittenDataFileCommand command) throws IOException {</a>
<span class="sourceLineNo">1325</span><a id="line.1325">                process(command, location);</a>
<span class="sourceLineNo">1326</span><a id="line.1326">            }</a>
<span class="sourceLineNo">1327</span><a id="line.1327">        });</a>
<span class="sourceLineNo">1328</span><a id="line.1328">    }</a>
<span class="sourceLineNo">1329</span><a id="line.1329"></a>
<span class="sourceLineNo">1330</span><a id="line.1330">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">1331</span><a id="line.1331">    protected void process(final KahaAddMessageCommand command, final Location location, final IndexAware runWithIndexLock) throws IOException {</a>
<span class="sourceLineNo">1332</span><a id="line.1332">        if (command.hasTransactionInfo()) {</a>
<span class="sourceLineNo">1333</span><a id="line.1333">            List&lt;Operation&gt; inflightTx = getInflightTx(command.getTransactionInfo());</a>
<span class="sourceLineNo">1334</span><a id="line.1334">            inflightTx.add(new AddOperation(command, location, runWithIndexLock));</a>
<span class="sourceLineNo">1335</span><a id="line.1335">        } else {</a>
<span class="sourceLineNo">1336</span><a id="line.1336">            this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1337</span><a id="line.1337">            try {</a>
<span class="sourceLineNo">1338</span><a id="line.1338">                pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">1339</span><a id="line.1339">                    @Override</a>
<span class="sourceLineNo">1340</span><a id="line.1340">                    public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1341</span><a id="line.1341">                        long assignedIndex = updateIndex(tx, command, location);</a>
<span class="sourceLineNo">1342</span><a id="line.1342">                        if (runWithIndexLock != null) {</a>
<span class="sourceLineNo">1343</span><a id="line.1343">                            runWithIndexLock.sequenceAssignedWithIndexLocked(assignedIndex);</a>
<span class="sourceLineNo">1344</span><a id="line.1344">                        }</a>
<span class="sourceLineNo">1345</span><a id="line.1345">                    }</a>
<span class="sourceLineNo">1346</span><a id="line.1346">                });</a>
<span class="sourceLineNo">1347</span><a id="line.1347"></a>
<span class="sourceLineNo">1348</span><a id="line.1348">            } finally {</a>
<span class="sourceLineNo">1349</span><a id="line.1349">                this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1350</span><a id="line.1350">            }</a>
<span class="sourceLineNo">1351</span><a id="line.1351">        }</a>
<span class="sourceLineNo">1352</span><a id="line.1352">    }</a>
<span class="sourceLineNo">1353</span><a id="line.1353"></a>
<span class="sourceLineNo">1354</span><a id="line.1354">    protected void process(final KahaUpdateMessageCommand command, final Location location) throws IOException {</a>
<span class="sourceLineNo">1355</span><a id="line.1355">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1356</span><a id="line.1356">        try {</a>
<span class="sourceLineNo">1357</span><a id="line.1357">            pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">1358</span><a id="line.1358">                @Override</a>
<span class="sourceLineNo">1359</span><a id="line.1359">                public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1360</span><a id="line.1360">                    updateIndex(tx, command, location);</a>
<span class="sourceLineNo">1361</span><a id="line.1361">                }</a>
<span class="sourceLineNo">1362</span><a id="line.1362">            });</a>
<span class="sourceLineNo">1363</span><a id="line.1363">        } finally {</a>
<span class="sourceLineNo">1364</span><a id="line.1364">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1365</span><a id="line.1365">        }</a>
<span class="sourceLineNo">1366</span><a id="line.1366">    }</a>
<span class="sourceLineNo">1367</span><a id="line.1367"></a>
<span class="sourceLineNo">1368</span><a id="line.1368">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">1369</span><a id="line.1369">    protected void process(final KahaRemoveMessageCommand command, final Location location) throws IOException {</a>
<span class="sourceLineNo">1370</span><a id="line.1370">        if (command.hasTransactionInfo()) {</a>
<span class="sourceLineNo">1371</span><a id="line.1371">           List&lt;Operation&gt; inflightTx = getInflightTx(command.getTransactionInfo());</a>
<span class="sourceLineNo">1372</span><a id="line.1372">           inflightTx.add(new RemoveOperation(command, location));</a>
<span class="sourceLineNo">1373</span><a id="line.1373">        } else {</a>
<span class="sourceLineNo">1374</span><a id="line.1374">            this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1375</span><a id="line.1375">            try {</a>
<span class="sourceLineNo">1376</span><a id="line.1376">                pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">1377</span><a id="line.1377">                    @Override</a>
<span class="sourceLineNo">1378</span><a id="line.1378">                    public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1379</span><a id="line.1379">                        updateIndex(tx, command, location);</a>
<span class="sourceLineNo">1380</span><a id="line.1380">                    }</a>
<span class="sourceLineNo">1381</span><a id="line.1381">                });</a>
<span class="sourceLineNo">1382</span><a id="line.1382">            } finally {</a>
<span class="sourceLineNo">1383</span><a id="line.1383">                this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1384</span><a id="line.1384">            }</a>
<span class="sourceLineNo">1385</span><a id="line.1385">        }</a>
<span class="sourceLineNo">1386</span><a id="line.1386">    }</a>
<span class="sourceLineNo">1387</span><a id="line.1387"></a>
<span class="sourceLineNo">1388</span><a id="line.1388">    protected void process(final KahaRemoveDestinationCommand command, final Location location) throws IOException {</a>
<span class="sourceLineNo">1389</span><a id="line.1389">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1390</span><a id="line.1390">        try {</a>
<span class="sourceLineNo">1391</span><a id="line.1391">            pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">1392</span><a id="line.1392">                @Override</a>
<span class="sourceLineNo">1393</span><a id="line.1393">                public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1394</span><a id="line.1394">                    updateIndex(tx, command, location);</a>
<span class="sourceLineNo">1395</span><a id="line.1395">                }</a>
<span class="sourceLineNo">1396</span><a id="line.1396">            });</a>
<span class="sourceLineNo">1397</span><a id="line.1397">        } finally {</a>
<span class="sourceLineNo">1398</span><a id="line.1398">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1399</span><a id="line.1399">        }</a>
<span class="sourceLineNo">1400</span><a id="line.1400">    }</a>
<span class="sourceLineNo">1401</span><a id="line.1401"></a>
<span class="sourceLineNo">1402</span><a id="line.1402">    protected void process(final KahaSubscriptionCommand command, final Location location) throws IOException {</a>
<span class="sourceLineNo">1403</span><a id="line.1403">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1404</span><a id="line.1404">        try {</a>
<span class="sourceLineNo">1405</span><a id="line.1405">            pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">1406</span><a id="line.1406">                @Override</a>
<span class="sourceLineNo">1407</span><a id="line.1407">                public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1408</span><a id="line.1408">                    updateIndex(tx, command, location);</a>
<span class="sourceLineNo">1409</span><a id="line.1409">                }</a>
<span class="sourceLineNo">1410</span><a id="line.1410">            });</a>
<span class="sourceLineNo">1411</span><a id="line.1411">        } finally {</a>
<span class="sourceLineNo">1412</span><a id="line.1412">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1413</span><a id="line.1413">        }</a>
<span class="sourceLineNo">1414</span><a id="line.1414">    }</a>
<span class="sourceLineNo">1415</span><a id="line.1415"></a>
<span class="sourceLineNo">1416</span><a id="line.1416">    protected void processLocation(final Location location) {</a>
<span class="sourceLineNo">1417</span><a id="line.1417">        this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1418</span><a id="line.1418">        try {</a>
<span class="sourceLineNo">1419</span><a id="line.1419">            metadata.lastUpdate = location;</a>
<span class="sourceLineNo">1420</span><a id="line.1420">        } finally {</a>
<span class="sourceLineNo">1421</span><a id="line.1421">            this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1422</span><a id="line.1422">        }</a>
<span class="sourceLineNo">1423</span><a id="line.1423">    }</a>
<span class="sourceLineNo">1424</span><a id="line.1424"></a>
<span class="sourceLineNo">1425</span><a id="line.1425">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">1426</span><a id="line.1426">    protected void process(KahaCommitCommand command, final Location location, final IndexAware before) throws IOException {</a>
<span class="sourceLineNo">1427</span><a id="line.1427">        TransactionId key = TransactionIdConversion.convert(command.getTransactionInfo());</a>
<span class="sourceLineNo">1428</span><a id="line.1428">        List&lt;Operation&gt; inflightTx;</a>
<span class="sourceLineNo">1429</span><a id="line.1429">        synchronized (inflightTransactions) {</a>
<span class="sourceLineNo">1430</span><a id="line.1430">            inflightTx = inflightTransactions.remove(key);</a>
<span class="sourceLineNo">1431</span><a id="line.1431">            if (inflightTx == null) {</a>
<span class="sourceLineNo">1432</span><a id="line.1432">                inflightTx = preparedTransactions.remove(key);</a>
<span class="sourceLineNo">1433</span><a id="line.1433">            }</a>
<span class="sourceLineNo">1434</span><a id="line.1434">        }</a>
<span class="sourceLineNo">1435</span><a id="line.1435">        if (inflightTx == null) {</a>
<span class="sourceLineNo">1436</span><a id="line.1436">            // only non persistent messages in this tx</a>
<span class="sourceLineNo">1437</span><a id="line.1437">            if (before != null) {</a>
<span class="sourceLineNo">1438</span><a id="line.1438">                before.sequenceAssignedWithIndexLocked(-1);</a>
<span class="sourceLineNo">1439</span><a id="line.1439">            }</a>
<span class="sourceLineNo">1440</span><a id="line.1440">            // Moving the checkpoint pointer as there is no persistent operations in this transaction to be replayed</a>
<span class="sourceLineNo">1441</span><a id="line.1441">            processLocation(location);</a>
<span class="sourceLineNo">1442</span><a id="line.1442">            return;</a>
<span class="sourceLineNo">1443</span><a id="line.1443">        }</a>
<span class="sourceLineNo">1444</span><a id="line.1444"></a>
<span class="sourceLineNo">1445</span><a id="line.1445">        final List&lt;Operation&gt; messagingTx = inflightTx;</a>
<span class="sourceLineNo">1446</span><a id="line.1446">        indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1447</span><a id="line.1447">        try {</a>
<span class="sourceLineNo">1448</span><a id="line.1448">            pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">1449</span><a id="line.1449">                @Override</a>
<span class="sourceLineNo">1450</span><a id="line.1450">                public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1451</span><a id="line.1451">                    for (Operation op : messagingTx) {</a>
<span class="sourceLineNo">1452</span><a id="line.1452">                        op.execute(tx);</a>
<span class="sourceLineNo">1453</span><a id="line.1453">                        recordAckMessageReferenceLocation(location, op.getLocation());</a>
<span class="sourceLineNo">1454</span><a id="line.1454">                    }</a>
<span class="sourceLineNo">1455</span><a id="line.1455">                }</a>
<span class="sourceLineNo">1456</span><a id="line.1456">            });</a>
<span class="sourceLineNo">1457</span><a id="line.1457">            metadata.lastUpdate = location;</a>
<span class="sourceLineNo">1458</span><a id="line.1458">        } finally {</a>
<span class="sourceLineNo">1459</span><a id="line.1459">            indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1460</span><a id="line.1460">        }</a>
<span class="sourceLineNo">1461</span><a id="line.1461">    }</a>
<span class="sourceLineNo">1462</span><a id="line.1462"></a>
<span class="sourceLineNo">1463</span><a id="line.1463">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">1464</span><a id="line.1464">    protected void process(KahaPrepareCommand command, Location location) {</a>
<span class="sourceLineNo">1465</span><a id="line.1465">        TransactionId key = TransactionIdConversion.convert(command.getTransactionInfo());</a>
<span class="sourceLineNo">1466</span><a id="line.1466">        List&lt;Operation&gt; tx = null;</a>
<span class="sourceLineNo">1467</span><a id="line.1467">        synchronized (inflightTransactions) {</a>
<span class="sourceLineNo">1468</span><a id="line.1468">            tx = inflightTransactions.remove(key);</a>
<span class="sourceLineNo">1469</span><a id="line.1469">            if (tx != null) {</a>
<span class="sourceLineNo">1470</span><a id="line.1470">                preparedTransactions.put(key, tx);</a>
<span class="sourceLineNo">1471</span><a id="line.1471">            }</a>
<span class="sourceLineNo">1472</span><a id="line.1472">        }</a>
<span class="sourceLineNo">1473</span><a id="line.1473">        if (tx != null &amp;&amp; !tx.isEmpty()) {</a>
<span class="sourceLineNo">1474</span><a id="line.1474">            indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1475</span><a id="line.1475">            try {</a>
<span class="sourceLineNo">1476</span><a id="line.1476">                for (Operation op : tx) {</a>
<span class="sourceLineNo">1477</span><a id="line.1477">                    recordAckMessageReferenceLocation(location, op.getLocation());</a>
<span class="sourceLineNo">1478</span><a id="line.1478">                }</a>
<span class="sourceLineNo">1479</span><a id="line.1479">            } finally {</a>
<span class="sourceLineNo">1480</span><a id="line.1480">                indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1481</span><a id="line.1481">            }</a>
<span class="sourceLineNo">1482</span><a id="line.1482">        }</a>
<span class="sourceLineNo">1483</span><a id="line.1483">    }</a>
<span class="sourceLineNo">1484</span><a id="line.1484"></a>
<span class="sourceLineNo">1485</span><a id="line.1485">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">1486</span><a id="line.1486">    protected void process(KahaRollbackCommand command, Location location)  throws IOException {</a>
<span class="sourceLineNo">1487</span><a id="line.1487">        TransactionId key = TransactionIdConversion.convert(command.getTransactionInfo());</a>
<span class="sourceLineNo">1488</span><a id="line.1488">        List&lt;Operation&gt; updates = null;</a>
<span class="sourceLineNo">1489</span><a id="line.1489">        synchronized (inflightTransactions) {</a>
<span class="sourceLineNo">1490</span><a id="line.1490">            updates = inflightTransactions.remove(key);</a>
<span class="sourceLineNo">1491</span><a id="line.1491">            if (updates == null) {</a>
<span class="sourceLineNo">1492</span><a id="line.1492">                updates = preparedTransactions.remove(key);</a>
<span class="sourceLineNo">1493</span><a id="line.1493">            }</a>
<span class="sourceLineNo">1494</span><a id="line.1494">        }</a>
<span class="sourceLineNo">1495</span><a id="line.1495">        if (key.isXATransaction() &amp;&amp; updates != null &amp;&amp; !updates.isEmpty()) {</a>
<span class="sourceLineNo">1496</span><a id="line.1496">            indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1497</span><a id="line.1497">            try {</a>
<span class="sourceLineNo">1498</span><a id="line.1498">                for (Operation op : updates) {</a>
<span class="sourceLineNo">1499</span><a id="line.1499">                    recordAckMessageReferenceLocation(location, op.getLocation());</a>
<span class="sourceLineNo">1500</span><a id="line.1500">                }</a>
<span class="sourceLineNo">1501</span><a id="line.1501">            } finally {</a>
<span class="sourceLineNo">1502</span><a id="line.1502">                indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1503</span><a id="line.1503">            }</a>
<span class="sourceLineNo">1504</span><a id="line.1504">        }</a>
<span class="sourceLineNo">1505</span><a id="line.1505">    }</a>
<span class="sourceLineNo">1506</span><a id="line.1506"></a>
<span class="sourceLineNo">1507</span><a id="line.1507">    protected void process(KahaRewrittenDataFileCommand command, Location location)  throws IOException {</a>
<span class="sourceLineNo">1508</span><a id="line.1508">        final TreeSet&lt;Integer&gt; completeFileSet = new TreeSet&lt;&gt;(journal.getFileMap().keySet());</a>
<span class="sourceLineNo">1509</span><a id="line.1509"></a>
<span class="sourceLineNo">1510</span><a id="line.1510">        // Mark the current journal file as a compacted file so that gc checks can skip</a>
<span class="sourceLineNo">1511</span><a id="line.1511">        // over logs that are smaller compaction type logs.</a>
<span class="sourceLineNo">1512</span><a id="line.1512">        DataFile current = journal.getDataFileById(location.getDataFileId());</a>
<span class="sourceLineNo">1513</span><a id="line.1513">        current.setTypeCode(command.getRewriteType());</a>
<span class="sourceLineNo">1514</span><a id="line.1514"></a>
<span class="sourceLineNo">1515</span><a id="line.1515">        if (completeFileSet.contains(command.getSourceDataFileId()) &amp;&amp; command.getSkipIfSourceExists()) {</a>
<span class="sourceLineNo">1516</span><a id="line.1516">            // Move offset so that next location read jumps to next file.</a>
<span class="sourceLineNo">1517</span><a id="line.1517">            location.setOffset(journalMaxFileLength);</a>
<span class="sourceLineNo">1518</span><a id="line.1518">        }</a>
<span class="sourceLineNo">1519</span><a id="line.1519">    }</a>
<span class="sourceLineNo">1520</span><a id="line.1520"></a>
<span class="sourceLineNo">1521</span><a id="line.1521">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">1522</span><a id="line.1522">    // These methods do the actual index updates.</a>
<span class="sourceLineNo">1523</span><a id="line.1523">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">1524</span><a id="line.1524"></a>
<span class="sourceLineNo">1525</span><a id="line.1525">    protected final ReentrantReadWriteLock indexLock = new ReentrantReadWriteLock();</a>
<span class="sourceLineNo">1526</span><a id="line.1526">    private final HashSet&lt;Integer&gt; journalFilesBeingReplicated = new HashSet&lt;&gt;();</a>
<span class="sourceLineNo">1527</span><a id="line.1527"></a>
<span class="sourceLineNo">1528</span><a id="line.1528">    long updateIndex(Transaction tx, KahaAddMessageCommand command, Location location) throws IOException {</a>
<span class="sourceLineNo">1529</span><a id="line.1529">        StoredDestination sd = getExistingStoredDestination(command.getDestination(), tx);</a>
<span class="sourceLineNo">1530</span><a id="line.1530">        if (sd == null) {</a>
<span class="sourceLineNo">1531</span><a id="line.1531">            // if the store no longer exists, skip</a>
<span class="sourceLineNo">1532</span><a id="line.1532">            return -1;</a>
<span class="sourceLineNo">1533</span><a id="line.1533">        }</a>
<span class="sourceLineNo">1534</span><a id="line.1534">        // Skip adding the message to the index if this is a topic and there are</a>
<span class="sourceLineNo">1535</span><a id="line.1535">        // no subscriptions.</a>
<span class="sourceLineNo">1536</span><a id="line.1536">        if (sd.subscriptions != null &amp;&amp; sd.subscriptions.isEmpty(tx)) {</a>
<span class="sourceLineNo">1537</span><a id="line.1537">            return -1;</a>
<span class="sourceLineNo">1538</span><a id="line.1538">        }</a>
<span class="sourceLineNo">1539</span><a id="line.1539"></a>
<span class="sourceLineNo">1540</span><a id="line.1540">        // Add the message.</a>
<span class="sourceLineNo">1541</span><a id="line.1541">        int priority = command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY;</a>
<span class="sourceLineNo">1542</span><a id="line.1542">        long id = sd.orderIndex.getNextMessageId();</a>
<span class="sourceLineNo">1543</span><a id="line.1543">        Long previous = sd.locationIndex.put(tx, location, id);</a>
<span class="sourceLineNo">1544</span><a id="line.1544">        if (previous == null) {</a>
<span class="sourceLineNo">1545</span><a id="line.1545">            previous = sd.messageIdIndex.put(tx, command.getMessageId(), id);</a>
<span class="sourceLineNo">1546</span><a id="line.1546">            if (previous == null) {</a>
<span class="sourceLineNo">1547</span><a id="line.1547">                incrementAndAddSizeToStoreStat(tx, command.getDestination(), location.getSize());</a>
<span class="sourceLineNo">1548</span><a id="line.1548">                sd.orderIndex.put(tx, priority, id, new MessageKeys(command.getMessageId(), location));</a>
<span class="sourceLineNo">1549</span><a id="line.1549">                if (sd.subscriptions != null &amp;&amp; !sd.subscriptions.isEmpty(tx)) {</a>
<span class="sourceLineNo">1550</span><a id="line.1550">                    addAckLocationForNewMessage(tx, command.getDestination(), sd, id);</a>
<span class="sourceLineNo">1551</span><a id="line.1551">                }</a>
<span class="sourceLineNo">1552</span><a id="line.1552">                metadata.lastUpdate = location;</a>
<span class="sourceLineNo">1553</span><a id="line.1553">            } else {</a>
<span class="sourceLineNo">1554</span><a id="line.1554"></a>
<span class="sourceLineNo">1555</span><a id="line.1555">                MessageKeys messageKeys = sd.orderIndex.get(tx, previous);</a>
<span class="sourceLineNo">1556</span><a id="line.1556">                if (messageKeys != null &amp;&amp; messageKeys.location.compareTo(location) &lt; 0) {</a>
<span class="sourceLineNo">1557</span><a id="line.1557">                    // If the message ID is indexed, then the broker asked us to store a duplicate before the message was dispatched and acked, we ignore this add attempt</a>
<span class="sourceLineNo">1558</span><a id="line.1558">                    LOG.warn("Duplicate message add attempt rejected. Destination: {}://{}, Message id: {}", command.getDestination().getType(), command.getDestination().getName(), command.getMessageId());</a>
<span class="sourceLineNo">1559</span><a id="line.1559">                }</a>
<span class="sourceLineNo">1560</span><a id="line.1560">                sd.messageIdIndex.put(tx, command.getMessageId(), previous);</a>
<span class="sourceLineNo">1561</span><a id="line.1561">                sd.locationIndex.remove(tx, location);</a>
<span class="sourceLineNo">1562</span><a id="line.1562">                id = -1;</a>
<span class="sourceLineNo">1563</span><a id="line.1563">            }</a>
<span class="sourceLineNo">1564</span><a id="line.1564">        } else {</a>
<span class="sourceLineNo">1565</span><a id="line.1565">            // restore the previous value.. Looks like this was a redo of a previously</a>
<span class="sourceLineNo">1566</span><a id="line.1566">            // added message. We don't want to assign it a new id as the other indexes would</a>
<span class="sourceLineNo">1567</span><a id="line.1567">            // be wrong..</a>
<span class="sourceLineNo">1568</span><a id="line.1568">            sd.locationIndex.put(tx, location, previous);</a>
<span class="sourceLineNo">1569</span><a id="line.1569">            // ensure sequence is not broken</a>
<span class="sourceLineNo">1570</span><a id="line.1570">            sd.orderIndex.revertNextMessageId();</a>
<span class="sourceLineNo">1571</span><a id="line.1571">            metadata.lastUpdate = location;</a>
<span class="sourceLineNo">1572</span><a id="line.1572">        }</a>
<span class="sourceLineNo">1573</span><a id="line.1573">        // record this id in any event, initial send or recovery</a>
<span class="sourceLineNo">1574</span><a id="line.1574">        metadata.producerSequenceIdTracker.isDuplicate(command.getMessageId());</a>
<span class="sourceLineNo">1575</span><a id="line.1575"></a>
<span class="sourceLineNo">1576</span><a id="line.1576">       return id;</a>
<span class="sourceLineNo">1577</span><a id="line.1577">    }</a>
<span class="sourceLineNo">1578</span><a id="line.1578"></a>
<span class="sourceLineNo">1579</span><a id="line.1579">    void trackPendingAdd(KahaDestination destination, Long seq) {</a>
<span class="sourceLineNo">1580</span><a id="line.1580">        StoredDestination sd = storedDestinations.get(key(destination));</a>
<span class="sourceLineNo">1581</span><a id="line.1581">        if (sd != null) {</a>
<span class="sourceLineNo">1582</span><a id="line.1582">            sd.trackPendingAdd(seq);</a>
<span class="sourceLineNo">1583</span><a id="line.1583">        }</a>
<span class="sourceLineNo">1584</span><a id="line.1584">    }</a>
<span class="sourceLineNo">1585</span><a id="line.1585"></a>
<span class="sourceLineNo">1586</span><a id="line.1586">    void trackPendingAddComplete(KahaDestination destination, Long seq) {</a>
<span class="sourceLineNo">1587</span><a id="line.1587">        StoredDestination sd = storedDestinations.get(key(destination));</a>
<span class="sourceLineNo">1588</span><a id="line.1588">        if (sd != null) {</a>
<span class="sourceLineNo">1589</span><a id="line.1589">            sd.trackPendingAddComplete(seq);</a>
<span class="sourceLineNo">1590</span><a id="line.1590">        }</a>
<span class="sourceLineNo">1591</span><a id="line.1591">    }</a>
<span class="sourceLineNo">1592</span><a id="line.1592"></a>
<span class="sourceLineNo">1593</span><a id="line.1593">    void updateIndex(Transaction tx, KahaUpdateMessageCommand updateMessageCommand, Location location) throws IOException {</a>
<span class="sourceLineNo">1594</span><a id="line.1594">        KahaAddMessageCommand command = updateMessageCommand.getMessage();</a>
<span class="sourceLineNo">1595</span><a id="line.1595">        StoredDestination sd = getStoredDestination(command.getDestination(), tx);</a>
<span class="sourceLineNo">1596</span><a id="line.1596"></a>
<span class="sourceLineNo">1597</span><a id="line.1597">        Long id = sd.messageIdIndex.get(tx, command.getMessageId());</a>
<span class="sourceLineNo">1598</span><a id="line.1598">        if (id != null) {</a>
<span class="sourceLineNo">1599</span><a id="line.1599">            MessageKeys previousKeys = sd.orderIndex.put(</a>
<span class="sourceLineNo">1600</span><a id="line.1600">                    tx,</a>
<span class="sourceLineNo">1601</span><a id="line.1601">                    command.getPrioritySupported() ? command.getPriority() : javax.jms.Message.DEFAULT_PRIORITY,</a>
<span class="sourceLineNo">1602</span><a id="line.1602">                    id,</a>
<span class="sourceLineNo">1603</span><a id="line.1603">                    new MessageKeys(command.getMessageId(), location)</a>
<span class="sourceLineNo">1604</span><a id="line.1604">            );</a>
<span class="sourceLineNo">1605</span><a id="line.1605">            sd.locationIndex.put(tx, location, id);</a>
<span class="sourceLineNo">1606</span><a id="line.1606">            incrementAndAddSizeToStoreStat(tx, command.getDestination(), location.getSize());</a>
<span class="sourceLineNo">1607</span><a id="line.1607"></a>
<span class="sourceLineNo">1608</span><a id="line.1608">            if (previousKeys != null) {</a>
<span class="sourceLineNo">1609</span><a id="line.1609">                //Remove the existing from the size</a>
<span class="sourceLineNo">1610</span><a id="line.1610">                decrementAndSubSizeToStoreStat(tx, command.getDestination(), previousKeys.location.getSize());</a>
<span class="sourceLineNo">1611</span><a id="line.1611"></a>
<span class="sourceLineNo">1612</span><a id="line.1612">                //update all the subscription metrics</a>
<span class="sourceLineNo">1613</span><a id="line.1613">                if (enableSubscriptionStatistics &amp;&amp; sd.ackPositions != null &amp;&amp; location.getSize() != previousKeys.location.getSize()) {</a>
<span class="sourceLineNo">1614</span><a id="line.1614">                    Iterator&lt;Entry&lt;String, SequenceSet&gt;&gt; iter = sd.ackPositions.iterator(tx);</a>
<span class="sourceLineNo">1615</span><a id="line.1615">                    while (iter.hasNext()) {</a>
<span class="sourceLineNo">1616</span><a id="line.1616">                        Entry&lt;String, SequenceSet&gt; e = iter.next();</a>
<span class="sourceLineNo">1617</span><a id="line.1617">                        if (e.getValue().contains(id)) {</a>
<span class="sourceLineNo">1618</span><a id="line.1618">                            incrementAndAddSizeToStoreStat(key(command.getDestination()), e.getKey(), location.getSize());</a>
<span class="sourceLineNo">1619</span><a id="line.1619">                            decrementAndSubSizeToStoreStat(key(command.getDestination()), e.getKey(), previousKeys.location.getSize());</a>
<span class="sourceLineNo">1620</span><a id="line.1620">                        }</a>
<span class="sourceLineNo">1621</span><a id="line.1621">                    }</a>
<span class="sourceLineNo">1622</span><a id="line.1622">                }</a>
<span class="sourceLineNo">1623</span><a id="line.1623"></a>
<span class="sourceLineNo">1624</span><a id="line.1624">                // on first update previous is original location, on recovery/replay it may be the updated location</a>
<span class="sourceLineNo">1625</span><a id="line.1625">                if(!previousKeys.location.equals(location)) {</a>
<span class="sourceLineNo">1626</span><a id="line.1626">                    sd.locationIndex.remove(tx, previousKeys.location);</a>
<span class="sourceLineNo">1627</span><a id="line.1627">                }</a>
<span class="sourceLineNo">1628</span><a id="line.1628">            }</a>
<span class="sourceLineNo">1629</span><a id="line.1629">            metadata.lastUpdate = location;</a>
<span class="sourceLineNo">1630</span><a id="line.1630">        } else {</a>
<span class="sourceLineNo">1631</span><a id="line.1631">            //Add the message if it can't be found</a>
<span class="sourceLineNo">1632</span><a id="line.1632">            this.updateIndex(tx, command, location);</a>
<span class="sourceLineNo">1633</span><a id="line.1633">        }</a>
<span class="sourceLineNo">1634</span><a id="line.1634">    }</a>
<span class="sourceLineNo">1635</span><a id="line.1635"></a>
<span class="sourceLineNo">1636</span><a id="line.1636">    void updateIndex(Transaction tx, KahaRemoveMessageCommand command, Location ackLocation) throws IOException {</a>
<span class="sourceLineNo">1637</span><a id="line.1637">        StoredDestination sd = getStoredDestination(command.getDestination(), tx);</a>
<span class="sourceLineNo">1638</span><a id="line.1638">        if (!command.hasSubscriptionKey()) {</a>
<span class="sourceLineNo">1639</span><a id="line.1639"></a>
<span class="sourceLineNo">1640</span><a id="line.1640">            // In the queue case we just remove the message from the index..</a>
<span class="sourceLineNo">1641</span><a id="line.1641">            Long sequenceId = sd.messageIdIndex.remove(tx, command.getMessageId());</a>
<span class="sourceLineNo">1642</span><a id="line.1642">            if (sequenceId != null) {</a>
<span class="sourceLineNo">1643</span><a id="line.1643">                MessageKeys keys = sd.orderIndex.remove(tx, sequenceId);</a>
<span class="sourceLineNo">1644</span><a id="line.1644">                if (keys != null) {</a>
<span class="sourceLineNo">1645</span><a id="line.1645">                    sd.locationIndex.remove(tx, keys.location);</a>
<span class="sourceLineNo">1646</span><a id="line.1646">                    decrementAndSubSizeToStoreStat(tx, command.getDestination(), keys.location.getSize());</a>
<span class="sourceLineNo">1647</span><a id="line.1647">                    recordAckMessageReferenceLocation(ackLocation, keys.location);</a>
<span class="sourceLineNo">1648</span><a id="line.1648">                    metadata.lastUpdate = ackLocation;</a>
<span class="sourceLineNo">1649</span><a id="line.1649">                }  else if (LOG.isDebugEnabled()) {</a>
<span class="sourceLineNo">1650</span><a id="line.1650">                    LOG.debug("message not found in order index: " + sequenceId  + " for: " + command.getMessageId());</a>
<span class="sourceLineNo">1651</span><a id="line.1651">                }</a>
<span class="sourceLineNo">1652</span><a id="line.1652">            } else if (LOG.isDebugEnabled()) {</a>
<span class="sourceLineNo">1653</span><a id="line.1653">                LOG.debug("message not found in sequence id index: " + command.getMessageId());</a>
<span class="sourceLineNo">1654</span><a id="line.1654">            }</a>
<span class="sourceLineNo">1655</span><a id="line.1655">        } else {</a>
<span class="sourceLineNo">1656</span><a id="line.1656">            // In the topic case we need remove the message once it's been acked</a>
<span class="sourceLineNo">1657</span><a id="line.1657">            // by all the subs</a>
<span class="sourceLineNo">1658</span><a id="line.1658">            Long sequence = sd.messageIdIndex.get(tx, command.getMessageId());</a>
<span class="sourceLineNo">1659</span><a id="line.1659"></a>
<span class="sourceLineNo">1660</span><a id="line.1660">            // Make sure it's a valid message id...</a>
<span class="sourceLineNo">1661</span><a id="line.1661">            if (sequence != null) {</a>
<span class="sourceLineNo">1662</span><a id="line.1662">                String subscriptionKey = command.getSubscriptionKey();</a>
<span class="sourceLineNo">1663</span><a id="line.1663">                if (command.getAck() != UNMATCHED) {</a>
<span class="sourceLineNo">1664</span><a id="line.1664">                    sd.orderIndex.get(tx, sequence);</a>
<span class="sourceLineNo">1665</span><a id="line.1665">                    byte priority = sd.orderIndex.lastGetPriority();</a>
<span class="sourceLineNo">1666</span><a id="line.1666">                    sd.subscriptionAcks.put(tx, subscriptionKey, new LastAck(sequence, priority));</a>
<span class="sourceLineNo">1667</span><a id="line.1667">                }</a>
<span class="sourceLineNo">1668</span><a id="line.1668"></a>
<span class="sourceLineNo">1669</span><a id="line.1669">                MessageKeys keys = sd.orderIndex.get(tx, sequence);</a>
<span class="sourceLineNo">1670</span><a id="line.1670">                if (keys != null) {</a>
<span class="sourceLineNo">1671</span><a id="line.1671">                    recordAckMessageReferenceLocation(ackLocation, keys.location);</a>
<span class="sourceLineNo">1672</span><a id="line.1672">                }</a>
<span class="sourceLineNo">1673</span><a id="line.1673">                // The following method handles deleting un-referenced messages.</a>
<span class="sourceLineNo">1674</span><a id="line.1674">                removeAckLocation(command, tx, sd, subscriptionKey, sequence);</a>
<span class="sourceLineNo">1675</span><a id="line.1675">                metadata.lastUpdate = ackLocation;</a>
<span class="sourceLineNo">1676</span><a id="line.1676">            } else if (LOG.isDebugEnabled()) {</a>
<span class="sourceLineNo">1677</span><a id="line.1677">                LOG.debug("on ack, no message sequence exists for id: " + command.getMessageId() + " and sub: " + command.getSubscriptionKey());</a>
<span class="sourceLineNo">1678</span><a id="line.1678">            }</a>
<span class="sourceLineNo">1679</span><a id="line.1679"></a>
<span class="sourceLineNo">1680</span><a id="line.1680">        }</a>
<span class="sourceLineNo">1681</span><a id="line.1681">    }</a>
<span class="sourceLineNo">1682</span><a id="line.1682"></a>
<span class="sourceLineNo">1683</span><a id="line.1683">    private void recordAckMessageReferenceLocation(Location ackLocation, Location messageLocation) {</a>
<span class="sourceLineNo">1684</span><a id="line.1684">        Set&lt;Integer&gt; referenceFileIds = metadata.ackMessageFileMap.get(Integer.valueOf(ackLocation.getDataFileId()));</a>
<span class="sourceLineNo">1685</span><a id="line.1685">        if (referenceFileIds == null) {</a>
<span class="sourceLineNo">1686</span><a id="line.1686">            referenceFileIds = new HashSet&lt;&gt;();</a>
<span class="sourceLineNo">1687</span><a id="line.1687">            referenceFileIds.add(messageLocation.getDataFileId());</a>
<span class="sourceLineNo">1688</span><a id="line.1688">            metadata.ackMessageFileMap.put(ackLocation.getDataFileId(), referenceFileIds);</a>
<span class="sourceLineNo">1689</span><a id="line.1689">            metadata.ackMessageFileMapDirtyFlag.lazySet(true);</a>
<span class="sourceLineNo">1690</span><a id="line.1690"></a>
<span class="sourceLineNo">1691</span><a id="line.1691">        } else {</a>
<span class="sourceLineNo">1692</span><a id="line.1692">            Integer id = Integer.valueOf(messageLocation.getDataFileId());</a>
<span class="sourceLineNo">1693</span><a id="line.1693">            if (!referenceFileIds.contains(id)) {</a>
<span class="sourceLineNo">1694</span><a id="line.1694">                referenceFileIds.add(id);</a>
<span class="sourceLineNo">1695</span><a id="line.1695">            }</a>
<span class="sourceLineNo">1696</span><a id="line.1696">        }</a>
<span class="sourceLineNo">1697</span><a id="line.1697">    }</a>
<span class="sourceLineNo">1698</span><a id="line.1698"></a>
<span class="sourceLineNo">1699</span><a id="line.1699">    void updateIndex(Transaction tx, KahaRemoveDestinationCommand command, Location location) throws IOException {</a>
<span class="sourceLineNo">1700</span><a id="line.1700">        StoredDestination sd = getStoredDestination(command.getDestination(), tx);</a>
<span class="sourceLineNo">1701</span><a id="line.1701">        sd.orderIndex.remove(tx);</a>
<span class="sourceLineNo">1702</span><a id="line.1702"></a>
<span class="sourceLineNo">1703</span><a id="line.1703">        sd.locationIndex.clear(tx);</a>
<span class="sourceLineNo">1704</span><a id="line.1704">        sd.locationIndex.unload(tx);</a>
<span class="sourceLineNo">1705</span><a id="line.1705">        tx.free(sd.locationIndex.getPageId());</a>
<span class="sourceLineNo">1706</span><a id="line.1706"></a>
<span class="sourceLineNo">1707</span><a id="line.1707">        sd.messageIdIndex.clear(tx);</a>
<span class="sourceLineNo">1708</span><a id="line.1708">        sd.messageIdIndex.unload(tx);</a>
<span class="sourceLineNo">1709</span><a id="line.1709">        tx.free(sd.messageIdIndex.getPageId());</a>
<span class="sourceLineNo">1710</span><a id="line.1710"></a>
<span class="sourceLineNo">1711</span><a id="line.1711">        tx.free(sd.messageStoreStatistics.getPageId());</a>
<span class="sourceLineNo">1712</span><a id="line.1712">        sd.messageStoreStatistics = null;</a>
<span class="sourceLineNo">1713</span><a id="line.1713"></a>
<span class="sourceLineNo">1714</span><a id="line.1714">        if (sd.subscriptions != null) {</a>
<span class="sourceLineNo">1715</span><a id="line.1715">            sd.subscriptions.clear(tx);</a>
<span class="sourceLineNo">1716</span><a id="line.1716">            sd.subscriptions.unload(tx);</a>
<span class="sourceLineNo">1717</span><a id="line.1717">            tx.free(sd.subscriptions.getPageId());</a>
<span class="sourceLineNo">1718</span><a id="line.1718"></a>
<span class="sourceLineNo">1719</span><a id="line.1719">            sd.subscriptionAcks.clear(tx);</a>
<span class="sourceLineNo">1720</span><a id="line.1720">            sd.subscriptionAcks.unload(tx);</a>
<span class="sourceLineNo">1721</span><a id="line.1721">            tx.free(sd.subscriptionAcks.getPageId());</a>
<span class="sourceLineNo">1722</span><a id="line.1722"></a>
<span class="sourceLineNo">1723</span><a id="line.1723">            sd.ackPositions.clear(tx);</a>
<span class="sourceLineNo">1724</span><a id="line.1724">            sd.ackPositions.unload(tx);</a>
<span class="sourceLineNo">1725</span><a id="line.1725">            tx.free(sd.ackPositions.getHeadPageId());</a>
<span class="sourceLineNo">1726</span><a id="line.1726"></a>
<span class="sourceLineNo">1727</span><a id="line.1727">            sd.subLocations.clear(tx);</a>
<span class="sourceLineNo">1728</span><a id="line.1728">            sd.subLocations.unload(tx);</a>
<span class="sourceLineNo">1729</span><a id="line.1729">            tx.free(sd.subLocations.getHeadPageId());</a>
<span class="sourceLineNo">1730</span><a id="line.1730">        }</a>
<span class="sourceLineNo">1731</span><a id="line.1731"></a>
<span class="sourceLineNo">1732</span><a id="line.1732">        String key = key(command.getDestination());</a>
<span class="sourceLineNo">1733</span><a id="line.1733">        storedDestinations.remove(key);</a>
<span class="sourceLineNo">1734</span><a id="line.1734">        metadata.destinations.remove(tx, key);</a>
<span class="sourceLineNo">1735</span><a id="line.1735">        clearStoreStats(command.getDestination());</a>
<span class="sourceLineNo">1736</span><a id="line.1736">        storeCache.remove(key(command.getDestination()));</a>
<span class="sourceLineNo">1737</span><a id="line.1737">    }</a>
<span class="sourceLineNo">1738</span><a id="line.1738"></a>
<span class="sourceLineNo">1739</span><a id="line.1739">    void updateIndex(Transaction tx, KahaSubscriptionCommand command, Location location) throws IOException {</a>
<span class="sourceLineNo">1740</span><a id="line.1740">        StoredDestination sd = getStoredDestination(command.getDestination(), tx);</a>
<span class="sourceLineNo">1741</span><a id="line.1741">        final String subscriptionKey = command.getSubscriptionKey();</a>
<span class="sourceLineNo">1742</span><a id="line.1742"></a>
<span class="sourceLineNo">1743</span><a id="line.1743">        // If set then we are creating it.. otherwise we are destroying the sub</a>
<span class="sourceLineNo">1744</span><a id="line.1744">        if (command.hasSubscriptionInfo()) {</a>
<span class="sourceLineNo">1745</span><a id="line.1745">            Location existing = sd.subLocations.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">1746</span><a id="line.1746">            if (existing != null &amp;&amp; existing.compareTo(location) == 0) {</a>
<span class="sourceLineNo">1747</span><a id="line.1747">                // replay on recovery, ignore</a>
<span class="sourceLineNo">1748</span><a id="line.1748">                LOG.trace("ignoring journal replay of replay of sub from: " + location);</a>
<span class="sourceLineNo">1749</span><a id="line.1749">                return;</a>
<span class="sourceLineNo">1750</span><a id="line.1750">            }</a>
<span class="sourceLineNo">1751</span><a id="line.1751"></a>
<span class="sourceLineNo">1752</span><a id="line.1752">            sd.subscriptions.put(tx, subscriptionKey, command);</a>
<span class="sourceLineNo">1753</span><a id="line.1753">            sd.subLocations.put(tx, subscriptionKey, location);</a>
<span class="sourceLineNo">1754</span><a id="line.1754">            long ackLocation=NOT_ACKED;</a>
<span class="sourceLineNo">1755</span><a id="line.1755">            if (!command.getRetroactive()) {</a>
<span class="sourceLineNo">1756</span><a id="line.1756">                ackLocation = sd.orderIndex.nextMessageId-1;</a>
<span class="sourceLineNo">1757</span><a id="line.1757">            } else {</a>
<span class="sourceLineNo">1758</span><a id="line.1758">                addAckLocationForRetroactiveSub(tx, sd, subscriptionKey);</a>
<span class="sourceLineNo">1759</span><a id="line.1759">            }</a>
<span class="sourceLineNo">1760</span><a id="line.1760">            sd.subscriptionAcks.put(tx, subscriptionKey, new LastAck(ackLocation));</a>
<span class="sourceLineNo">1761</span><a id="line.1761">            sd.subscriptionCache.add(subscriptionKey);</a>
<span class="sourceLineNo">1762</span><a id="line.1762">        } else {</a>
<span class="sourceLineNo">1763</span><a id="line.1763">            // delete the sub...</a>
<span class="sourceLineNo">1764</span><a id="line.1764">            sd.subscriptions.remove(tx, subscriptionKey);</a>
<span class="sourceLineNo">1765</span><a id="line.1765">            sd.subLocations.remove(tx, subscriptionKey);</a>
<span class="sourceLineNo">1766</span><a id="line.1766">            sd.subscriptionAcks.remove(tx, subscriptionKey);</a>
<span class="sourceLineNo">1767</span><a id="line.1767">            sd.subscriptionCache.remove(subscriptionKey);</a>
<span class="sourceLineNo">1768</span><a id="line.1768">            removeAckLocationsForSub(command, tx, sd, subscriptionKey);</a>
<span class="sourceLineNo">1769</span><a id="line.1769">            MessageStoreSubscriptionStatistics subStats = getSubStats(key(command.getDestination()));</a>
<span class="sourceLineNo">1770</span><a id="line.1770">            if (subStats != null) {</a>
<span class="sourceLineNo">1771</span><a id="line.1771">                subStats.removeSubscription(subscriptionKey);</a>
<span class="sourceLineNo">1772</span><a id="line.1772">            }</a>
<span class="sourceLineNo">1773</span><a id="line.1773"></a>
<span class="sourceLineNo">1774</span><a id="line.1774">            if (sd.subscriptions.isEmpty(tx)) {</a>
<span class="sourceLineNo">1775</span><a id="line.1775">                // remove the stored destination</a>
<span class="sourceLineNo">1776</span><a id="line.1776">                KahaRemoveDestinationCommand removeDestinationCommand = new KahaRemoveDestinationCommand();</a>
<span class="sourceLineNo">1777</span><a id="line.1777">                removeDestinationCommand.setDestination(command.getDestination());</a>
<span class="sourceLineNo">1778</span><a id="line.1778">                updateIndex(tx, removeDestinationCommand, null);</a>
<span class="sourceLineNo">1779</span><a id="line.1779">                clearStoreStats(command.getDestination());</a>
<span class="sourceLineNo">1780</span><a id="line.1780">            }</a>
<span class="sourceLineNo">1781</span><a id="line.1781">        }</a>
<span class="sourceLineNo">1782</span><a id="line.1782">    }</a>
<span class="sourceLineNo">1783</span><a id="line.1783"></a>
<span class="sourceLineNo">1784</span><a id="line.1784">    private void checkpointUpdate(final boolean cleanup) throws IOException {</a>
<span class="sourceLineNo">1785</span><a id="line.1785">        checkpointLock.writeLock().lock();</a>
<span class="sourceLineNo">1786</span><a id="line.1786">        try {</a>
<span class="sourceLineNo">1787</span><a id="line.1787">            this.indexLock.writeLock().lock();</a>
<span class="sourceLineNo">1788</span><a id="line.1788">            try {</a>
<span class="sourceLineNo">1789</span><a id="line.1789">                Set&lt;Integer&gt; filesToGc = pageFile.tx().execute(new Transaction.CallableClosure&lt;Set&lt;Integer&gt;, IOException&gt;() {</a>
<span class="sourceLineNo">1790</span><a id="line.1790">                    @Override</a>
<span class="sourceLineNo">1791</span><a id="line.1791">                    public Set&lt;Integer&gt; execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">1792</span><a id="line.1792">                        return checkpointUpdate(tx, cleanup);</a>
<span class="sourceLineNo">1793</span><a id="line.1793">                    }</a>
<span class="sourceLineNo">1794</span><a id="line.1794">                });</a>
<span class="sourceLineNo">1795</span><a id="line.1795">                pageFile.flush();</a>
<span class="sourceLineNo">1796</span><a id="line.1796">                // after the index update such that partial removal does not leave dangling references in the index.</a>
<span class="sourceLineNo">1797</span><a id="line.1797">                journal.removeDataFiles(filesToGc);</a>
<span class="sourceLineNo">1798</span><a id="line.1798">            } finally {</a>
<span class="sourceLineNo">1799</span><a id="line.1799">                this.indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">1800</span><a id="line.1800">            }</a>
<span class="sourceLineNo">1801</span><a id="line.1801"></a>
<span class="sourceLineNo">1802</span><a id="line.1802">        } finally {</a>
<span class="sourceLineNo">1803</span><a id="line.1803">            checkpointLock.writeLock().unlock();</a>
<span class="sourceLineNo">1804</span><a id="line.1804">        }</a>
<span class="sourceLineNo">1805</span><a id="line.1805">    }</a>
<span class="sourceLineNo">1806</span><a id="line.1806"></a>
<span class="sourceLineNo">1807</span><a id="line.1807">    /**</a>
<span class="sourceLineNo">1808</span><a id="line.1808">     * @param tx</a>
<span class="sourceLineNo">1809</span><a id="line.1809">     * @throws IOException</a>
<span class="sourceLineNo">1810</span><a id="line.1810">     */</a>
<span class="sourceLineNo">1811</span><a id="line.1811">    Set&lt;Integer&gt; checkpointUpdate(Transaction tx, boolean cleanup) throws IOException {</a>
<span class="sourceLineNo">1812</span><a id="line.1812">        MDC.put("activemq.persistenceDir", getDirectory().getName());</a>
<span class="sourceLineNo">1813</span><a id="line.1813">        LOG.debug("Checkpoint started.");</a>
<span class="sourceLineNo">1814</span><a id="line.1814"></a>
<span class="sourceLineNo">1815</span><a id="line.1815">        // reflect last update exclusive of current checkpoint</a>
<span class="sourceLineNo">1816</span><a id="line.1816">        Location lastUpdate = metadata.lastUpdate;</a>
<span class="sourceLineNo">1817</span><a id="line.1817"></a>
<span class="sourceLineNo">1818</span><a id="line.1818">        metadata.state = OPEN_STATE;</a>
<span class="sourceLineNo">1819</span><a id="line.1819">        metadata.producerSequenceIdTrackerLocation = checkpointProducerAudit();</a>
<span class="sourceLineNo">1820</span><a id="line.1820">        if (metadata.ackMessageFileMapDirtyFlag.get() || (metadata.ackMessageFileMapLocation == null)) {</a>
<span class="sourceLineNo">1821</span><a id="line.1821">            metadata.ackMessageFileMapLocation = checkpointAckMessageFileMap();</a>
<span class="sourceLineNo">1822</span><a id="line.1822">        }</a>
<span class="sourceLineNo">1823</span><a id="line.1823">        metadata.ackMessageFileMapDirtyFlag.lazySet(false);</a>
<span class="sourceLineNo">1824</span><a id="line.1824">        Location[] inProgressTxRange = getInProgressTxLocationRange();</a>
<span class="sourceLineNo">1825</span><a id="line.1825">        metadata.firstInProgressTransactionLocation = inProgressTxRange[0];</a>
<span class="sourceLineNo">1826</span><a id="line.1826">        tx.store(metadata.page, metadataMarshaller, true);</a>
<span class="sourceLineNo">1827</span><a id="line.1827"></a>
<span class="sourceLineNo">1828</span><a id="line.1828">        final TreeSet&lt;Integer&gt; gcCandidateSet = new TreeSet&lt;&gt;();</a>
<span class="sourceLineNo">1829</span><a id="line.1829">        if (cleanup) {</a>
<span class="sourceLineNo">1830</span><a id="line.1830"></a>
<span class="sourceLineNo">1831</span><a id="line.1831">            final TreeSet&lt;Integer&gt; completeFileSet = new TreeSet&lt;&gt;(journal.getFileMap().keySet());</a>
<span class="sourceLineNo">1832</span><a id="line.1832">            gcCandidateSet.addAll(completeFileSet);</a>
<span class="sourceLineNo">1833</span><a id="line.1833"></a>
<span class="sourceLineNo">1834</span><a id="line.1834">            if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1835</span><a id="line.1835">                LOG.trace("Last update: " + lastUpdate + ", full gc candidates set: " + gcCandidateSet);</a>
<span class="sourceLineNo">1836</span><a id="line.1836">            }</a>
<span class="sourceLineNo">1837</span><a id="line.1837"></a>
<span class="sourceLineNo">1838</span><a id="line.1838">            if (lastUpdate != null) {</a>
<span class="sourceLineNo">1839</span><a id="line.1839">                // we won't delete past the last update, ackCompaction journal can be a candidate in error</a>
<span class="sourceLineNo">1840</span><a id="line.1840">                gcCandidateSet.removeAll(new TreeSet&lt;Integer&gt;(gcCandidateSet.tailSet(lastUpdate.getDataFileId())));</a>
<span class="sourceLineNo">1841</span><a id="line.1841">            }</a>
<span class="sourceLineNo">1842</span><a id="line.1842"></a>
<span class="sourceLineNo">1843</span><a id="line.1843">            // Don't GC files under replication</a>
<span class="sourceLineNo">1844</span><a id="line.1844">            if( journalFilesBeingReplicated!=null ) {</a>
<span class="sourceLineNo">1845</span><a id="line.1845">                gcCandidateSet.removeAll(journalFilesBeingReplicated);</a>
<span class="sourceLineNo">1846</span><a id="line.1846">            }</a>
<span class="sourceLineNo">1847</span><a id="line.1847"></a>
<span class="sourceLineNo">1848</span><a id="line.1848">            if (metadata.producerSequenceIdTrackerLocation != null) {</a>
<span class="sourceLineNo">1849</span><a id="line.1849">                int dataFileId = metadata.producerSequenceIdTrackerLocation.getDataFileId();</a>
<span class="sourceLineNo">1850</span><a id="line.1850">                if (gcCandidateSet.contains(dataFileId) &amp;&amp; gcCandidateSet.first() == dataFileId) {</a>
<span class="sourceLineNo">1851</span><a id="line.1851">                    // rewrite so we don't prevent gc</a>
<span class="sourceLineNo">1852</span><a id="line.1852">                    metadata.producerSequenceIdTracker.setModified(true);</a>
<span class="sourceLineNo">1853</span><a id="line.1853">                    if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1854</span><a id="line.1854">                        LOG.trace("rewriting producerSequenceIdTracker:" + metadata.producerSequenceIdTrackerLocation);</a>
<span class="sourceLineNo">1855</span><a id="line.1855">                    }</a>
<span class="sourceLineNo">1856</span><a id="line.1856">                }</a>
<span class="sourceLineNo">1857</span><a id="line.1857">                gcCandidateSet.remove(dataFileId);</a>
<span class="sourceLineNo">1858</span><a id="line.1858">                if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1859</span><a id="line.1859">                    LOG.trace("gc candidates after producerSequenceIdTrackerLocation:" + metadata.producerSequenceIdTrackerLocation + ", " + gcCandidateSet);</a>
<span class="sourceLineNo">1860</span><a id="line.1860">                }</a>
<span class="sourceLineNo">1861</span><a id="line.1861">            }</a>
<span class="sourceLineNo">1862</span><a id="line.1862"></a>
<span class="sourceLineNo">1863</span><a id="line.1863">            if (metadata.ackMessageFileMapLocation != null) {</a>
<span class="sourceLineNo">1864</span><a id="line.1864">                int dataFileId = metadata.ackMessageFileMapLocation.getDataFileId();</a>
<span class="sourceLineNo">1865</span><a id="line.1865">                gcCandidateSet.remove(dataFileId);</a>
<span class="sourceLineNo">1866</span><a id="line.1866">                if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1867</span><a id="line.1867">                    LOG.trace("gc candidates after ackMessageFileMapLocation:" + metadata.ackMessageFileMapLocation + ", " + gcCandidateSet);</a>
<span class="sourceLineNo">1868</span><a id="line.1868">                }</a>
<span class="sourceLineNo">1869</span><a id="line.1869">            }</a>
<span class="sourceLineNo">1870</span><a id="line.1870"></a>
<span class="sourceLineNo">1871</span><a id="line.1871">            // Don't GC files referenced by in-progress tx</a>
<span class="sourceLineNo">1872</span><a id="line.1872">            if (inProgressTxRange[0] != null) {</a>
<span class="sourceLineNo">1873</span><a id="line.1873">                for (int pendingTx=inProgressTxRange[0].getDataFileId(); pendingTx &lt;= inProgressTxRange[1].getDataFileId(); pendingTx++) {</a>
<span class="sourceLineNo">1874</span><a id="line.1874">                    gcCandidateSet.remove(pendingTx);</a>
<span class="sourceLineNo">1875</span><a id="line.1875">                }</a>
<span class="sourceLineNo">1876</span><a id="line.1876">            }</a>
<span class="sourceLineNo">1877</span><a id="line.1877">            if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1878</span><a id="line.1878">                LOG.trace("gc candidates after in progress tx range:" + Arrays.asList(inProgressTxRange) + ", " + gcCandidateSet);</a>
<span class="sourceLineNo">1879</span><a id="line.1879">            }</a>
<span class="sourceLineNo">1880</span><a id="line.1880"></a>
<span class="sourceLineNo">1881</span><a id="line.1881">            // Go through all the destinations to see if any of them can remove GC candidates.</a>
<span class="sourceLineNo">1882</span><a id="line.1882">            for (Entry&lt;String, StoredDestination&gt; entry : storedDestinations.entrySet()) {</a>
<span class="sourceLineNo">1883</span><a id="line.1883">                if( gcCandidateSet.isEmpty() ) {</a>
<span class="sourceLineNo">1884</span><a id="line.1884">                    break;</a>
<span class="sourceLineNo">1885</span><a id="line.1885">                }</a>
<span class="sourceLineNo">1886</span><a id="line.1886"></a>
<span class="sourceLineNo">1887</span><a id="line.1887">                // Use a visitor to cut down the number of pages that we load</a>
<span class="sourceLineNo">1888</span><a id="line.1888">                entry.getValue().locationIndex.visit(tx, new BTreeVisitor&lt;Location, Long&gt;() {</a>
<span class="sourceLineNo">1889</span><a id="line.1889">                    int last=-1;</a>
<span class="sourceLineNo">1890</span><a id="line.1890">                    @Override</a>
<span class="sourceLineNo">1891</span><a id="line.1891">                    public boolean isInterestedInKeysBetween(Location first, Location second) {</a>
<span class="sourceLineNo">1892</span><a id="line.1892">                        if( first==null ) {</a>
<span class="sourceLineNo">1893</span><a id="line.1893">                            SortedSet&lt;Integer&gt; subset = gcCandidateSet.headSet(second.getDataFileId()+1);</a>
<span class="sourceLineNo">1894</span><a id="line.1894">                            if( !subset.isEmpty() &amp;&amp; subset.last() == second.getDataFileId() ) {</a>
<span class="sourceLineNo">1895</span><a id="line.1895">                                subset.remove(second.getDataFileId());</a>
<span class="sourceLineNo">1896</span><a id="line.1896">                            }</a>
<span class="sourceLineNo">1897</span><a id="line.1897">                            return !subset.isEmpty();</a>
<span class="sourceLineNo">1898</span><a id="line.1898">                        } else if( second==null ) {</a>
<span class="sourceLineNo">1899</span><a id="line.1899">                            SortedSet&lt;Integer&gt; subset = gcCandidateSet.tailSet(first.getDataFileId());</a>
<span class="sourceLineNo">1900</span><a id="line.1900">                            if( !subset.isEmpty() &amp;&amp; subset.first() == first.getDataFileId() ) {</a>
<span class="sourceLineNo">1901</span><a id="line.1901">                                subset.remove(first.getDataFileId());</a>
<span class="sourceLineNo">1902</span><a id="line.1902">                            }</a>
<span class="sourceLineNo">1903</span><a id="line.1903">                            return !subset.isEmpty();</a>
<span class="sourceLineNo">1904</span><a id="line.1904">                        } else {</a>
<span class="sourceLineNo">1905</span><a id="line.1905">                            SortedSet&lt;Integer&gt; subset = gcCandidateSet.subSet(first.getDataFileId(), second.getDataFileId()+1);</a>
<span class="sourceLineNo">1906</span><a id="line.1906">                            if( !subset.isEmpty() &amp;&amp; subset.first() == first.getDataFileId() ) {</a>
<span class="sourceLineNo">1907</span><a id="line.1907">                                subset.remove(first.getDataFileId());</a>
<span class="sourceLineNo">1908</span><a id="line.1908">                            }</a>
<span class="sourceLineNo">1909</span><a id="line.1909">                            if( !subset.isEmpty() &amp;&amp; subset.last() == second.getDataFileId() ) {</a>
<span class="sourceLineNo">1910</span><a id="line.1910">                                subset.remove(second.getDataFileId());</a>
<span class="sourceLineNo">1911</span><a id="line.1911">                            }</a>
<span class="sourceLineNo">1912</span><a id="line.1912">                            return !subset.isEmpty();</a>
<span class="sourceLineNo">1913</span><a id="line.1913">                        }</a>
<span class="sourceLineNo">1914</span><a id="line.1914">                    }</a>
<span class="sourceLineNo">1915</span><a id="line.1915"></a>
<span class="sourceLineNo">1916</span><a id="line.1916">                    @Override</a>
<span class="sourceLineNo">1917</span><a id="line.1917">                    public void visit(List&lt;Location&gt; keys, List&lt;Long&gt; values) {</a>
<span class="sourceLineNo">1918</span><a id="line.1918">                        for (Location l : keys) {</a>
<span class="sourceLineNo">1919</span><a id="line.1919">                            int fileId = l.getDataFileId();</a>
<span class="sourceLineNo">1920</span><a id="line.1920">                            if( last != fileId ) {</a>
<span class="sourceLineNo">1921</span><a id="line.1921">                                gcCandidateSet.remove(fileId);</a>
<span class="sourceLineNo">1922</span><a id="line.1922">                                last = fileId;</a>
<span class="sourceLineNo">1923</span><a id="line.1923">                            }</a>
<span class="sourceLineNo">1924</span><a id="line.1924">                        }</a>
<span class="sourceLineNo">1925</span><a id="line.1925">                    }</a>
<span class="sourceLineNo">1926</span><a id="line.1926">                });</a>
<span class="sourceLineNo">1927</span><a id="line.1927"></a>
<span class="sourceLineNo">1928</span><a id="line.1928">                // Durable Subscription</a>
<span class="sourceLineNo">1929</span><a id="line.1929">                if (entry.getValue().subLocations != null) {</a>
<span class="sourceLineNo">1930</span><a id="line.1930">                    Iterator&lt;Entry&lt;String, Location&gt;&gt; iter = entry.getValue().subLocations.iterator(tx);</a>
<span class="sourceLineNo">1931</span><a id="line.1931">                    while (iter.hasNext()) {</a>
<span class="sourceLineNo">1932</span><a id="line.1932">                        Entry&lt;String, Location&gt; subscription = iter.next();</a>
<span class="sourceLineNo">1933</span><a id="line.1933">                        int dataFileId = subscription.getValue().getDataFileId();</a>
<span class="sourceLineNo">1934</span><a id="line.1934"></a>
<span class="sourceLineNo">1935</span><a id="line.1935">                        // Move subscription along if it has no outstanding messages that need ack'd</a>
<span class="sourceLineNo">1936</span><a id="line.1936">                        // and its in the last log file in the journal.</a>
<span class="sourceLineNo">1937</span><a id="line.1937">                        if (!gcCandidateSet.isEmpty() &amp;&amp; gcCandidateSet.first() == dataFileId) {</a>
<span class="sourceLineNo">1938</span><a id="line.1938">                            final StoredDestination destination = entry.getValue();</a>
<span class="sourceLineNo">1939</span><a id="line.1939">                            final String subscriptionKey = subscription.getKey();</a>
<span class="sourceLineNo">1940</span><a id="line.1940">                            SequenceSet pendingAcks = destination.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">1941</span><a id="line.1941"></a>
<span class="sourceLineNo">1942</span><a id="line.1942">                            // When pending is size one that is the next message Id meaning there</a>
<span class="sourceLineNo">1943</span><a id="line.1943">                            // are no pending messages currently.</a>
<span class="sourceLineNo">1944</span><a id="line.1944">                            if (pendingAcks == null || pendingAcks.isEmpty() ||</a>
<span class="sourceLineNo">1945</span><a id="line.1945">                                (pendingAcks.size() == 1 &amp;&amp; pendingAcks.getTail().range() == 1)) {</a>
<span class="sourceLineNo">1946</span><a id="line.1946"></a>
<span class="sourceLineNo">1947</span><a id="line.1947">                                if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1948</span><a id="line.1948">                                    LOG.trace("Found candidate for rewrite: sub {} on {} from file {}", subscriptionKey, entry.getKey(), dataFileId);</a>
<span class="sourceLineNo">1949</span><a id="line.1949">                                }</a>
<span class="sourceLineNo">1950</span><a id="line.1950"></a>
<span class="sourceLineNo">1951</span><a id="line.1951">                                final KahaSubscriptionCommand kahaSub =</a>
<span class="sourceLineNo">1952</span><a id="line.1952">                                    destination.subscriptions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">1953</span><a id="line.1953">                                destination.subLocations.put(</a>
<span class="sourceLineNo">1954</span><a id="line.1954">                                    tx, subscriptionKey, checkpointSubscriptionCommand(kahaSub));</a>
<span class="sourceLineNo">1955</span><a id="line.1955"></a>
<span class="sourceLineNo">1956</span><a id="line.1956">                                // Skips the remove from candidates if we rewrote the subscription</a>
<span class="sourceLineNo">1957</span><a id="line.1957">                                // in order to prevent duplicate subscription commands on recover.</a>
<span class="sourceLineNo">1958</span><a id="line.1958">                                // If another subscription is on the same file and isn't rewritten</a>
<span class="sourceLineNo">1959</span><a id="line.1959">                                // than it will remove the file from the set.</a>
<span class="sourceLineNo">1960</span><a id="line.1960">                                continue;</a>
<span class="sourceLineNo">1961</span><a id="line.1961">                            }</a>
<span class="sourceLineNo">1962</span><a id="line.1962">                        }</a>
<span class="sourceLineNo">1963</span><a id="line.1963"></a>
<span class="sourceLineNo">1964</span><a id="line.1964">                        if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1965</span><a id="line.1965">                            final StoredDestination destination = entry.getValue();</a>
<span class="sourceLineNo">1966</span><a id="line.1966">                            final String subscriptionKey = subscription.getKey();</a>
<span class="sourceLineNo">1967</span><a id="line.1967">                            final SequenceSet pendingAcks = destination.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">1968</span><a id="line.1968">                            LOG.trace("sub {} on {} in dataFile {} has pendingCount {}", subscriptionKey, entry.getKey(), dataFileId, pendingAcks.rangeSize()-1);</a>
<span class="sourceLineNo">1969</span><a id="line.1969">                        }</a>
<span class="sourceLineNo">1970</span><a id="line.1970">                        gcCandidateSet.remove(dataFileId);</a>
<span class="sourceLineNo">1971</span><a id="line.1971">                    }</a>
<span class="sourceLineNo">1972</span><a id="line.1972">                }</a>
<span class="sourceLineNo">1973</span><a id="line.1973"></a>
<span class="sourceLineNo">1974</span><a id="line.1974">                if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1975</span><a id="line.1975">                    LOG.trace("gc candidates after dest:" + entry.getKey() + ", " + gcCandidateSet);</a>
<span class="sourceLineNo">1976</span><a id="line.1976">                }</a>
<span class="sourceLineNo">1977</span><a id="line.1977">            }</a>
<span class="sourceLineNo">1978</span><a id="line.1978"></a>
<span class="sourceLineNo">1979</span><a id="line.1979">            // check we are not deleting file with ack for in-use journal files</a>
<span class="sourceLineNo">1980</span><a id="line.1980">            if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">1981</span><a id="line.1981">                LOG.trace("gc candidates: " + gcCandidateSet);</a>
<span class="sourceLineNo">1982</span><a id="line.1982">                LOG.trace("ackMessageFileMap: " +  metadata.ackMessageFileMap);</a>
<span class="sourceLineNo">1983</span><a id="line.1983">            }</a>
<span class="sourceLineNo">1984</span><a id="line.1984"></a>
<span class="sourceLineNo">1985</span><a id="line.1985">            boolean ackMessageFileMapMod = false;</a>
<span class="sourceLineNo">1986</span><a id="line.1986">            Iterator&lt;Integer&gt; candidates = gcCandidateSet.iterator();</a>
<span class="sourceLineNo">1987</span><a id="line.1987">            while (candidates.hasNext()) {</a>
<span class="sourceLineNo">1988</span><a id="line.1988">                Integer candidate = candidates.next();</a>
<span class="sourceLineNo">1989</span><a id="line.1989">                Set&lt;Integer&gt; referencedFileIds = metadata.ackMessageFileMap.get(candidate);</a>
<span class="sourceLineNo">1990</span><a id="line.1990">                if (referencedFileIds != null) {</a>
<span class="sourceLineNo">1991</span><a id="line.1991">                    for (Integer referencedFileId : referencedFileIds) {</a>
<span class="sourceLineNo">1992</span><a id="line.1992">                        if (completeFileSet.contains(referencedFileId) &amp;&amp; !gcCandidateSet.contains(referencedFileId)) {</a>
<span class="sourceLineNo">1993</span><a id="line.1993">                            // active file that is not targeted for deletion is referenced so don't delete</a>
<span class="sourceLineNo">1994</span><a id="line.1994">                            candidates.remove();</a>
<span class="sourceLineNo">1995</span><a id="line.1995">                            break;</a>
<span class="sourceLineNo">1996</span><a id="line.1996">                        }</a>
<span class="sourceLineNo">1997</span><a id="line.1997">                    }</a>
<span class="sourceLineNo">1998</span><a id="line.1998">                    if (gcCandidateSet.contains(candidate)) {</a>
<span class="sourceLineNo">1999</span><a id="line.1999">                        ackMessageFileMapMod |= (metadata.ackMessageFileMap.remove(candidate) != null);</a>
<span class="sourceLineNo">2000</span><a id="line.2000">                        metadata.ackMessageFileMapDirtyFlag.lazySet(true);</a>
<span class="sourceLineNo">2001</span><a id="line.2001">                    } else {</a>
<span class="sourceLineNo">2002</span><a id="line.2002">                        if (LOG.isTraceEnabled()) {</a>
<span class="sourceLineNo">2003</span><a id="line.2003">                            LOG.trace("not removing data file: " + candidate</a>
<span class="sourceLineNo">2004</span><a id="line.2004">                                    + " as contained ack(s) refer to referenced file: " + referencedFileIds);</a>
<span class="sourceLineNo">2005</span><a id="line.2005">                        }</a>
<span class="sourceLineNo">2006</span><a id="line.2006">                    }</a>
<span class="sourceLineNo">2007</span><a id="line.2007">                }</a>
<span class="sourceLineNo">2008</span><a id="line.2008">            }</a>
<span class="sourceLineNo">2009</span><a id="line.2009"></a>
<span class="sourceLineNo">2010</span><a id="line.2010">            if (!gcCandidateSet.isEmpty()) {</a>
<span class="sourceLineNo">2011</span><a id="line.2011">                LOG.debug("Cleanup removing the data files: {}", gcCandidateSet);</a>
<span class="sourceLineNo">2012</span><a id="line.2012">                for (Integer candidate : gcCandidateSet) {</a>
<span class="sourceLineNo">2013</span><a id="line.2013">                    for (Set&lt;Integer&gt; ackFiles : metadata.ackMessageFileMap.values()) {</a>
<span class="sourceLineNo">2014</span><a id="line.2014">                        ackMessageFileMapMod |= ackFiles.remove(candidate);</a>
<span class="sourceLineNo">2015</span><a id="line.2015">                        metadata.ackMessageFileMapDirtyFlag.lazySet(true);</a>
<span class="sourceLineNo">2016</span><a id="line.2016">                    }</a>
<span class="sourceLineNo">2017</span><a id="line.2017">                }</a>
<span class="sourceLineNo">2018</span><a id="line.2018">                if (ackMessageFileMapMod) {</a>
<span class="sourceLineNo">2019</span><a id="line.2019">                    checkpointUpdate(tx, false);</a>
<span class="sourceLineNo">2020</span><a id="line.2020">                }</a>
<span class="sourceLineNo">2021</span><a id="line.2021">            } else if (isEnableAckCompaction()) {</a>
<span class="sourceLineNo">2022</span><a id="line.2022">                if (++checkPointCyclesWithNoGC &gt;= getCompactAcksAfterNoGC()) {</a>
<span class="sourceLineNo">2023</span><a id="line.2023">                    // First check length of journal to make sure it makes sense to even try.</a>
<span class="sourceLineNo">2024</span><a id="line.2024">                    //</a>
<span class="sourceLineNo">2025</span><a id="line.2025">                    // If there is only one journal file with Acks in it we don't need to move</a>
<span class="sourceLineNo">2026</span><a id="line.2026">                    // it since it won't be chained to any later logs.</a>
<span class="sourceLineNo">2027</span><a id="line.2027">                    //</a>
<span class="sourceLineNo">2028</span><a id="line.2028">                    // If the logs haven't grown since the last time then we need to compact</a>
<span class="sourceLineNo">2029</span><a id="line.2029">                    // otherwise there seems to still be room for growth and we don't need to incur</a>
<span class="sourceLineNo">2030</span><a id="line.2030">                    // the overhead.  Depending on configuration this check can be avoided and</a>
<span class="sourceLineNo">2031</span><a id="line.2031">                    // Ack compaction will run any time the store has not GC'd a journal file in</a>
<span class="sourceLineNo">2032</span><a id="line.2032">                    // the configured amount of cycles.</a>
<span class="sourceLineNo">2033</span><a id="line.2033">                    if (metadata.ackMessageFileMap.size() &gt; 1 &amp;&amp;</a>
<span class="sourceLineNo">2034</span><a id="line.2034">                        (journalLogOnLastCompactionCheck == journal.getCurrentDataFileId() || isCompactAcksIgnoresStoreGrowth())) {</a>
<span class="sourceLineNo">2035</span><a id="line.2035"></a>
<span class="sourceLineNo">2036</span><a id="line.2036">                        LOG.trace("No files GC'd checking if threshold to ACK compaction has been met.");</a>
<span class="sourceLineNo">2037</span><a id="line.2037">                        try {</a>
<span class="sourceLineNo">2038</span><a id="line.2038">                            scheduler.execute(new AckCompactionRunner());</a>
<span class="sourceLineNo">2039</span><a id="line.2039">                        } catch (Exception ex) {</a>
<span class="sourceLineNo">2040</span><a id="line.2040">                            LOG.warn("Error on queueing the Ack Compactor", ex);</a>
<span class="sourceLineNo">2041</span><a id="line.2041">                        }</a>
<span class="sourceLineNo">2042</span><a id="line.2042">                    } else {</a>
<span class="sourceLineNo">2043</span><a id="line.2043">                        LOG.trace("Journal activity detected, no Ack compaction scheduled.");</a>
<span class="sourceLineNo">2044</span><a id="line.2044">                    }</a>
<span class="sourceLineNo">2045</span><a id="line.2045"></a>
<span class="sourceLineNo">2046</span><a id="line.2046">                    checkPointCyclesWithNoGC = 0;</a>
<span class="sourceLineNo">2047</span><a id="line.2047">                } else {</a>
<span class="sourceLineNo">2048</span><a id="line.2048">                    LOG.trace("Not yet time to check for compaction: {} of {} cycles",</a>
<span class="sourceLineNo">2049</span><a id="line.2049">                              checkPointCyclesWithNoGC, getCompactAcksAfterNoGC());</a>
<span class="sourceLineNo">2050</span><a id="line.2050">                }</a>
<span class="sourceLineNo">2051</span><a id="line.2051"></a>
<span class="sourceLineNo">2052</span><a id="line.2052">                journalLogOnLastCompactionCheck = journal.getCurrentDataFileId();</a>
<span class="sourceLineNo">2053</span><a id="line.2053">            }</a>
<span class="sourceLineNo">2054</span><a id="line.2054">        }</a>
<span class="sourceLineNo">2055</span><a id="line.2055">        MDC.remove("activemq.persistenceDir");</a>
<span class="sourceLineNo">2056</span><a id="line.2056"></a>
<span class="sourceLineNo">2057</span><a id="line.2057">        LOG.debug("Checkpoint done.");</a>
<span class="sourceLineNo">2058</span><a id="line.2058">        return gcCandidateSet;</a>
<span class="sourceLineNo">2059</span><a id="line.2059">    }</a>
<span class="sourceLineNo">2060</span><a id="line.2060"></a>
<span class="sourceLineNo">2061</span><a id="line.2061">    private final class AckCompactionRunner implements Runnable {</a>
<span class="sourceLineNo">2062</span><a id="line.2062"></a>
<span class="sourceLineNo">2063</span><a id="line.2063">        @Override</a>
<span class="sourceLineNo">2064</span><a id="line.2064">        public void run() {</a>
<span class="sourceLineNo">2065</span><a id="line.2065"></a>
<span class="sourceLineNo">2066</span><a id="line.2066">            int journalToAdvance = -1;</a>
<span class="sourceLineNo">2067</span><a id="line.2067">            Set&lt;Integer&gt; journalLogsReferenced = new HashSet&lt;&gt;();</a>
<span class="sourceLineNo">2068</span><a id="line.2068"></a>
<span class="sourceLineNo">2069</span><a id="line.2069">            //flag to know whether the ack forwarding completed without an exception</a>
<span class="sourceLineNo">2070</span><a id="line.2070">            boolean forwarded = false;</a>
<span class="sourceLineNo">2071</span><a id="line.2071"></a>
<span class="sourceLineNo">2072</span><a id="line.2072">            try {</a>
<span class="sourceLineNo">2073</span><a id="line.2073">                //acquire the checkpoint lock to prevent other threads from</a>
<span class="sourceLineNo">2074</span><a id="line.2074">                //running a checkpoint while this is running</a>
<span class="sourceLineNo">2075</span><a id="line.2075">                //</a>
<span class="sourceLineNo">2076</span><a id="line.2076">                //Normally this task runs on the same executor as the checkpoint task</a>
<span class="sourceLineNo">2077</span><a id="line.2077">                //so this ack compaction runner wouldn't run at the same time as the checkpoint task.</a>
<span class="sourceLineNo">2078</span><a id="line.2078">                //</a>
<span class="sourceLineNo">2079</span><a id="line.2079">                //However, there are two cases where this isn't always true.</a>
<span class="sourceLineNo">2080</span><a id="line.2080">                //First, the checkpoint() method is public and can be called through the</a>
<span class="sourceLineNo">2081</span><a id="line.2081">                //PersistenceAdapter interface by someone at the same time this is running.</a>
<span class="sourceLineNo">2082</span><a id="line.2082">                //Second, a checkpoint is called during shutdown without using the executor.</a>
<span class="sourceLineNo">2083</span><a id="line.2083">                //</a>
<span class="sourceLineNo">2084</span><a id="line.2084">                //In the future it might be better to just remove the checkpointLock entirely</a>
<span class="sourceLineNo">2085</span><a id="line.2085">                //and only use the executor but this would need to be examined for any unintended</a>
<span class="sourceLineNo">2086</span><a id="line.2086">                //consequences</a>
<span class="sourceLineNo">2087</span><a id="line.2087">                checkpointLock.readLock().lock();</a>
<span class="sourceLineNo">2088</span><a id="line.2088"></a>
<span class="sourceLineNo">2089</span><a id="line.2089">                try {</a>
<span class="sourceLineNo">2090</span><a id="line.2090"></a>
<span class="sourceLineNo">2091</span><a id="line.2091">                    // Lock index to capture the ackMessageFileMap data</a>
<span class="sourceLineNo">2092</span><a id="line.2092">                    indexLock.writeLock().lock();</a>
<span class="sourceLineNo">2093</span><a id="line.2093"></a>
<span class="sourceLineNo">2094</span><a id="line.2094">                    // Map keys might not be sorted, find the earliest log file to forward acks</a>
<span class="sourceLineNo">2095</span><a id="line.2095">                    // from and move only those, future cycles can chip away at more as needed.</a>
<span class="sourceLineNo">2096</span><a id="line.2096">                    // We won't move files that are themselves rewritten on a previous compaction.</a>
<span class="sourceLineNo">2097</span><a id="line.2097">                    List&lt;Integer&gt; journalFileIds = new ArrayList&lt;&gt;(metadata.ackMessageFileMap.keySet());</a>
<span class="sourceLineNo">2098</span><a id="line.2098">                    Collections.sort(journalFileIds);</a>
<span class="sourceLineNo">2099</span><a id="line.2099">                    for (Integer journalFileId : journalFileIds) {</a>
<span class="sourceLineNo">2100</span><a id="line.2100">                        DataFile current = journal.getDataFileById(journalFileId);</a>
<span class="sourceLineNo">2101</span><a id="line.2101">                        if (current != null &amp;&amp; current.getTypeCode() != COMPACTED_JOURNAL_FILE) {</a>
<span class="sourceLineNo">2102</span><a id="line.2102">                            journalToAdvance = journalFileId;</a>
<span class="sourceLineNo">2103</span><a id="line.2103">                            break;</a>
<span class="sourceLineNo">2104</span><a id="line.2104">                        }</a>
<span class="sourceLineNo">2105</span><a id="line.2105">                    }</a>
<span class="sourceLineNo">2106</span><a id="line.2106"></a>
<span class="sourceLineNo">2107</span><a id="line.2107">                    // Check if we found one, or if we only found the current file being written to.</a>
<span class="sourceLineNo">2108</span><a id="line.2108">                    if (journalToAdvance == -1 || blockedFromCompaction(journalToAdvance)) {</a>
<span class="sourceLineNo">2109</span><a id="line.2109">                        return;</a>
<span class="sourceLineNo">2110</span><a id="line.2110">                    }</a>
<span class="sourceLineNo">2111</span><a id="line.2111"></a>
<span class="sourceLineNo">2112</span><a id="line.2112">                    journalLogsReferenced.addAll(metadata.ackMessageFileMap.get(journalToAdvance));</a>
<span class="sourceLineNo">2113</span><a id="line.2113"></a>
<span class="sourceLineNo">2114</span><a id="line.2114">                } finally {</a>
<span class="sourceLineNo">2115</span><a id="line.2115">                    indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">2116</span><a id="line.2116">                }</a>
<span class="sourceLineNo">2117</span><a id="line.2117"></a>
<span class="sourceLineNo">2118</span><a id="line.2118">                try {</a>
<span class="sourceLineNo">2119</span><a id="line.2119">                    // Background rewrite of the old acks</a>
<span class="sourceLineNo">2120</span><a id="line.2120">                    forwardAllAcks(journalToAdvance, journalLogsReferenced);</a>
<span class="sourceLineNo">2121</span><a id="line.2121">                    forwarded = true;</a>
<span class="sourceLineNo">2122</span><a id="line.2122">                } catch (IOException ioe) {</a>
<span class="sourceLineNo">2123</span><a id="line.2123">                    LOG.error("Forwarding of acks failed", ioe);</a>
<span class="sourceLineNo">2124</span><a id="line.2124">                    brokerService.handleIOException(ioe);</a>
<span class="sourceLineNo">2125</span><a id="line.2125">                } catch (Throwable e) {</a>
<span class="sourceLineNo">2126</span><a id="line.2126">                    LOG.error("Forwarding of acks failed", e);</a>
<span class="sourceLineNo">2127</span><a id="line.2127">                    brokerService.handleIOException(IOExceptionSupport.create(e));</a>
<span class="sourceLineNo">2128</span><a id="line.2128">                }</a>
<span class="sourceLineNo">2129</span><a id="line.2129">            } finally {</a>
<span class="sourceLineNo">2130</span><a id="line.2130">                checkpointLock.readLock().unlock();</a>
<span class="sourceLineNo">2131</span><a id="line.2131">            }</a>
<span class="sourceLineNo">2132</span><a id="line.2132"></a>
<span class="sourceLineNo">2133</span><a id="line.2133">            try {</a>
<span class="sourceLineNo">2134</span><a id="line.2134">                if (forwarded) {</a>
<span class="sourceLineNo">2135</span><a id="line.2135">                    // Checkpoint with changes from the ackMessageFileMap</a>
<span class="sourceLineNo">2136</span><a id="line.2136">                    checkpointUpdate(false);</a>
<span class="sourceLineNo">2137</span><a id="line.2137">                }</a>
<span class="sourceLineNo">2138</span><a id="line.2138">            } catch (IOException ioe) {</a>
<span class="sourceLineNo">2139</span><a id="line.2139">                LOG.error("Checkpoint failed", ioe);</a>
<span class="sourceLineNo">2140</span><a id="line.2140">                brokerService.handleIOException(ioe);</a>
<span class="sourceLineNo">2141</span><a id="line.2141">            } catch (Throwable e) {</a>
<span class="sourceLineNo">2142</span><a id="line.2142">                LOG.error("Checkpoint failed", e);</a>
<span class="sourceLineNo">2143</span><a id="line.2143">                brokerService.handleIOException(IOExceptionSupport.create(e));</a>
<span class="sourceLineNo">2144</span><a id="line.2144">            }</a>
<span class="sourceLineNo">2145</span><a id="line.2145">        }</a>
<span class="sourceLineNo">2146</span><a id="line.2146">    }</a>
<span class="sourceLineNo">2147</span><a id="line.2147"></a>
<span class="sourceLineNo">2148</span><a id="line.2148">    // called with the index lock held</a>
<span class="sourceLineNo">2149</span><a id="line.2149">    private boolean blockedFromCompaction(int journalToAdvance) {</a>
<span class="sourceLineNo">2150</span><a id="line.2150">        // don't forward the current data file</a>
<span class="sourceLineNo">2151</span><a id="line.2151">        if (journalToAdvance == journal.getCurrentDataFileId()) {</a>
<span class="sourceLineNo">2152</span><a id="line.2152">            return true;</a>
<span class="sourceLineNo">2153</span><a id="line.2153">        }</a>
<span class="sourceLineNo">2154</span><a id="line.2154">        // don't forward any data file with inflight transaction records because it will whack the tx - data file link</a>
<span class="sourceLineNo">2155</span><a id="line.2155">        // in the ack map when all acks are migrated (now that the ack map is not just for acks)</a>
<span class="sourceLineNo">2156</span><a id="line.2156">        // TODO: prepare records can be dropped but completion records (maybe only commit outcomes) need to be migrated</a>
<span class="sourceLineNo">2157</span><a id="line.2157">        // as part of the forward work.</a>
<span class="sourceLineNo">2158</span><a id="line.2158">        Location[] inProgressTxRange = getInProgressTxLocationRange();</a>
<span class="sourceLineNo">2159</span><a id="line.2159">        if (inProgressTxRange[0] != null) {</a>
<span class="sourceLineNo">2160</span><a id="line.2160">            for (int pendingTx = inProgressTxRange[0].getDataFileId(); pendingTx &lt;= inProgressTxRange[1].getDataFileId(); pendingTx++) {</a>
<span class="sourceLineNo">2161</span><a id="line.2161">                if (journalToAdvance == pendingTx) {</a>
<span class="sourceLineNo">2162</span><a id="line.2162">                    LOG.trace("Compaction target:{} blocked by inflight transaction records: {}", journalToAdvance, inProgressTxRange);</a>
<span class="sourceLineNo">2163</span><a id="line.2163">                    return true;</a>
<span class="sourceLineNo">2164</span><a id="line.2164">                }</a>
<span class="sourceLineNo">2165</span><a id="line.2165">            }</a>
<span class="sourceLineNo">2166</span><a id="line.2166">        }</a>
<span class="sourceLineNo">2167</span><a id="line.2167">        return false;</a>
<span class="sourceLineNo">2168</span><a id="line.2168">    }</a>
<span class="sourceLineNo">2169</span><a id="line.2169"></a>
<span class="sourceLineNo">2170</span><a id="line.2170">    private void forwardAllAcks(Integer journalToRead, Set&lt;Integer&gt; journalLogsReferenced) throws IllegalStateException, IOException {</a>
<span class="sourceLineNo">2171</span><a id="line.2171">        LOG.trace("Attempting to move all acks in journal:{} to the front. Referenced files:{}", journalToRead, journalLogsReferenced);</a>
<span class="sourceLineNo">2172</span><a id="line.2172"></a>
<span class="sourceLineNo">2173</span><a id="line.2173">        DataFile forwardsFile = journal.reserveDataFile();</a>
<span class="sourceLineNo">2174</span><a id="line.2174">        forwardsFile.setTypeCode(COMPACTED_JOURNAL_FILE);</a>
<span class="sourceLineNo">2175</span><a id="line.2175">        LOG.trace("Reserved file for forwarded acks: {}", forwardsFile);</a>
<span class="sourceLineNo">2176</span><a id="line.2176"></a>
<span class="sourceLineNo">2177</span><a id="line.2177">        Map&lt;Integer, Set&lt;Integer&gt;&gt; updatedAckLocations = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">2178</span><a id="line.2178"></a>
<span class="sourceLineNo">2179</span><a id="line.2179">        try (TargetedDataFileAppender appender = new TargetedDataFileAppender(journal, forwardsFile);) {</a>
<span class="sourceLineNo">2180</span><a id="line.2180">            KahaRewrittenDataFileCommand compactionMarker = new KahaRewrittenDataFileCommand();</a>
<span class="sourceLineNo">2181</span><a id="line.2181">            compactionMarker.setSourceDataFileId(journalToRead);</a>
<span class="sourceLineNo">2182</span><a id="line.2182">            compactionMarker.setRewriteType(forwardsFile.getTypeCode());</a>
<span class="sourceLineNo">2183</span><a id="line.2183"></a>
<span class="sourceLineNo">2184</span><a id="line.2184">            ByteSequence payload = toByteSequence(compactionMarker);</a>
<span class="sourceLineNo">2185</span><a id="line.2185">            appender.storeItem(payload, Journal.USER_RECORD_TYPE, false);</a>
<span class="sourceLineNo">2186</span><a id="line.2186">            LOG.trace("Marked ack rewrites file as replacing file: {}", journalToRead);</a>
<span class="sourceLineNo">2187</span><a id="line.2187"></a>
<span class="sourceLineNo">2188</span><a id="line.2188">            final Location limit = new Location(journalToRead + 1, 0);</a>
<span class="sourceLineNo">2189</span><a id="line.2189">            Location nextLocation = getNextLocationForAckForward(new Location(journalToRead, 0), limit);</a>
<span class="sourceLineNo">2190</span><a id="line.2190">            while (nextLocation != null) {</a>
<span class="sourceLineNo">2191</span><a id="line.2191">                JournalCommand&lt;?&gt; command = null;</a>
<span class="sourceLineNo">2192</span><a id="line.2192">                try {</a>
<span class="sourceLineNo">2193</span><a id="line.2193">                    command = load(nextLocation);</a>
<span class="sourceLineNo">2194</span><a id="line.2194">                } catch (IOException ex) {</a>
<span class="sourceLineNo">2195</span><a id="line.2195">                    LOG.trace("Error loading command during ack forward: {}", nextLocation);</a>
<span class="sourceLineNo">2196</span><a id="line.2196">                }</a>
<span class="sourceLineNo">2197</span><a id="line.2197"></a>
<span class="sourceLineNo">2198</span><a id="line.2198">                if (shouldForward(command)) {</a>
<span class="sourceLineNo">2199</span><a id="line.2199">                    payload = toByteSequence(command);</a>
<span class="sourceLineNo">2200</span><a id="line.2200">                    Location location = appender.storeItem(payload, Journal.USER_RECORD_TYPE, false);</a>
<span class="sourceLineNo">2201</span><a id="line.2201">                    updatedAckLocations.put(location.getDataFileId(), journalLogsReferenced);</a>
<span class="sourceLineNo">2202</span><a id="line.2202">                }</a>
<span class="sourceLineNo">2203</span><a id="line.2203"></a>
<span class="sourceLineNo">2204</span><a id="line.2204">                nextLocation = getNextLocationForAckForward(nextLocation, limit);</a>
<span class="sourceLineNo">2205</span><a id="line.2205">            }</a>
<span class="sourceLineNo">2206</span><a id="line.2206">        }</a>
<span class="sourceLineNo">2207</span><a id="line.2207"></a>
<span class="sourceLineNo">2208</span><a id="line.2208">        LOG.trace("ACKS forwarded, updates for ack locations: {}", updatedAckLocations);</a>
<span class="sourceLineNo">2209</span><a id="line.2209"></a>
<span class="sourceLineNo">2210</span><a id="line.2210">        // Lock index while we update the ackMessageFileMap.</a>
<span class="sourceLineNo">2211</span><a id="line.2211">        indexLock.writeLock().lock();</a>
<span class="sourceLineNo">2212</span><a id="line.2212"></a>
<span class="sourceLineNo">2213</span><a id="line.2213">        // Update the ack map with the new locations of the acks</a>
<span class="sourceLineNo">2214</span><a id="line.2214">        for (Entry&lt;Integer, Set&lt;Integer&gt;&gt; entry : updatedAckLocations.entrySet()) {</a>
<span class="sourceLineNo">2215</span><a id="line.2215">            Set&lt;Integer&gt; referenceFileIds = metadata.ackMessageFileMap.get(entry.getKey());</a>
<span class="sourceLineNo">2216</span><a id="line.2216">            if (referenceFileIds == null) {</a>
<span class="sourceLineNo">2217</span><a id="line.2217">                referenceFileIds = new HashSet&lt;&gt;();</a>
<span class="sourceLineNo">2218</span><a id="line.2218">                referenceFileIds.addAll(entry.getValue());</a>
<span class="sourceLineNo">2219</span><a id="line.2219">                metadata.ackMessageFileMap.put(entry.getKey(), referenceFileIds);</a>
<span class="sourceLineNo">2220</span><a id="line.2220">                metadata.ackMessageFileMapDirtyFlag.lazySet(true);</a>
<span class="sourceLineNo">2221</span><a id="line.2221">            } else {</a>
<span class="sourceLineNo">2222</span><a id="line.2222">                referenceFileIds.addAll(entry.getValue());</a>
<span class="sourceLineNo">2223</span><a id="line.2223">            }</a>
<span class="sourceLineNo">2224</span><a id="line.2224">        }</a>
<span class="sourceLineNo">2225</span><a id="line.2225"></a>
<span class="sourceLineNo">2226</span><a id="line.2226">        // remove the old location data from the ack map so that the old journal log file can</a>
<span class="sourceLineNo">2227</span><a id="line.2227">        // be removed on next GC.</a>
<span class="sourceLineNo">2228</span><a id="line.2228">        metadata.ackMessageFileMap.remove(journalToRead);</a>
<span class="sourceLineNo">2229</span><a id="line.2229">        metadata.ackMessageFileMapDirtyFlag.lazySet(true);</a>
<span class="sourceLineNo">2230</span><a id="line.2230"></a>
<span class="sourceLineNo">2231</span><a id="line.2231">        indexLock.writeLock().unlock();</a>
<span class="sourceLineNo">2232</span><a id="line.2232"></a>
<span class="sourceLineNo">2233</span><a id="line.2233">        LOG.trace("ACK File Map following updates: {}", metadata.ackMessageFileMap);</a>
<span class="sourceLineNo">2234</span><a id="line.2234">    }</a>
<span class="sourceLineNo">2235</span><a id="line.2235"></a>
<span class="sourceLineNo">2236</span><a id="line.2236">    private boolean shouldForward(JournalCommand&lt;?&gt; command) {</a>
<span class="sourceLineNo">2237</span><a id="line.2237">        if (command == null) {</a>
<span class="sourceLineNo">2238</span><a id="line.2238">            return false;</a>
<span class="sourceLineNo">2239</span><a id="line.2239">        }</a>
<span class="sourceLineNo">2240</span><a id="line.2240"></a>
<span class="sourceLineNo">2241</span><a id="line.2241">        return (command instanceof KahaRemoveMessageCommand || command instanceof KahaCommitCommand);</a>
<span class="sourceLineNo">2242</span><a id="line.2242">    }</a>
<span class="sourceLineNo">2243</span><a id="line.2243"></a>
<span class="sourceLineNo">2244</span><a id="line.2244">    private Location getNextLocationForAckForward(final Location nextLocation, final Location limit) {</a>
<span class="sourceLineNo">2245</span><a id="line.2245">        //getNextLocation() can throw an IOException, we should handle it and set</a>
<span class="sourceLineNo">2246</span><a id="line.2246">        //nextLocation to null and abort gracefully</a>
<span class="sourceLineNo">2247</span><a id="line.2247">        //Should not happen in the normal case</a>
<span class="sourceLineNo">2248</span><a id="line.2248">        Location location = null;</a>
<span class="sourceLineNo">2249</span><a id="line.2249">        try {</a>
<span class="sourceLineNo">2250</span><a id="line.2250">            location = journal.getNextLocation(nextLocation, limit);</a>
<span class="sourceLineNo">2251</span><a id="line.2251">        } catch (IOException e) {</a>
<span class="sourceLineNo">2252</span><a id="line.2252">            LOG.warn("Failed to load next journal location after: {}, reason: {}", nextLocation, e);</a>
<span class="sourceLineNo">2253</span><a id="line.2253">            if (LOG.isDebugEnabled()) {</a>
<span class="sourceLineNo">2254</span><a id="line.2254">                LOG.debug("Failed to load next journal location after: {}", nextLocation, e);</a>
<span class="sourceLineNo">2255</span><a id="line.2255">            }</a>
<span class="sourceLineNo">2256</span><a id="line.2256">        }</a>
<span class="sourceLineNo">2257</span><a id="line.2257">        return location;</a>
<span class="sourceLineNo">2258</span><a id="line.2258">    }</a>
<span class="sourceLineNo">2259</span><a id="line.2259"></a>
<span class="sourceLineNo">2260</span><a id="line.2260">    final Runnable nullCompletionCallback = new Runnable() {</a>
<span class="sourceLineNo">2261</span><a id="line.2261">        @Override</a>
<span class="sourceLineNo">2262</span><a id="line.2262">        public void run() {</a>
<span class="sourceLineNo">2263</span><a id="line.2263">        }</a>
<span class="sourceLineNo">2264</span><a id="line.2264">    };</a>
<span class="sourceLineNo">2265</span><a id="line.2265"></a>
<span class="sourceLineNo">2266</span><a id="line.2266">    private Location checkpointProducerAudit() throws IOException {</a>
<span class="sourceLineNo">2267</span><a id="line.2267">        if (metadata.producerSequenceIdTracker == null || metadata.producerSequenceIdTracker.modified()) {</a>
<span class="sourceLineNo">2268</span><a id="line.2268">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</a>
<span class="sourceLineNo">2269</span><a id="line.2269">            ObjectOutputStream oout = new ObjectOutputStream(baos);</a>
<span class="sourceLineNo">2270</span><a id="line.2270">            oout.writeObject(metadata.producerSequenceIdTracker);</a>
<span class="sourceLineNo">2271</span><a id="line.2271">            oout.flush();</a>
<span class="sourceLineNo">2272</span><a id="line.2272">            oout.close();</a>
<span class="sourceLineNo">2273</span><a id="line.2273">            // using completion callback allows a disk sync to be avoided when enableJournalDiskSyncs = false</a>
<span class="sourceLineNo">2274</span><a id="line.2274">            Location location = store(new KahaProducerAuditCommand().setAudit(new Buffer(baos.toByteArray())), nullCompletionCallback);</a>
<span class="sourceLineNo">2275</span><a id="line.2275">            try {</a>
<span class="sourceLineNo">2276</span><a id="line.2276">                location.getLatch().await();</a>
<span class="sourceLineNo">2277</span><a id="line.2277">                if (location.getException().get() != null) {</a>
<span class="sourceLineNo">2278</span><a id="line.2278">                    throw location.getException().get();</a>
<span class="sourceLineNo">2279</span><a id="line.2279">                }</a>
<span class="sourceLineNo">2280</span><a id="line.2280">            } catch (InterruptedException e) {</a>
<span class="sourceLineNo">2281</span><a id="line.2281">                throw new InterruptedIOException(e.toString());</a>
<span class="sourceLineNo">2282</span><a id="line.2282">            }</a>
<span class="sourceLineNo">2283</span><a id="line.2283">            return location;</a>
<span class="sourceLineNo">2284</span><a id="line.2284">        }</a>
<span class="sourceLineNo">2285</span><a id="line.2285">        return metadata.producerSequenceIdTrackerLocation;</a>
<span class="sourceLineNo">2286</span><a id="line.2286">    }</a>
<span class="sourceLineNo">2287</span><a id="line.2287"></a>
<span class="sourceLineNo">2288</span><a id="line.2288">    private Location checkpointAckMessageFileMap() throws IOException {</a>
<span class="sourceLineNo">2289</span><a id="line.2289">        ByteArrayOutputStream baos = new ByteArrayOutputStream();</a>
<span class="sourceLineNo">2290</span><a id="line.2290">        ObjectOutputStream oout = new ObjectOutputStream(baos);</a>
<span class="sourceLineNo">2291</span><a id="line.2291">        oout.writeObject(metadata.ackMessageFileMap);</a>
<span class="sourceLineNo">2292</span><a id="line.2292">        oout.flush();</a>
<span class="sourceLineNo">2293</span><a id="line.2293">        oout.close();</a>
<span class="sourceLineNo">2294</span><a id="line.2294">        // using completion callback allows a disk sync to be avoided when enableJournalDiskSyncs = false</a>
<span class="sourceLineNo">2295</span><a id="line.2295">        Location location = store(new KahaAckMessageFileMapCommand().setAckMessageFileMap(new Buffer(baos.toByteArray())), nullCompletionCallback);</a>
<span class="sourceLineNo">2296</span><a id="line.2296">        try {</a>
<span class="sourceLineNo">2297</span><a id="line.2297">            location.getLatch().await();</a>
<span class="sourceLineNo">2298</span><a id="line.2298">        } catch (InterruptedException e) {</a>
<span class="sourceLineNo">2299</span><a id="line.2299">            throw new InterruptedIOException(e.toString());</a>
<span class="sourceLineNo">2300</span><a id="line.2300">        }</a>
<span class="sourceLineNo">2301</span><a id="line.2301">        return location;</a>
<span class="sourceLineNo">2302</span><a id="line.2302">    }</a>
<span class="sourceLineNo">2303</span><a id="line.2303"></a>
<span class="sourceLineNo">2304</span><a id="line.2304">    private Location checkpointSubscriptionCommand(KahaSubscriptionCommand subscription) throws IOException {</a>
<span class="sourceLineNo">2305</span><a id="line.2305"></a>
<span class="sourceLineNo">2306</span><a id="line.2306">        ByteSequence sequence = toByteSequence(subscription);</a>
<span class="sourceLineNo">2307</span><a id="line.2307">        Location location = journal.write(sequence, nullCompletionCallback) ;</a>
<span class="sourceLineNo">2308</span><a id="line.2308"></a>
<span class="sourceLineNo">2309</span><a id="line.2309">        try {</a>
<span class="sourceLineNo">2310</span><a id="line.2310">            location.getLatch().await();</a>
<span class="sourceLineNo">2311</span><a id="line.2311">        } catch (InterruptedException e) {</a>
<span class="sourceLineNo">2312</span><a id="line.2312">            throw new InterruptedIOException(e.toString());</a>
<span class="sourceLineNo">2313</span><a id="line.2313">        }</a>
<span class="sourceLineNo">2314</span><a id="line.2314">        return location;</a>
<span class="sourceLineNo">2315</span><a id="line.2315">    }</a>
<span class="sourceLineNo">2316</span><a id="line.2316"></a>
<span class="sourceLineNo">2317</span><a id="line.2317">    public HashSet&lt;Integer&gt; getJournalFilesBeingReplicated() {</a>
<span class="sourceLineNo">2318</span><a id="line.2318">        return journalFilesBeingReplicated;</a>
<span class="sourceLineNo">2319</span><a id="line.2319">    }</a>
<span class="sourceLineNo">2320</span><a id="line.2320"></a>
<span class="sourceLineNo">2321</span><a id="line.2321">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">2322</span><a id="line.2322">    // StoredDestination related implementation methods.</a>
<span class="sourceLineNo">2323</span><a id="line.2323">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">2324</span><a id="line.2324"></a>
<span class="sourceLineNo">2325</span><a id="line.2325">    protected final HashMap&lt;String, StoredDestination&gt; storedDestinations = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">2326</span><a id="line.2326"></a>
<span class="sourceLineNo">2327</span><a id="line.2327">    static class MessageKeys {</a>
<span class="sourceLineNo">2328</span><a id="line.2328">        final String messageId;</a>
<span class="sourceLineNo">2329</span><a id="line.2329">        final Location location;</a>
<span class="sourceLineNo">2330</span><a id="line.2330"></a>
<span class="sourceLineNo">2331</span><a id="line.2331">        public MessageKeys(String messageId, Location location) {</a>
<span class="sourceLineNo">2332</span><a id="line.2332">            this.messageId=messageId;</a>
<span class="sourceLineNo">2333</span><a id="line.2333">            this.location=location;</a>
<span class="sourceLineNo">2334</span><a id="line.2334">        }</a>
<span class="sourceLineNo">2335</span><a id="line.2335"></a>
<span class="sourceLineNo">2336</span><a id="line.2336">        @Override</a>
<span class="sourceLineNo">2337</span><a id="line.2337">        public String toString() {</a>
<span class="sourceLineNo">2338</span><a id="line.2338">            return "["+messageId+","+location+"]";</a>
<span class="sourceLineNo">2339</span><a id="line.2339">        }</a>
<span class="sourceLineNo">2340</span><a id="line.2340">    }</a>
<span class="sourceLineNo">2341</span><a id="line.2341"></a>
<span class="sourceLineNo">2342</span><a id="line.2342">    protected class MessageKeysMarshaller extends VariableMarshaller&lt;MessageKeys&gt; {</a>
<span class="sourceLineNo">2343</span><a id="line.2343">        final LocationSizeMarshaller locationSizeMarshaller = new LocationSizeMarshaller();</a>
<span class="sourceLineNo">2344</span><a id="line.2344"></a>
<span class="sourceLineNo">2345</span><a id="line.2345">        @Override</a>
<span class="sourceLineNo">2346</span><a id="line.2346">        public MessageKeys readPayload(DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">2347</span><a id="line.2347">            return new MessageKeys(dataIn.readUTF(), locationSizeMarshaller.readPayload(dataIn));</a>
<span class="sourceLineNo">2348</span><a id="line.2348">        }</a>
<span class="sourceLineNo">2349</span><a id="line.2349"></a>
<span class="sourceLineNo">2350</span><a id="line.2350">        @Override</a>
<span class="sourceLineNo">2351</span><a id="line.2351">        public void writePayload(MessageKeys object, DataOutput dataOut) throws IOException {</a>
<span class="sourceLineNo">2352</span><a id="line.2352">            dataOut.writeUTF(object.messageId);</a>
<span class="sourceLineNo">2353</span><a id="line.2353">            locationSizeMarshaller.writePayload(object.location, dataOut);</a>
<span class="sourceLineNo">2354</span><a id="line.2354">        }</a>
<span class="sourceLineNo">2355</span><a id="line.2355">    }</a>
<span class="sourceLineNo">2356</span><a id="line.2356"></a>
<span class="sourceLineNo">2357</span><a id="line.2357">    class LastAck {</a>
<span class="sourceLineNo">2358</span><a id="line.2358">        long lastAckedSequence;</a>
<span class="sourceLineNo">2359</span><a id="line.2359">        byte priority;</a>
<span class="sourceLineNo">2360</span><a id="line.2360"></a>
<span class="sourceLineNo">2361</span><a id="line.2361">        public LastAck(LastAck source) {</a>
<span class="sourceLineNo">2362</span><a id="line.2362">            this.lastAckedSequence = source.lastAckedSequence;</a>
<span class="sourceLineNo">2363</span><a id="line.2363">            this.priority = source.priority;</a>
<span class="sourceLineNo">2364</span><a id="line.2364">        }</a>
<span class="sourceLineNo">2365</span><a id="line.2365"></a>
<span class="sourceLineNo">2366</span><a id="line.2366">        public LastAck() {</a>
<span class="sourceLineNo">2367</span><a id="line.2367">            this.priority = MessageOrderIndex.HI;</a>
<span class="sourceLineNo">2368</span><a id="line.2368">        }</a>
<span class="sourceLineNo">2369</span><a id="line.2369"></a>
<span class="sourceLineNo">2370</span><a id="line.2370">        public LastAck(long ackLocation) {</a>
<span class="sourceLineNo">2371</span><a id="line.2371">            this.lastAckedSequence = ackLocation;</a>
<span class="sourceLineNo">2372</span><a id="line.2372">            this.priority = MessageOrderIndex.LO;</a>
<span class="sourceLineNo">2373</span><a id="line.2373">        }</a>
<span class="sourceLineNo">2374</span><a id="line.2374"></a>
<span class="sourceLineNo">2375</span><a id="line.2375">        public LastAck(long ackLocation, byte priority) {</a>
<span class="sourceLineNo">2376</span><a id="line.2376">            this.lastAckedSequence = ackLocation;</a>
<span class="sourceLineNo">2377</span><a id="line.2377">            this.priority = priority;</a>
<span class="sourceLineNo">2378</span><a id="line.2378">        }</a>
<span class="sourceLineNo">2379</span><a id="line.2379"></a>
<span class="sourceLineNo">2380</span><a id="line.2380">        @Override</a>
<span class="sourceLineNo">2381</span><a id="line.2381">        public String toString() {</a>
<span class="sourceLineNo">2382</span><a id="line.2382">            return "[" + lastAckedSequence + ":" + priority + "]";</a>
<span class="sourceLineNo">2383</span><a id="line.2383">        }</a>
<span class="sourceLineNo">2384</span><a id="line.2384">    }</a>
<span class="sourceLineNo">2385</span><a id="line.2385"></a>
<span class="sourceLineNo">2386</span><a id="line.2386">    protected class LastAckMarshaller implements Marshaller&lt;LastAck&gt; {</a>
<span class="sourceLineNo">2387</span><a id="line.2387"></a>
<span class="sourceLineNo">2388</span><a id="line.2388">        @Override</a>
<span class="sourceLineNo">2389</span><a id="line.2389">        public void writePayload(LastAck object, DataOutput dataOut) throws IOException {</a>
<span class="sourceLineNo">2390</span><a id="line.2390">            dataOut.writeLong(object.lastAckedSequence);</a>
<span class="sourceLineNo">2391</span><a id="line.2391">            dataOut.writeByte(object.priority);</a>
<span class="sourceLineNo">2392</span><a id="line.2392">        }</a>
<span class="sourceLineNo">2393</span><a id="line.2393"></a>
<span class="sourceLineNo">2394</span><a id="line.2394">        @Override</a>
<span class="sourceLineNo">2395</span><a id="line.2395">        public LastAck readPayload(DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">2396</span><a id="line.2396">            LastAck lastAcked = new LastAck();</a>
<span class="sourceLineNo">2397</span><a id="line.2397">            lastAcked.lastAckedSequence = dataIn.readLong();</a>
<span class="sourceLineNo">2398</span><a id="line.2398">            if (metadata.version &gt;= 3) {</a>
<span class="sourceLineNo">2399</span><a id="line.2399">                lastAcked.priority = dataIn.readByte();</a>
<span class="sourceLineNo">2400</span><a id="line.2400">            }</a>
<span class="sourceLineNo">2401</span><a id="line.2401">            return lastAcked;</a>
<span class="sourceLineNo">2402</span><a id="line.2402">        }</a>
<span class="sourceLineNo">2403</span><a id="line.2403"></a>
<span class="sourceLineNo">2404</span><a id="line.2404">        @Override</a>
<span class="sourceLineNo">2405</span><a id="line.2405">        public int getFixedSize() {</a>
<span class="sourceLineNo">2406</span><a id="line.2406">            return 9;</a>
<span class="sourceLineNo">2407</span><a id="line.2407">        }</a>
<span class="sourceLineNo">2408</span><a id="line.2408"></a>
<span class="sourceLineNo">2409</span><a id="line.2409">        @Override</a>
<span class="sourceLineNo">2410</span><a id="line.2410">        public LastAck deepCopy(LastAck source) {</a>
<span class="sourceLineNo">2411</span><a id="line.2411">            return new LastAck(source);</a>
<span class="sourceLineNo">2412</span><a id="line.2412">        }</a>
<span class="sourceLineNo">2413</span><a id="line.2413"></a>
<span class="sourceLineNo">2414</span><a id="line.2414">        @Override</a>
<span class="sourceLineNo">2415</span><a id="line.2415">        public boolean isDeepCopySupported() {</a>
<span class="sourceLineNo">2416</span><a id="line.2416">            return true;</a>
<span class="sourceLineNo">2417</span><a id="line.2417">        }</a>
<span class="sourceLineNo">2418</span><a id="line.2418">    }</a>
<span class="sourceLineNo">2419</span><a id="line.2419"></a>
<span class="sourceLineNo">2420</span><a id="line.2420">    class StoredMessageStoreStatistics {</a>
<span class="sourceLineNo">2421</span><a id="line.2421">        private PageFile pageFile;</a>
<span class="sourceLineNo">2422</span><a id="line.2422">        private Page&lt;MessageStoreStatistics&gt; page;</a>
<span class="sourceLineNo">2423</span><a id="line.2423">        private long pageId;</a>
<span class="sourceLineNo">2424</span><a id="line.2424">        private AtomicBoolean loaded = new AtomicBoolean();</a>
<span class="sourceLineNo">2425</span><a id="line.2425">        private MessageStoreStatisticsMarshaller messageStoreStatisticsMarshaller = new MessageStoreStatisticsMarshaller();</a>
<span class="sourceLineNo">2426</span><a id="line.2426"></a>
<span class="sourceLineNo">2427</span><a id="line.2427">        StoredMessageStoreStatistics(PageFile pageFile, long pageId) {</a>
<span class="sourceLineNo">2428</span><a id="line.2428">            this.pageId = pageId;</a>
<span class="sourceLineNo">2429</span><a id="line.2429">            this.pageFile = pageFile;</a>
<span class="sourceLineNo">2430</span><a id="line.2430">        }</a>
<span class="sourceLineNo">2431</span><a id="line.2431"></a>
<span class="sourceLineNo">2432</span><a id="line.2432">        StoredMessageStoreStatistics(PageFile pageFile, Page page) {</a>
<span class="sourceLineNo">2433</span><a id="line.2433">            this(pageFile, page.getPageId());</a>
<span class="sourceLineNo">2434</span><a id="line.2434">        }</a>
<span class="sourceLineNo">2435</span><a id="line.2435"></a>
<span class="sourceLineNo">2436</span><a id="line.2436">        public long getPageId() {</a>
<span class="sourceLineNo">2437</span><a id="line.2437">            return pageId;</a>
<span class="sourceLineNo">2438</span><a id="line.2438">        }</a>
<span class="sourceLineNo">2439</span><a id="line.2439"></a>
<span class="sourceLineNo">2440</span><a id="line.2440">        synchronized void load(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2441</span><a id="line.2441">            if (loaded.compareAndSet(false, true)) {</a>
<span class="sourceLineNo">2442</span><a id="line.2442">                page = tx.load(pageId, null);</a>
<span class="sourceLineNo">2443</span><a id="line.2443"></a>
<span class="sourceLineNo">2444</span><a id="line.2444">                if (page.getType() == Page.PAGE_FREE_TYPE) {</a>
<span class="sourceLineNo">2445</span><a id="line.2445">                    page.set(null);</a>
<span class="sourceLineNo">2446</span><a id="line.2446">                    tx.store(page, messageStoreStatisticsMarshaller, true);</a>
<span class="sourceLineNo">2447</span><a id="line.2447">                }</a>
<span class="sourceLineNo">2448</span><a id="line.2448">            }</a>
<span class="sourceLineNo">2449</span><a id="line.2449">            page = tx.load(pageId, messageStoreStatisticsMarshaller);</a>
<span class="sourceLineNo">2450</span><a id="line.2450">        }</a>
<span class="sourceLineNo">2451</span><a id="line.2451"></a>
<span class="sourceLineNo">2452</span><a id="line.2452">        synchronized MessageStoreStatistics get(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2453</span><a id="line.2453">            load(tx);</a>
<span class="sourceLineNo">2454</span><a id="line.2454">            return page.get();</a>
<span class="sourceLineNo">2455</span><a id="line.2455">        }</a>
<span class="sourceLineNo">2456</span><a id="line.2456"></a>
<span class="sourceLineNo">2457</span><a id="line.2457">        synchronized void put(Transaction tx, MessageStoreStatistics storeStatistics) throws IOException {</a>
<span class="sourceLineNo">2458</span><a id="line.2458">            if (page == null) {</a>
<span class="sourceLineNo">2459</span><a id="line.2459">                page = tx.load(pageId, messageStoreStatisticsMarshaller);</a>
<span class="sourceLineNo">2460</span><a id="line.2460">            }</a>
<span class="sourceLineNo">2461</span><a id="line.2461"></a>
<span class="sourceLineNo">2462</span><a id="line.2462">            page.set(storeStatistics);</a>
<span class="sourceLineNo">2463</span><a id="line.2463"></a>
<span class="sourceLineNo">2464</span><a id="line.2464">            tx.store(page, messageStoreStatisticsMarshaller, true);</a>
<span class="sourceLineNo">2465</span><a id="line.2465">        }</a>
<span class="sourceLineNo">2466</span><a id="line.2466">    }</a>
<span class="sourceLineNo">2467</span><a id="line.2467">    class StoredDestination {</a>
<span class="sourceLineNo">2468</span><a id="line.2468"></a>
<span class="sourceLineNo">2469</span><a id="line.2469">        MessageOrderIndex orderIndex = new MessageOrderIndex();</a>
<span class="sourceLineNo">2470</span><a id="line.2470">        BTreeIndex&lt;Location, Long&gt; locationIndex;</a>
<span class="sourceLineNo">2471</span><a id="line.2471">        BTreeIndex&lt;String, Long&gt; messageIdIndex;</a>
<span class="sourceLineNo">2472</span><a id="line.2472"></a>
<span class="sourceLineNo">2473</span><a id="line.2473">        // These bits are only set for Topics</a>
<span class="sourceLineNo">2474</span><a id="line.2474">        BTreeIndex&lt;String, KahaSubscriptionCommand&gt; subscriptions;</a>
<span class="sourceLineNo">2475</span><a id="line.2475">        BTreeIndex&lt;String, LastAck&gt; subscriptionAcks;</a>
<span class="sourceLineNo">2476</span><a id="line.2476">        HashMap&lt;String, MessageOrderCursor&gt; subscriptionCursors;</a>
<span class="sourceLineNo">2477</span><a id="line.2477">        ListIndex&lt;String, SequenceSet&gt; ackPositions;</a>
<span class="sourceLineNo">2478</span><a id="line.2478">        ListIndex&lt;String, Location&gt; subLocations;</a>
<span class="sourceLineNo">2479</span><a id="line.2479"></a>
<span class="sourceLineNo">2480</span><a id="line.2480">        // Transient data used to track which Messages are no longer needed.</a>
<span class="sourceLineNo">2481</span><a id="line.2481">        final HashSet&lt;String&gt; subscriptionCache = new LinkedHashSet&lt;&gt;();</a>
<span class="sourceLineNo">2482</span><a id="line.2482"></a>
<span class="sourceLineNo">2483</span><a id="line.2483">        StoredMessageStoreStatistics messageStoreStatistics;</a>
<span class="sourceLineNo">2484</span><a id="line.2484"></a>
<span class="sourceLineNo">2485</span><a id="line.2485">        public void trackPendingAdd(Long seq) {</a>
<span class="sourceLineNo">2486</span><a id="line.2486">            orderIndex.trackPendingAdd(seq);</a>
<span class="sourceLineNo">2487</span><a id="line.2487">        }</a>
<span class="sourceLineNo">2488</span><a id="line.2488"></a>
<span class="sourceLineNo">2489</span><a id="line.2489">        public void trackPendingAddComplete(Long seq) {</a>
<span class="sourceLineNo">2490</span><a id="line.2490">            orderIndex.trackPendingAddComplete(seq);</a>
<span class="sourceLineNo">2491</span><a id="line.2491">        }</a>
<span class="sourceLineNo">2492</span><a id="line.2492"></a>
<span class="sourceLineNo">2493</span><a id="line.2493">        @Override</a>
<span class="sourceLineNo">2494</span><a id="line.2494">        public String toString() {</a>
<span class="sourceLineNo">2495</span><a id="line.2495">            return "nextSeq:" + orderIndex.nextMessageId + ",lastRet:" + orderIndex.cursor + ",pending:" + orderIndex.pendingAdditions.size();</a>
<span class="sourceLineNo">2496</span><a id="line.2496">        }</a>
<span class="sourceLineNo">2497</span><a id="line.2497">    }</a>
<span class="sourceLineNo">2498</span><a id="line.2498"></a>
<span class="sourceLineNo">2499</span><a id="line.2499">    protected  class MessageStoreStatisticsMarshaller extends VariableMarshaller&lt;MessageStoreStatistics&gt; {</a>
<span class="sourceLineNo">2500</span><a id="line.2500"></a>
<span class="sourceLineNo">2501</span><a id="line.2501">        @Override</a>
<span class="sourceLineNo">2502</span><a id="line.2502">        public void writePayload(final MessageStoreStatistics object, final DataOutput dataOut) throws IOException {</a>
<span class="sourceLineNo">2503</span><a id="line.2503">            dataOut.writeBoolean(null != object);</a>
<span class="sourceLineNo">2504</span><a id="line.2504">            if (object != null) {</a>
<span class="sourceLineNo">2505</span><a id="line.2505">                dataOut.writeLong(object.getMessageCount().getCount());</a>
<span class="sourceLineNo">2506</span><a id="line.2506">                dataOut.writeLong(object.getMessageSize().getTotalSize());</a>
<span class="sourceLineNo">2507</span><a id="line.2507">                dataOut.writeLong(object.getMessageSize().getMaxSize());</a>
<span class="sourceLineNo">2508</span><a id="line.2508">                dataOut.writeLong(object.getMessageSize().getMinSize());</a>
<span class="sourceLineNo">2509</span><a id="line.2509">                dataOut.writeLong(object.getMessageSize().getCount());</a>
<span class="sourceLineNo">2510</span><a id="line.2510">            }</a>
<span class="sourceLineNo">2511</span><a id="line.2511">        }</a>
<span class="sourceLineNo">2512</span><a id="line.2512"></a>
<span class="sourceLineNo">2513</span><a id="line.2513">        @Override</a>
<span class="sourceLineNo">2514</span><a id="line.2514">        public MessageStoreStatistics readPayload(final DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">2515</span><a id="line.2515"></a>
<span class="sourceLineNo">2516</span><a id="line.2516">            if (!dataIn.readBoolean()) {</a>
<span class="sourceLineNo">2517</span><a id="line.2517">                return null;</a>
<span class="sourceLineNo">2518</span><a id="line.2518">            }</a>
<span class="sourceLineNo">2519</span><a id="line.2519"></a>
<span class="sourceLineNo">2520</span><a id="line.2520">            MessageStoreStatistics messageStoreStatistics = new MessageStoreStatistics();</a>
<span class="sourceLineNo">2521</span><a id="line.2521">            messageStoreStatistics.getMessageCount().setCount(dataIn.readLong());</a>
<span class="sourceLineNo">2522</span><a id="line.2522">            messageStoreStatistics.getMessageSize().setTotalSize(dataIn.readLong());</a>
<span class="sourceLineNo">2523</span><a id="line.2523">            messageStoreStatistics.getMessageSize().setMaxSize(dataIn.readLong());</a>
<span class="sourceLineNo">2524</span><a id="line.2524">            messageStoreStatistics.getMessageSize().setMinSize(dataIn.readLong());</a>
<span class="sourceLineNo">2525</span><a id="line.2525">            messageStoreStatistics.getMessageSize().setCount(dataIn.readLong());</a>
<span class="sourceLineNo">2526</span><a id="line.2526"></a>
<span class="sourceLineNo">2527</span><a id="line.2527">            return messageStoreStatistics;</a>
<span class="sourceLineNo">2528</span><a id="line.2528">        }</a>
<span class="sourceLineNo">2529</span><a id="line.2529">    }</a>
<span class="sourceLineNo">2530</span><a id="line.2530"></a>
<span class="sourceLineNo">2531</span><a id="line.2531">    protected class StoredDestinationMarshaller extends VariableMarshaller&lt;StoredDestination&gt; {</a>
<span class="sourceLineNo">2532</span><a id="line.2532"></a>
<span class="sourceLineNo">2533</span><a id="line.2533">        final MessageKeysMarshaller messageKeysMarshaller = new MessageKeysMarshaller();</a>
<span class="sourceLineNo">2534</span><a id="line.2534"></a>
<span class="sourceLineNo">2535</span><a id="line.2535">        @Override</a>
<span class="sourceLineNo">2536</span><a id="line.2536">        public StoredDestination readPayload(final DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">2537</span><a id="line.2537">            final StoredDestination value = new StoredDestination();</a>
<span class="sourceLineNo">2538</span><a id="line.2538">            value.orderIndex.defaultPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2539</span><a id="line.2539">            value.locationIndex = new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2540</span><a id="line.2540">            value.messageIdIndex = new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2541</span><a id="line.2541"></a>
<span class="sourceLineNo">2542</span><a id="line.2542">            if (dataIn.readBoolean()) {</a>
<span class="sourceLineNo">2543</span><a id="line.2543">                value.subscriptions = new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2544</span><a id="line.2544">                value.subscriptionAcks = new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2545</span><a id="line.2545">                if (metadata.version &gt;= 4) {</a>
<span class="sourceLineNo">2546</span><a id="line.2546">                    value.ackPositions = new ListIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2547</span><a id="line.2547">                } else {</a>
<span class="sourceLineNo">2548</span><a id="line.2548">                    // upgrade</a>
<span class="sourceLineNo">2549</span><a id="line.2549">                    pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">2550</span><a id="line.2550">                        @Override</a>
<span class="sourceLineNo">2551</span><a id="line.2551">                        public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2552</span><a id="line.2552">                            LinkedHashMap&lt;String, SequenceSet&gt; temp = new LinkedHashMap&lt;&gt;();</a>
<span class="sourceLineNo">2553</span><a id="line.2553"></a>
<span class="sourceLineNo">2554</span><a id="line.2554">                            if (metadata.version &gt;= 3) {</a>
<span class="sourceLineNo">2555</span><a id="line.2555">                                // migrate</a>
<span class="sourceLineNo">2556</span><a id="line.2556">                                BTreeIndex&lt;Long, HashSet&lt;String&gt;&gt; oldAckPositions =</a>
<span class="sourceLineNo">2557</span><a id="line.2557">                                        new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2558</span><a id="line.2558">                                oldAckPositions.setKeyMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2559</span><a id="line.2559">                                oldAckPositions.setValueMarshaller(HashSetStringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2560</span><a id="line.2560">                                oldAckPositions.load(tx);</a>
<span class="sourceLineNo">2561</span><a id="line.2561"></a>
<span class="sourceLineNo">2562</span><a id="line.2562"></a>
<span class="sourceLineNo">2563</span><a id="line.2563">                                // Do the initial build of the data in memory before writing into the store</a>
<span class="sourceLineNo">2564</span><a id="line.2564">                                // based Ack Positions List to avoid a lot of disk thrashing.</a>
<span class="sourceLineNo">2565</span><a id="line.2565">                                Iterator&lt;Entry&lt;Long, HashSet&lt;String&gt;&gt;&gt; iterator = oldAckPositions.iterator(tx);</a>
<span class="sourceLineNo">2566</span><a id="line.2566">                                while (iterator.hasNext()) {</a>
<span class="sourceLineNo">2567</span><a id="line.2567">                                    Entry&lt;Long, HashSet&lt;String&gt;&gt; entry = iterator.next();</a>
<span class="sourceLineNo">2568</span><a id="line.2568"></a>
<span class="sourceLineNo">2569</span><a id="line.2569">                                    for(String subKey : entry.getValue()) {</a>
<span class="sourceLineNo">2570</span><a id="line.2570">                                        SequenceSet pendingAcks = temp.get(subKey);</a>
<span class="sourceLineNo">2571</span><a id="line.2571">                                        if (pendingAcks == null) {</a>
<span class="sourceLineNo">2572</span><a id="line.2572">                                            pendingAcks = new SequenceSet();</a>
<span class="sourceLineNo">2573</span><a id="line.2573">                                            temp.put(subKey, pendingAcks);</a>
<span class="sourceLineNo">2574</span><a id="line.2574">                                        }</a>
<span class="sourceLineNo">2575</span><a id="line.2575"></a>
<span class="sourceLineNo">2576</span><a id="line.2576">                                        pendingAcks.add(entry.getKey());</a>
<span class="sourceLineNo">2577</span><a id="line.2577">                                    }</a>
<span class="sourceLineNo">2578</span><a id="line.2578">                                }</a>
<span class="sourceLineNo">2579</span><a id="line.2579">                            }</a>
<span class="sourceLineNo">2580</span><a id="line.2580">                            // Now move the pending messages to ack data into the store backed</a>
<span class="sourceLineNo">2581</span><a id="line.2581">                            // structure.</a>
<span class="sourceLineNo">2582</span><a id="line.2582">                            value.ackPositions = new ListIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2583</span><a id="line.2583">                            value.ackPositions.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2584</span><a id="line.2584">                            value.ackPositions.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);</a>
<span class="sourceLineNo">2585</span><a id="line.2585">                            value.ackPositions.load(tx);</a>
<span class="sourceLineNo">2586</span><a id="line.2586">                            for(String subscriptionKey : temp.keySet()) {</a>
<span class="sourceLineNo">2587</span><a id="line.2587">                                value.ackPositions.put(tx, subscriptionKey, temp.get(subscriptionKey));</a>
<span class="sourceLineNo">2588</span><a id="line.2588">                            }</a>
<span class="sourceLineNo">2589</span><a id="line.2589"></a>
<span class="sourceLineNo">2590</span><a id="line.2590">                        }</a>
<span class="sourceLineNo">2591</span><a id="line.2591">                    });</a>
<span class="sourceLineNo">2592</span><a id="line.2592">                }</a>
<span class="sourceLineNo">2593</span><a id="line.2593"></a>
<span class="sourceLineNo">2594</span><a id="line.2594">                if (metadata.version &gt;= 5) {</a>
<span class="sourceLineNo">2595</span><a id="line.2595">                    value.subLocations = new ListIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2596</span><a id="line.2596">                } else {</a>
<span class="sourceLineNo">2597</span><a id="line.2597">                    // upgrade</a>
<span class="sourceLineNo">2598</span><a id="line.2598">                    pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">2599</span><a id="line.2599">                        @Override</a>
<span class="sourceLineNo">2600</span><a id="line.2600">                        public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2601</span><a id="line.2601">                            value.subLocations = new ListIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2602</span><a id="line.2602">                            value.subLocations.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2603</span><a id="line.2603">                            value.subLocations.setValueMarshaller(LocationMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2604</span><a id="line.2604">                            value.subLocations.load(tx);</a>
<span class="sourceLineNo">2605</span><a id="line.2605">                        }</a>
<span class="sourceLineNo">2606</span><a id="line.2606">                    });</a>
<span class="sourceLineNo">2607</span><a id="line.2607">                }</a>
<span class="sourceLineNo">2608</span><a id="line.2608">            }</a>
<span class="sourceLineNo">2609</span><a id="line.2609"></a>
<span class="sourceLineNo">2610</span><a id="line.2610">            if (metadata.version &gt;= 2) {</a>
<span class="sourceLineNo">2611</span><a id="line.2611">                value.orderIndex.lowPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2612</span><a id="line.2612">                value.orderIndex.highPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2613</span><a id="line.2613">            } else {</a>
<span class="sourceLineNo">2614</span><a id="line.2614">                // upgrade</a>
<span class="sourceLineNo">2615</span><a id="line.2615">                pageFile.tx().execute(new Transaction.Closure&lt;IOException&gt;() {</a>
<span class="sourceLineNo">2616</span><a id="line.2616">                    @Override</a>
<span class="sourceLineNo">2617</span><a id="line.2617">                    public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2618</span><a id="line.2618">                        value.orderIndex.lowPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2619</span><a id="line.2619">                        value.orderIndex.lowPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2620</span><a id="line.2620">                        value.orderIndex.lowPriorityIndex.setValueMarshaller(messageKeysMarshaller);</a>
<span class="sourceLineNo">2621</span><a id="line.2621">                        value.orderIndex.lowPriorityIndex.load(tx);</a>
<span class="sourceLineNo">2622</span><a id="line.2622"></a>
<span class="sourceLineNo">2623</span><a id="line.2623">                        value.orderIndex.highPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2624</span><a id="line.2624">                        value.orderIndex.highPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2625</span><a id="line.2625">                        value.orderIndex.highPriorityIndex.setValueMarshaller(messageKeysMarshaller);</a>
<span class="sourceLineNo">2626</span><a id="line.2626">                        value.orderIndex.highPriorityIndex.load(tx);</a>
<span class="sourceLineNo">2627</span><a id="line.2627">                    }</a>
<span class="sourceLineNo">2628</span><a id="line.2628">                });</a>
<span class="sourceLineNo">2629</span><a id="line.2629">            }</a>
<span class="sourceLineNo">2630</span><a id="line.2630"></a>
<span class="sourceLineNo">2631</span><a id="line.2631">            if (metadata.version &gt;= 7) {</a>
<span class="sourceLineNo">2632</span><a id="line.2632">                value.messageStoreStatistics = new StoredMessageStoreStatistics(pageFile, dataIn.readLong());</a>
<span class="sourceLineNo">2633</span><a id="line.2633">            } else {</a>
<span class="sourceLineNo">2634</span><a id="line.2634">                pageFile.tx().execute(tx -&gt; {</a>
<span class="sourceLineNo">2635</span><a id="line.2635">                    value.messageStoreStatistics = new StoredMessageStoreStatistics(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2636</span><a id="line.2636">                    value.messageStoreStatistics.load(tx);</a>
<span class="sourceLineNo">2637</span><a id="line.2637">                });</a>
<span class="sourceLineNo">2638</span><a id="line.2638">            }</a>
<span class="sourceLineNo">2639</span><a id="line.2639"></a>
<span class="sourceLineNo">2640</span><a id="line.2640">            return value;</a>
<span class="sourceLineNo">2641</span><a id="line.2641">        }</a>
<span class="sourceLineNo">2642</span><a id="line.2642"></a>
<span class="sourceLineNo">2643</span><a id="line.2643">        @Override</a>
<span class="sourceLineNo">2644</span><a id="line.2644">        public void writePayload(StoredDestination value, DataOutput dataOut) throws IOException {</a>
<span class="sourceLineNo">2645</span><a id="line.2645">            dataOut.writeLong(value.orderIndex.defaultPriorityIndex.getPageId());</a>
<span class="sourceLineNo">2646</span><a id="line.2646">            dataOut.writeLong(value.locationIndex.getPageId());</a>
<span class="sourceLineNo">2647</span><a id="line.2647">            dataOut.writeLong(value.messageIdIndex.getPageId());</a>
<span class="sourceLineNo">2648</span><a id="line.2648">            if (value.subscriptions != null) {</a>
<span class="sourceLineNo">2649</span><a id="line.2649">                dataOut.writeBoolean(true);</a>
<span class="sourceLineNo">2650</span><a id="line.2650">                dataOut.writeLong(value.subscriptions.getPageId());</a>
<span class="sourceLineNo">2651</span><a id="line.2651">                dataOut.writeLong(value.subscriptionAcks.getPageId());</a>
<span class="sourceLineNo">2652</span><a id="line.2652">                dataOut.writeLong(value.ackPositions.getHeadPageId());</a>
<span class="sourceLineNo">2653</span><a id="line.2653">                dataOut.writeLong(value.subLocations.getHeadPageId());</a>
<span class="sourceLineNo">2654</span><a id="line.2654">            } else {</a>
<span class="sourceLineNo">2655</span><a id="line.2655">                dataOut.writeBoolean(false);</a>
<span class="sourceLineNo">2656</span><a id="line.2656">            }</a>
<span class="sourceLineNo">2657</span><a id="line.2657">            dataOut.writeLong(value.orderIndex.lowPriorityIndex.getPageId());</a>
<span class="sourceLineNo">2658</span><a id="line.2658">            dataOut.writeLong(value.orderIndex.highPriorityIndex.getPageId());</a>
<span class="sourceLineNo">2659</span><a id="line.2659">            dataOut.writeLong(value.messageStoreStatistics.getPageId());</a>
<span class="sourceLineNo">2660</span><a id="line.2660">        }</a>
<span class="sourceLineNo">2661</span><a id="line.2661">    }</a>
<span class="sourceLineNo">2662</span><a id="line.2662"></a>
<span class="sourceLineNo">2663</span><a id="line.2663">    static class KahaSubscriptionCommandMarshaller extends VariableMarshaller&lt;KahaSubscriptionCommand&gt; {</a>
<span class="sourceLineNo">2664</span><a id="line.2664">        final static KahaSubscriptionCommandMarshaller INSTANCE = new KahaSubscriptionCommandMarshaller();</a>
<span class="sourceLineNo">2665</span><a id="line.2665"></a>
<span class="sourceLineNo">2666</span><a id="line.2666">        @Override</a>
<span class="sourceLineNo">2667</span><a id="line.2667">        public KahaSubscriptionCommand readPayload(DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">2668</span><a id="line.2668">            KahaSubscriptionCommand rc = new KahaSubscriptionCommand();</a>
<span class="sourceLineNo">2669</span><a id="line.2669">            rc.mergeFramed((InputStream)dataIn);</a>
<span class="sourceLineNo">2670</span><a id="line.2670">            return rc;</a>
<span class="sourceLineNo">2671</span><a id="line.2671">        }</a>
<span class="sourceLineNo">2672</span><a id="line.2672"></a>
<span class="sourceLineNo">2673</span><a id="line.2673">        @Override</a>
<span class="sourceLineNo">2674</span><a id="line.2674">        public void writePayload(KahaSubscriptionCommand object, DataOutput dataOut) throws IOException {</a>
<span class="sourceLineNo">2675</span><a id="line.2675">            object.writeFramed((OutputStream)dataOut);</a>
<span class="sourceLineNo">2676</span><a id="line.2676">        }</a>
<span class="sourceLineNo">2677</span><a id="line.2677">    }</a>
<span class="sourceLineNo">2678</span><a id="line.2678"></a>
<span class="sourceLineNo">2679</span><a id="line.2679">    protected StoredDestination getStoredDestination(KahaDestination destination, Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2680</span><a id="line.2680">        String key = key(destination);</a>
<span class="sourceLineNo">2681</span><a id="line.2681">        StoredDestination rc = storedDestinations.get(key);</a>
<span class="sourceLineNo">2682</span><a id="line.2682">        if (rc == null) {</a>
<span class="sourceLineNo">2683</span><a id="line.2683">            boolean topic = destination.getType() == KahaDestination.DestinationType.TOPIC || destination.getType() == KahaDestination.DestinationType.TEMP_TOPIC;</a>
<span class="sourceLineNo">2684</span><a id="line.2684">            rc = loadStoredDestination(tx, key, topic);</a>
<span class="sourceLineNo">2685</span><a id="line.2685">            // Cache it. We may want to remove/unload destinations from the</a>
<span class="sourceLineNo">2686</span><a id="line.2686">            // cache that are not used for a while</a>
<span class="sourceLineNo">2687</span><a id="line.2687">            // to reduce memory usage.</a>
<span class="sourceLineNo">2688</span><a id="line.2688">            storedDestinations.put(key, rc);</a>
<span class="sourceLineNo">2689</span><a id="line.2689">        }</a>
<span class="sourceLineNo">2690</span><a id="line.2690">        return rc;</a>
<span class="sourceLineNo">2691</span><a id="line.2691">    }</a>
<span class="sourceLineNo">2692</span><a id="line.2692"></a>
<span class="sourceLineNo">2693</span><a id="line.2693">    protected MessageStoreStatistics getStoredMessageStoreStatistics(KahaDestination destination, Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2694</span><a id="line.2694">        StoredDestination sd = getStoredDestination(destination, tx);</a>
<span class="sourceLineNo">2695</span><a id="line.2695">        return  sd != null &amp;&amp; sd.messageStoreStatistics != null ? sd.messageStoreStatistics.get(tx) : null;</a>
<span class="sourceLineNo">2696</span><a id="line.2696">    }</a>
<span class="sourceLineNo">2697</span><a id="line.2697"></a>
<span class="sourceLineNo">2698</span><a id="line.2698">    protected StoredDestination getExistingStoredDestination(KahaDestination destination, Transaction tx) throws IOException {</a>
<span class="sourceLineNo">2699</span><a id="line.2699">        String key = key(destination);</a>
<span class="sourceLineNo">2700</span><a id="line.2700">        StoredDestination rc = storedDestinations.get(key);</a>
<span class="sourceLineNo">2701</span><a id="line.2701">        if (rc == null &amp;&amp; metadata.destinations.containsKey(tx, key)) {</a>
<span class="sourceLineNo">2702</span><a id="line.2702">            rc = getStoredDestination(destination, tx);</a>
<span class="sourceLineNo">2703</span><a id="line.2703">        }</a>
<span class="sourceLineNo">2704</span><a id="line.2704">        return rc;</a>
<span class="sourceLineNo">2705</span><a id="line.2705">    }</a>
<span class="sourceLineNo">2706</span><a id="line.2706"></a>
<span class="sourceLineNo">2707</span><a id="line.2707">    /**</a>
<span class="sourceLineNo">2708</span><a id="line.2708">     * @param tx</a>
<span class="sourceLineNo">2709</span><a id="line.2709">     * @param key</a>
<span class="sourceLineNo">2710</span><a id="line.2710">     * @param topic</a>
<span class="sourceLineNo">2711</span><a id="line.2711">     * @return</a>
<span class="sourceLineNo">2712</span><a id="line.2712">     * @throws IOException</a>
<span class="sourceLineNo">2713</span><a id="line.2713">     */</a>
<span class="sourceLineNo">2714</span><a id="line.2714">    private StoredDestination loadStoredDestination(Transaction tx, String key, boolean topic) throws IOException {</a>
<span class="sourceLineNo">2715</span><a id="line.2715">        // Try to load the existing indexes..</a>
<span class="sourceLineNo">2716</span><a id="line.2716">        StoredDestination rc = metadata.destinations.get(tx, key);</a>
<span class="sourceLineNo">2717</span><a id="line.2717">        if (rc == null) {</a>
<span class="sourceLineNo">2718</span><a id="line.2718">            // Brand new destination.. allocate indexes for it.</a>
<span class="sourceLineNo">2719</span><a id="line.2719">            rc = new StoredDestination();</a>
<span class="sourceLineNo">2720</span><a id="line.2720">            rc.orderIndex.allocate(tx);</a>
<span class="sourceLineNo">2721</span><a id="line.2721">            rc.locationIndex = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2722</span><a id="line.2722">            rc.messageIdIndex = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2723</span><a id="line.2723"></a>
<span class="sourceLineNo">2724</span><a id="line.2724">            if (topic) {</a>
<span class="sourceLineNo">2725</span><a id="line.2725">                rc.subscriptions = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2726</span><a id="line.2726">                rc.subscriptionAcks = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2727</span><a id="line.2727">                rc.ackPositions = new ListIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2728</span><a id="line.2728">                rc.subLocations = new ListIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2729</span><a id="line.2729">            }</a>
<span class="sourceLineNo">2730</span><a id="line.2730"></a>
<span class="sourceLineNo">2731</span><a id="line.2731">            rc.messageStoreStatistics = new StoredMessageStoreStatistics(pageFile, tx.allocate());</a>
<span class="sourceLineNo">2732</span><a id="line.2732"></a>
<span class="sourceLineNo">2733</span><a id="line.2733">            metadata.destinations.put(tx, key, rc);</a>
<span class="sourceLineNo">2734</span><a id="line.2734">        }</a>
<span class="sourceLineNo">2735</span><a id="line.2735"></a>
<span class="sourceLineNo">2736</span><a id="line.2736">        rc.messageStoreStatistics.load(tx);</a>
<span class="sourceLineNo">2737</span><a id="line.2737"></a>
<span class="sourceLineNo">2738</span><a id="line.2738">        // Configure the marshalers and load.</a>
<span class="sourceLineNo">2739</span><a id="line.2739">        rc.orderIndex.load(tx);</a>
<span class="sourceLineNo">2740</span><a id="line.2740"></a>
<span class="sourceLineNo">2741</span><a id="line.2741">        // Figure out the next key using the last entry in the destination.</a>
<span class="sourceLineNo">2742</span><a id="line.2742">        rc.orderIndex.configureLast(tx);</a>
<span class="sourceLineNo">2743</span><a id="line.2743"></a>
<span class="sourceLineNo">2744</span><a id="line.2744">        rc.locationIndex.setKeyMarshaller(new LocationSizeMarshaller());</a>
<span class="sourceLineNo">2745</span><a id="line.2745">        rc.locationIndex.setValueMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2746</span><a id="line.2746">        rc.locationIndex.load(tx);</a>
<span class="sourceLineNo">2747</span><a id="line.2747"></a>
<span class="sourceLineNo">2748</span><a id="line.2748">        rc.messageIdIndex.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2749</span><a id="line.2749">        rc.messageIdIndex.setValueMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2750</span><a id="line.2750">        rc.messageIdIndex.load(tx);</a>
<span class="sourceLineNo">2751</span><a id="line.2751"></a>
<span class="sourceLineNo">2752</span><a id="line.2752">        //go through an upgrade old index if older than version 6</a>
<span class="sourceLineNo">2753</span><a id="line.2753">        if (metadata.version &lt; 6) {</a>
<span class="sourceLineNo">2754</span><a id="line.2754">            for (Iterator&lt;Entry&lt;Location, Long&gt;&gt; iterator = rc.locationIndex.iterator(tx); iterator.hasNext(); ) {</a>
<span class="sourceLineNo">2755</span><a id="line.2755">                Entry&lt;Location, Long&gt; entry = iterator.next();</a>
<span class="sourceLineNo">2756</span><a id="line.2756">                // modify so it is upgraded</a>
<span class="sourceLineNo">2757</span><a id="line.2757">                rc.locationIndex.put(tx, entry.getKey(), entry.getValue());</a>
<span class="sourceLineNo">2758</span><a id="line.2758">            }</a>
<span class="sourceLineNo">2759</span><a id="line.2759">            //upgrade the order index</a>
<span class="sourceLineNo">2760</span><a id="line.2760">            for (Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt; iterator = rc.orderIndex.iterator(tx); iterator.hasNext(); ) {</a>
<span class="sourceLineNo">2761</span><a id="line.2761">                Entry&lt;Long, MessageKeys&gt; entry = iterator.next();</a>
<span class="sourceLineNo">2762</span><a id="line.2762">                //call get so that the last priority is updated</a>
<span class="sourceLineNo">2763</span><a id="line.2763">                rc.orderIndex.get(tx, entry.getKey());</a>
<span class="sourceLineNo">2764</span><a id="line.2764">                rc.orderIndex.put(tx, rc.orderIndex.lastGetPriority(), entry.getKey(), entry.getValue());</a>
<span class="sourceLineNo">2765</span><a id="line.2765">            }</a>
<span class="sourceLineNo">2766</span><a id="line.2766">        }</a>
<span class="sourceLineNo">2767</span><a id="line.2767"></a>
<span class="sourceLineNo">2768</span><a id="line.2768">        // If it was a topic...</a>
<span class="sourceLineNo">2769</span><a id="line.2769">        if (topic) {</a>
<span class="sourceLineNo">2770</span><a id="line.2770"></a>
<span class="sourceLineNo">2771</span><a id="line.2771">            rc.subscriptions.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2772</span><a id="line.2772">            rc.subscriptions.setValueMarshaller(KahaSubscriptionCommandMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2773</span><a id="line.2773">            rc.subscriptions.load(tx);</a>
<span class="sourceLineNo">2774</span><a id="line.2774"></a>
<span class="sourceLineNo">2775</span><a id="line.2775">            rc.subscriptionAcks.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2776</span><a id="line.2776">            rc.subscriptionAcks.setValueMarshaller(new LastAckMarshaller());</a>
<span class="sourceLineNo">2777</span><a id="line.2777">            rc.subscriptionAcks.load(tx);</a>
<span class="sourceLineNo">2778</span><a id="line.2778"></a>
<span class="sourceLineNo">2779</span><a id="line.2779">            rc.ackPositions.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2780</span><a id="line.2780">            rc.ackPositions.setValueMarshaller(SequenceSet.Marshaller.INSTANCE);</a>
<span class="sourceLineNo">2781</span><a id="line.2781">            rc.ackPositions.load(tx);</a>
<span class="sourceLineNo">2782</span><a id="line.2782"></a>
<span class="sourceLineNo">2783</span><a id="line.2783">            rc.subLocations.setKeyMarshaller(StringMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2784</span><a id="line.2784">            rc.subLocations.setValueMarshaller(LocationMarshaller.INSTANCE);</a>
<span class="sourceLineNo">2785</span><a id="line.2785">            rc.subLocations.load(tx);</a>
<span class="sourceLineNo">2786</span><a id="line.2786"></a>
<span class="sourceLineNo">2787</span><a id="line.2787">            rc.subscriptionCursors = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">2788</span><a id="line.2788"></a>
<span class="sourceLineNo">2789</span><a id="line.2789">            if (metadata.version &lt; 3) {</a>
<span class="sourceLineNo">2790</span><a id="line.2790"></a>
<span class="sourceLineNo">2791</span><a id="line.2791">                // on upgrade need to fill ackLocation with available messages past last ack</a>
<span class="sourceLineNo">2792</span><a id="line.2792">                for (Iterator&lt;Entry&lt;String, LastAck&gt;&gt; iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {</a>
<span class="sourceLineNo">2793</span><a id="line.2793">                    Entry&lt;String, LastAck&gt; entry = iterator.next();</a>
<span class="sourceLineNo">2794</span><a id="line.2794">                    for (Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt; orderIterator =</a>
<span class="sourceLineNo">2795</span><a id="line.2795">                            rc.orderIndex.iterator(tx, new MessageOrderCursor(entry.getValue().lastAckedSequence)); orderIterator.hasNext(); ) {</a>
<span class="sourceLineNo">2796</span><a id="line.2796">                        Long sequence = orderIterator.next().getKey();</a>
<span class="sourceLineNo">2797</span><a id="line.2797">                        addAckLocation(tx, rc, sequence, entry.getKey());</a>
<span class="sourceLineNo">2798</span><a id="line.2798">                    }</a>
<span class="sourceLineNo">2799</span><a id="line.2799">                    // modify so it is upgraded</a>
<span class="sourceLineNo">2800</span><a id="line.2800">                    rc.subscriptionAcks.put(tx, entry.getKey(), entry.getValue());</a>
<span class="sourceLineNo">2801</span><a id="line.2801">                }</a>
<span class="sourceLineNo">2802</span><a id="line.2802">            }</a>
<span class="sourceLineNo">2803</span><a id="line.2803"></a>
<span class="sourceLineNo">2804</span><a id="line.2804">            // Configure the subscription cache</a>
<span class="sourceLineNo">2805</span><a id="line.2805">            for (Iterator&lt;Entry&lt;String, LastAck&gt;&gt; iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext(); ) {</a>
<span class="sourceLineNo">2806</span><a id="line.2806">                Entry&lt;String, LastAck&gt; entry = iterator.next();</a>
<span class="sourceLineNo">2807</span><a id="line.2807">                rc.subscriptionCache.add(entry.getKey());</a>
<span class="sourceLineNo">2808</span><a id="line.2808">            }</a>
<span class="sourceLineNo">2809</span><a id="line.2809"></a>
<span class="sourceLineNo">2810</span><a id="line.2810">            if (rc.orderIndex.nextMessageId == 0) {</a>
<span class="sourceLineNo">2811</span><a id="line.2811">                // check for existing durable sub all acked out - pull next seq from acks as messages are gone</a>
<span class="sourceLineNo">2812</span><a id="line.2812">                if (!rc.subscriptionAcks.isEmpty(tx)) {</a>
<span class="sourceLineNo">2813</span><a id="line.2813">                    for (Iterator&lt;Entry&lt;String, LastAck&gt;&gt; iterator = rc.subscriptionAcks.iterator(tx); iterator.hasNext();) {</a>
<span class="sourceLineNo">2814</span><a id="line.2814">                        Entry&lt;String, LastAck&gt; entry = iterator.next();</a>
<span class="sourceLineNo">2815</span><a id="line.2815">                        rc.orderIndex.nextMessageId =</a>
<span class="sourceLineNo">2816</span><a id="line.2816">                                Math.max(rc.orderIndex.nextMessageId, entry.getValue().lastAckedSequence +1);</a>
<span class="sourceLineNo">2817</span><a id="line.2817">                    }</a>
<span class="sourceLineNo">2818</span><a id="line.2818">                }</a>
<span class="sourceLineNo">2819</span><a id="line.2819">            } else {</a>
<span class="sourceLineNo">2820</span><a id="line.2820">                // update based on ackPositions for unmatched, last entry is always the next</a>
<span class="sourceLineNo">2821</span><a id="line.2821">                Iterator&lt;Entry&lt;String, SequenceSet&gt;&gt; subscriptions = rc.ackPositions.iterator(tx);</a>
<span class="sourceLineNo">2822</span><a id="line.2822">                while (subscriptions.hasNext()) {</a>
<span class="sourceLineNo">2823</span><a id="line.2823">                    Entry&lt;String, SequenceSet&gt; subscription = subscriptions.next();</a>
<span class="sourceLineNo">2824</span><a id="line.2824">                    SequenceSet pendingAcks = subscription.getValue();</a>
<span class="sourceLineNo">2825</span><a id="line.2825">                    if (pendingAcks != null &amp;&amp; !pendingAcks.isEmpty()) {</a>
<span class="sourceLineNo">2826</span><a id="line.2826">                        for (Long sequenceId : pendingAcks) {</a>
<span class="sourceLineNo">2827</span><a id="line.2827">                            rc.orderIndex.nextMessageId = Math.max(rc.orderIndex.nextMessageId, sequenceId);</a>
<span class="sourceLineNo">2828</span><a id="line.2828">                        }</a>
<span class="sourceLineNo">2829</span><a id="line.2829">                    }</a>
<span class="sourceLineNo">2830</span><a id="line.2830">                }</a>
<span class="sourceLineNo">2831</span><a id="line.2831">            }</a>
<span class="sourceLineNo">2832</span><a id="line.2832">        }</a>
<span class="sourceLineNo">2833</span><a id="line.2833"></a>
<span class="sourceLineNo">2834</span><a id="line.2834">        if (metadata.version &lt; VERSION) {</a>
<span class="sourceLineNo">2835</span><a id="line.2835">            // store again after upgrade</a>
<span class="sourceLineNo">2836</span><a id="line.2836">            metadata.destinations.put(tx, key, rc);</a>
<span class="sourceLineNo">2837</span><a id="line.2837">        }</a>
<span class="sourceLineNo">2838</span><a id="line.2838">        return rc;</a>
<span class="sourceLineNo">2839</span><a id="line.2839">    }</a>
<span class="sourceLineNo">2840</span><a id="line.2840"></a>
<span class="sourceLineNo">2841</span><a id="line.2841">    /**</a>
<span class="sourceLineNo">2842</span><a id="line.2842">     * Clear the counter for the destination, if one exists.</a>
<span class="sourceLineNo">2843</span><a id="line.2843">     *</a>
<span class="sourceLineNo">2844</span><a id="line.2844">     * @param kahaDestination</a>
<span class="sourceLineNo">2845</span><a id="line.2845">     */</a>
<span class="sourceLineNo">2846</span><a id="line.2846">    protected void clearStoreStats(KahaDestination kahaDestination) {</a>
<span class="sourceLineNo">2847</span><a id="line.2847">        String key = key(kahaDestination);</a>
<span class="sourceLineNo">2848</span><a id="line.2848">        MessageStoreStatistics storeStats = getStoreStats(key);</a>
<span class="sourceLineNo">2849</span><a id="line.2849">        MessageStoreSubscriptionStatistics subStats = getSubStats(key);</a>
<span class="sourceLineNo">2850</span><a id="line.2850">        if (storeStats != null) {</a>
<span class="sourceLineNo">2851</span><a id="line.2851">            storeStats.reset();</a>
<span class="sourceLineNo">2852</span><a id="line.2852">        }</a>
<span class="sourceLineNo">2853</span><a id="line.2853">        if (subStats != null) {</a>
<span class="sourceLineNo">2854</span><a id="line.2854">            subStats.reset();</a>
<span class="sourceLineNo">2855</span><a id="line.2855">        }</a>
<span class="sourceLineNo">2856</span><a id="line.2856">    }</a>
<span class="sourceLineNo">2857</span><a id="line.2857"></a>
<span class="sourceLineNo">2858</span><a id="line.2858">    /**</a>
<span class="sourceLineNo">2859</span><a id="line.2859">     * Update MessageStoreStatistics</a>
<span class="sourceLineNo">2860</span><a id="line.2860">     *</a>
<span class="sourceLineNo">2861</span><a id="line.2861">     * @param kahaDestination</a>
<span class="sourceLineNo">2862</span><a id="line.2862">     * @param size</a>
<span class="sourceLineNo">2863</span><a id="line.2863">     */</a>
<span class="sourceLineNo">2864</span><a id="line.2864">    protected void incrementAndAddSizeToStoreStat(Transaction tx, KahaDestination kahaDestination, long size) throws IOException {</a>
<span class="sourceLineNo">2865</span><a id="line.2865">        StoredDestination sd = getStoredDestination(kahaDestination, tx);</a>
<span class="sourceLineNo">2866</span><a id="line.2866">        incrementAndAddSizeToStoreStat(tx, key(kahaDestination), sd, size);</a>
<span class="sourceLineNo">2867</span><a id="line.2867">    }</a>
<span class="sourceLineNo">2868</span><a id="line.2868"></a>
<span class="sourceLineNo">2869</span><a id="line.2869">    protected void incrementAndAddSizeToStoreStat(Transaction tx, String kahaDestKey, StoredDestination sd, long size) throws IOException {</a>
<span class="sourceLineNo">2870</span><a id="line.2870">        MessageStoreStatistics storeStats = getStoreStats(kahaDestKey);</a>
<span class="sourceLineNo">2871</span><a id="line.2871">        if (storeStats != null) {</a>
<span class="sourceLineNo">2872</span><a id="line.2872">            incrementAndAddSizeToStoreStat(size, storeStats);</a>
<span class="sourceLineNo">2873</span><a id="line.2873">            sd.messageStoreStatistics.put(tx, storeStats);</a>
<span class="sourceLineNo">2874</span><a id="line.2874">        } else if (sd != null){</a>
<span class="sourceLineNo">2875</span><a id="line.2875">            // During the recovery the storeStats is null</a>
<span class="sourceLineNo">2876</span><a id="line.2876">            MessageStoreStatistics storedStoreStats = sd.messageStoreStatistics.get(tx);</a>
<span class="sourceLineNo">2877</span><a id="line.2877">            if (storedStoreStats == null) {</a>
<span class="sourceLineNo">2878</span><a id="line.2878">                storedStoreStats = new MessageStoreStatistics();</a>
<span class="sourceLineNo">2879</span><a id="line.2879">            }</a>
<span class="sourceLineNo">2880</span><a id="line.2880">            incrementAndAddSizeToStoreStat(size, storedStoreStats);</a>
<span class="sourceLineNo">2881</span><a id="line.2881">            sd.messageStoreStatistics.put(tx, storedStoreStats);</a>
<span class="sourceLineNo">2882</span><a id="line.2882">        }</a>
<span class="sourceLineNo">2883</span><a id="line.2883">    }</a>
<span class="sourceLineNo">2884</span><a id="line.2884"></a>
<span class="sourceLineNo">2885</span><a id="line.2885">    private void incrementAndAddSizeToStoreStat(final long size, final MessageStoreStatistics storedStoreStats) {</a>
<span class="sourceLineNo">2886</span><a id="line.2886">        storedStoreStats.getMessageCount().increment();</a>
<span class="sourceLineNo">2887</span><a id="line.2887">        if (size &gt; 0) {</a>
<span class="sourceLineNo">2888</span><a id="line.2888">            storedStoreStats.getMessageSize().addSize(size);</a>
<span class="sourceLineNo">2889</span><a id="line.2889">        }</a>
<span class="sourceLineNo">2890</span><a id="line.2890">    }</a>
<span class="sourceLineNo">2891</span><a id="line.2891"></a>
<span class="sourceLineNo">2892</span><a id="line.2892">    protected void decrementAndSubSizeToStoreStat(Transaction tx, KahaDestination kahaDestination, long size) throws IOException {</a>
<span class="sourceLineNo">2893</span><a id="line.2893">        StoredDestination sd = getStoredDestination(kahaDestination, tx);</a>
<span class="sourceLineNo">2894</span><a id="line.2894">        decrementAndSubSizeToStoreStat(tx, key(kahaDestination), sd,size);</a>
<span class="sourceLineNo">2895</span><a id="line.2895">    }</a>
<span class="sourceLineNo">2896</span><a id="line.2896"></a>
<span class="sourceLineNo">2897</span><a id="line.2897">    protected void decrementAndSubSizeToStoreStat(Transaction tx, String kahaDestKey, StoredDestination sd, long size) throws IOException {</a>
<span class="sourceLineNo">2898</span><a id="line.2898">        MessageStoreStatistics storeStats = getStoreStats(kahaDestKey);</a>
<span class="sourceLineNo">2899</span><a id="line.2899">        if (storeStats != null) {</a>
<span class="sourceLineNo">2900</span><a id="line.2900">            decrementAndSubSizeToStoreStat(size, storeStats);</a>
<span class="sourceLineNo">2901</span><a id="line.2901">            sd.messageStoreStatistics.put(tx, storeStats);</a>
<span class="sourceLineNo">2902</span><a id="line.2902">        } else if (sd != null){</a>
<span class="sourceLineNo">2903</span><a id="line.2903">            // During the recovery the storeStats is null</a>
<span class="sourceLineNo">2904</span><a id="line.2904">            MessageStoreStatistics storedStoreStats = sd.messageStoreStatistics.get(tx);</a>
<span class="sourceLineNo">2905</span><a id="line.2905">            if (storedStoreStats == null) {</a>
<span class="sourceLineNo">2906</span><a id="line.2906">                storedStoreStats = new MessageStoreStatistics();</a>
<span class="sourceLineNo">2907</span><a id="line.2907">            }</a>
<span class="sourceLineNo">2908</span><a id="line.2908">            decrementAndSubSizeToStoreStat(size, storedStoreStats);</a>
<span class="sourceLineNo">2909</span><a id="line.2909">            sd.messageStoreStatistics.put(tx, storedStoreStats);</a>
<span class="sourceLineNo">2910</span><a id="line.2910">        }</a>
<span class="sourceLineNo">2911</span><a id="line.2911">    }</a>
<span class="sourceLineNo">2912</span><a id="line.2912"></a>
<span class="sourceLineNo">2913</span><a id="line.2913">    private void decrementAndSubSizeToStoreStat(final long size, final MessageStoreStatistics storedStoreStats) {</a>
<span class="sourceLineNo">2914</span><a id="line.2914">        storedStoreStats.getMessageCount().decrement();</a>
<span class="sourceLineNo">2915</span><a id="line.2915"></a>
<span class="sourceLineNo">2916</span><a id="line.2916">        if (size &gt; 0) {</a>
<span class="sourceLineNo">2917</span><a id="line.2917">            storedStoreStats.getMessageSize().addSize(-size);</a>
<span class="sourceLineNo">2918</span><a id="line.2918">        }</a>
<span class="sourceLineNo">2919</span><a id="line.2919">    }</a>
<span class="sourceLineNo">2920</span><a id="line.2920"></a>
<span class="sourceLineNo">2921</span><a id="line.2921">    protected void incrementAndAddSizeToStoreStat(KahaDestination kahaDestination, String subKey, long size) {</a>
<span class="sourceLineNo">2922</span><a id="line.2922">        incrementAndAddSizeToStoreStat(key(kahaDestination), subKey, size);</a>
<span class="sourceLineNo">2923</span><a id="line.2923">    }</a>
<span class="sourceLineNo">2924</span><a id="line.2924"></a>
<span class="sourceLineNo">2925</span><a id="line.2925">    protected void incrementAndAddSizeToStoreStat(String kahaDestKey, String subKey, long size) {</a>
<span class="sourceLineNo">2926</span><a id="line.2926">        if (enableSubscriptionStatistics) {</a>
<span class="sourceLineNo">2927</span><a id="line.2927">            MessageStoreSubscriptionStatistics subStats = getSubStats(kahaDestKey);</a>
<span class="sourceLineNo">2928</span><a id="line.2928">            if (subStats != null &amp;&amp; subKey != null) {</a>
<span class="sourceLineNo">2929</span><a id="line.2929">                subStats.getMessageCount(subKey).increment();</a>
<span class="sourceLineNo">2930</span><a id="line.2930">                if (size &gt; 0) {</a>
<span class="sourceLineNo">2931</span><a id="line.2931">                    subStats.getMessageSize(subKey).addSize(size);</a>
<span class="sourceLineNo">2932</span><a id="line.2932">                }</a>
<span class="sourceLineNo">2933</span><a id="line.2933">            }</a>
<span class="sourceLineNo">2934</span><a id="line.2934">        }</a>
<span class="sourceLineNo">2935</span><a id="line.2935">    }</a>
<span class="sourceLineNo">2936</span><a id="line.2936"></a>
<span class="sourceLineNo">2937</span><a id="line.2937"></a>
<span class="sourceLineNo">2938</span><a id="line.2938">    protected void decrementAndSubSizeToStoreStat(String kahaDestKey, String subKey, long size) {</a>
<span class="sourceLineNo">2939</span><a id="line.2939">        if (enableSubscriptionStatistics) {</a>
<span class="sourceLineNo">2940</span><a id="line.2940">            MessageStoreSubscriptionStatistics subStats = getSubStats(kahaDestKey);</a>
<span class="sourceLineNo">2941</span><a id="line.2941">            if (subStats != null &amp;&amp; subKey != null) {</a>
<span class="sourceLineNo">2942</span><a id="line.2942">                subStats.getMessageCount(subKey).decrement();</a>
<span class="sourceLineNo">2943</span><a id="line.2943">                if (size &gt; 0) {</a>
<span class="sourceLineNo">2944</span><a id="line.2944">                    subStats.getMessageSize(subKey).addSize(-size);</a>
<span class="sourceLineNo">2945</span><a id="line.2945">                }</a>
<span class="sourceLineNo">2946</span><a id="line.2946">            }</a>
<span class="sourceLineNo">2947</span><a id="line.2947">        }</a>
<span class="sourceLineNo">2948</span><a id="line.2948">    }</a>
<span class="sourceLineNo">2949</span><a id="line.2949"></a>
<span class="sourceLineNo">2950</span><a id="line.2950">    protected void decrementAndSubSizeToStoreStat(KahaDestination kahaDestination, String subKey, long size) {</a>
<span class="sourceLineNo">2951</span><a id="line.2951">        decrementAndSubSizeToStoreStat(key(kahaDestination), subKey, size);</a>
<span class="sourceLineNo">2952</span><a id="line.2952">    }</a>
<span class="sourceLineNo">2953</span><a id="line.2953"></a>
<span class="sourceLineNo">2954</span><a id="line.2954">    /**</a>
<span class="sourceLineNo">2955</span><a id="line.2955">     * This is a map to cache MessageStores for a specific</a>
<span class="sourceLineNo">2956</span><a id="line.2956">     * KahaDestination key</a>
<span class="sourceLineNo">2957</span><a id="line.2957">     */</a>
<span class="sourceLineNo">2958</span><a id="line.2958">    protected final ConcurrentMap&lt;String, MessageStore&gt; storeCache =</a>
<span class="sourceLineNo">2959</span><a id="line.2959">            new ConcurrentHashMap&lt;&gt;();</a>
<span class="sourceLineNo">2960</span><a id="line.2960"></a>
<span class="sourceLineNo">2961</span><a id="line.2961">    /**</a>
<span class="sourceLineNo">2962</span><a id="line.2962">     * Locate the storeMessageSize counter for this KahaDestination</a>
<span class="sourceLineNo">2963</span><a id="line.2963">     */</a>
<span class="sourceLineNo">2964</span><a id="line.2964">    protected MessageStoreStatistics getStoreStats(String kahaDestKey) {</a>
<span class="sourceLineNo">2965</span><a id="line.2965">        MessageStoreStatistics storeStats = null;</a>
<span class="sourceLineNo">2966</span><a id="line.2966">        try {</a>
<span class="sourceLineNo">2967</span><a id="line.2967">            MessageStore messageStore = storeCache.get(kahaDestKey);</a>
<span class="sourceLineNo">2968</span><a id="line.2968">            if (messageStore != null) {</a>
<span class="sourceLineNo">2969</span><a id="line.2969">                storeStats = messageStore.getMessageStoreStatistics();</a>
<span class="sourceLineNo">2970</span><a id="line.2970">            }</a>
<span class="sourceLineNo">2971</span><a id="line.2971">        } catch (Exception e1) {</a>
<span class="sourceLineNo">2972</span><a id="line.2972">             LOG.error("Getting size counter of destination failed", e1);</a>
<span class="sourceLineNo">2973</span><a id="line.2973">        }</a>
<span class="sourceLineNo">2974</span><a id="line.2974"></a>
<span class="sourceLineNo">2975</span><a id="line.2975">        return storeStats;</a>
<span class="sourceLineNo">2976</span><a id="line.2976">    }</a>
<span class="sourceLineNo">2977</span><a id="line.2977"></a>
<span class="sourceLineNo">2978</span><a id="line.2978">    protected MessageStoreSubscriptionStatistics getSubStats(String kahaDestKey) {</a>
<span class="sourceLineNo">2979</span><a id="line.2979">        MessageStoreSubscriptionStatistics subStats = null;</a>
<span class="sourceLineNo">2980</span><a id="line.2980">        try {</a>
<span class="sourceLineNo">2981</span><a id="line.2981">            MessageStore messageStore = storeCache.get(kahaDestKey);</a>
<span class="sourceLineNo">2982</span><a id="line.2982">            if (messageStore instanceof TopicMessageStore) {</a>
<span class="sourceLineNo">2983</span><a id="line.2983">                subStats = ((TopicMessageStore)messageStore).getMessageStoreSubStatistics();</a>
<span class="sourceLineNo">2984</span><a id="line.2984">            }</a>
<span class="sourceLineNo">2985</span><a id="line.2985">        } catch (Exception e1) {</a>
<span class="sourceLineNo">2986</span><a id="line.2986">             LOG.error("Getting size counter of destination failed", e1);</a>
<span class="sourceLineNo">2987</span><a id="line.2987">        }</a>
<span class="sourceLineNo">2988</span><a id="line.2988"></a>
<span class="sourceLineNo">2989</span><a id="line.2989">        return subStats;</a>
<span class="sourceLineNo">2990</span><a id="line.2990">    }</a>
<span class="sourceLineNo">2991</span><a id="line.2991"></a>
<span class="sourceLineNo">2992</span><a id="line.2992">    /**</a>
<span class="sourceLineNo">2993</span><a id="line.2993">     * Determine whether this Destination matches the DestinationType</a>
<span class="sourceLineNo">2994</span><a id="line.2994">     *</a>
<span class="sourceLineNo">2995</span><a id="line.2995">     * @param destination</a>
<span class="sourceLineNo">2996</span><a id="line.2996">     * @param type</a>
<span class="sourceLineNo">2997</span><a id="line.2997">     * @return</a>
<span class="sourceLineNo">2998</span><a id="line.2998">     */</a>
<span class="sourceLineNo">2999</span><a id="line.2999">    protected boolean matchType(Destination destination,</a>
<span class="sourceLineNo">3000</span><a id="line.3000">            KahaDestination.DestinationType type) {</a>
<span class="sourceLineNo">3001</span><a id="line.3001">        if (destination instanceof Topic</a>
<span class="sourceLineNo">3002</span><a id="line.3002">                &amp;&amp; type.equals(KahaDestination.DestinationType.TOPIC)) {</a>
<span class="sourceLineNo">3003</span><a id="line.3003">            return true;</a>
<span class="sourceLineNo">3004</span><a id="line.3004">        } else if (destination instanceof Queue</a>
<span class="sourceLineNo">3005</span><a id="line.3005">                &amp;&amp; type.equals(KahaDestination.DestinationType.QUEUE)) {</a>
<span class="sourceLineNo">3006</span><a id="line.3006">            return true;</a>
<span class="sourceLineNo">3007</span><a id="line.3007">        }</a>
<span class="sourceLineNo">3008</span><a id="line.3008">        return false;</a>
<span class="sourceLineNo">3009</span><a id="line.3009">    }</a>
<span class="sourceLineNo">3010</span><a id="line.3010"></a>
<span class="sourceLineNo">3011</span><a id="line.3011">    class LocationSizeMarshaller implements Marshaller&lt;Location&gt; {</a>
<span class="sourceLineNo">3012</span><a id="line.3012"></a>
<span class="sourceLineNo">3013</span><a id="line.3013">        public LocationSizeMarshaller() {</a>
<span class="sourceLineNo">3014</span><a id="line.3014"></a>
<span class="sourceLineNo">3015</span><a id="line.3015">        }</a>
<span class="sourceLineNo">3016</span><a id="line.3016"></a>
<span class="sourceLineNo">3017</span><a id="line.3017">        @Override</a>
<span class="sourceLineNo">3018</span><a id="line.3018">        public Location readPayload(DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">3019</span><a id="line.3019">            Location rc = new Location();</a>
<span class="sourceLineNo">3020</span><a id="line.3020">            rc.setDataFileId(dataIn.readInt());</a>
<span class="sourceLineNo">3021</span><a id="line.3021">            rc.setOffset(dataIn.readInt());</a>
<span class="sourceLineNo">3022</span><a id="line.3022">            if (metadata.version &gt;= 6) {</a>
<span class="sourceLineNo">3023</span><a id="line.3023">                rc.setSize(dataIn.readInt());</a>
<span class="sourceLineNo">3024</span><a id="line.3024">            }</a>
<span class="sourceLineNo">3025</span><a id="line.3025">            return rc;</a>
<span class="sourceLineNo">3026</span><a id="line.3026">        }</a>
<span class="sourceLineNo">3027</span><a id="line.3027"></a>
<span class="sourceLineNo">3028</span><a id="line.3028">        @Override</a>
<span class="sourceLineNo">3029</span><a id="line.3029">        public void writePayload(Location object, DataOutput dataOut)</a>
<span class="sourceLineNo">3030</span><a id="line.3030">                throws IOException {</a>
<span class="sourceLineNo">3031</span><a id="line.3031">            dataOut.writeInt(object.getDataFileId());</a>
<span class="sourceLineNo">3032</span><a id="line.3032">            dataOut.writeInt(object.getOffset());</a>
<span class="sourceLineNo">3033</span><a id="line.3033">            dataOut.writeInt(object.getSize());</a>
<span class="sourceLineNo">3034</span><a id="line.3034">        }</a>
<span class="sourceLineNo">3035</span><a id="line.3035"></a>
<span class="sourceLineNo">3036</span><a id="line.3036">        @Override</a>
<span class="sourceLineNo">3037</span><a id="line.3037">        public int getFixedSize() {</a>
<span class="sourceLineNo">3038</span><a id="line.3038">            return 12;</a>
<span class="sourceLineNo">3039</span><a id="line.3039">        }</a>
<span class="sourceLineNo">3040</span><a id="line.3040"></a>
<span class="sourceLineNo">3041</span><a id="line.3041">        @Override</a>
<span class="sourceLineNo">3042</span><a id="line.3042">        public Location deepCopy(Location source) {</a>
<span class="sourceLineNo">3043</span><a id="line.3043">            return new Location(source);</a>
<span class="sourceLineNo">3044</span><a id="line.3044">        }</a>
<span class="sourceLineNo">3045</span><a id="line.3045"></a>
<span class="sourceLineNo">3046</span><a id="line.3046">        @Override</a>
<span class="sourceLineNo">3047</span><a id="line.3047">        public boolean isDeepCopySupported() {</a>
<span class="sourceLineNo">3048</span><a id="line.3048">            return true;</a>
<span class="sourceLineNo">3049</span><a id="line.3049">        }</a>
<span class="sourceLineNo">3050</span><a id="line.3050">    }</a>
<span class="sourceLineNo">3051</span><a id="line.3051"></a>
<span class="sourceLineNo">3052</span><a id="line.3052">    private void addAckLocation(Transaction tx, StoredDestination sd, Long messageSequence, String subscriptionKey) throws IOException {</a>
<span class="sourceLineNo">3053</span><a id="line.3053">        SequenceSet sequences = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3054</span><a id="line.3054">        if (sequences == null) {</a>
<span class="sourceLineNo">3055</span><a id="line.3055">            sequences = new SequenceSet();</a>
<span class="sourceLineNo">3056</span><a id="line.3056">            sequences.add(messageSequence);</a>
<span class="sourceLineNo">3057</span><a id="line.3057">            sd.ackPositions.add(tx, subscriptionKey, sequences);</a>
<span class="sourceLineNo">3058</span><a id="line.3058">        } else {</a>
<span class="sourceLineNo">3059</span><a id="line.3059">            sequences.add(messageSequence);</a>
<span class="sourceLineNo">3060</span><a id="line.3060">            sd.ackPositions.put(tx, subscriptionKey, sequences);</a>
<span class="sourceLineNo">3061</span><a id="line.3061">        }</a>
<span class="sourceLineNo">3062</span><a id="line.3062">    }</a>
<span class="sourceLineNo">3063</span><a id="line.3063"></a>
<span class="sourceLineNo">3064</span><a id="line.3064">    // new sub is interested in potentially all existing messages</a>
<span class="sourceLineNo">3065</span><a id="line.3065">    private void addAckLocationForRetroactiveSub(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {</a>
<span class="sourceLineNo">3066</span><a id="line.3066">        SequenceSet allOutstanding = new SequenceSet();</a>
<span class="sourceLineNo">3067</span><a id="line.3067">        Iterator&lt;Map.Entry&lt;String, SequenceSet&gt;&gt; iterator = sd.ackPositions.iterator(tx);</a>
<span class="sourceLineNo">3068</span><a id="line.3068">        while (iterator.hasNext()) {</a>
<span class="sourceLineNo">3069</span><a id="line.3069">            SequenceSet set = iterator.next().getValue();</a>
<span class="sourceLineNo">3070</span><a id="line.3070">            for (Long entry : set) {</a>
<span class="sourceLineNo">3071</span><a id="line.3071">                allOutstanding.add(entry);</a>
<span class="sourceLineNo">3072</span><a id="line.3072">            }</a>
<span class="sourceLineNo">3073</span><a id="line.3073">        }</a>
<span class="sourceLineNo">3074</span><a id="line.3074">        sd.ackPositions.put(tx, subscriptionKey, allOutstanding);</a>
<span class="sourceLineNo">3075</span><a id="line.3075">    }</a>
<span class="sourceLineNo">3076</span><a id="line.3076"></a>
<span class="sourceLineNo">3077</span><a id="line.3077">    // on a new message add, all existing subs are interested in this message</a>
<span class="sourceLineNo">3078</span><a id="line.3078">    private void addAckLocationForNewMessage(Transaction tx, KahaDestination kahaDest,</a>
<span class="sourceLineNo">3079</span><a id="line.3079">            StoredDestination sd, Long messageSequence) throws IOException {</a>
<span class="sourceLineNo">3080</span><a id="line.3080">        for(String subscriptionKey : sd.subscriptionCache) {</a>
<span class="sourceLineNo">3081</span><a id="line.3081">            SequenceSet sequences = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3082</span><a id="line.3082">            if (sequences == null) {</a>
<span class="sourceLineNo">3083</span><a id="line.3083">                sequences = new SequenceSet();</a>
<span class="sourceLineNo">3084</span><a id="line.3084">                sequences.add(new Sequence(messageSequence, messageSequence + 1));</a>
<span class="sourceLineNo">3085</span><a id="line.3085">                sd.ackPositions.add(tx, subscriptionKey, sequences);</a>
<span class="sourceLineNo">3086</span><a id="line.3086">            } else {</a>
<span class="sourceLineNo">3087</span><a id="line.3087">                sequences.add(new Sequence(messageSequence, messageSequence + 1));</a>
<span class="sourceLineNo">3088</span><a id="line.3088">                sd.ackPositions.put(tx, subscriptionKey, sequences);</a>
<span class="sourceLineNo">3089</span><a id="line.3089">            }</a>
<span class="sourceLineNo">3090</span><a id="line.3090"></a>
<span class="sourceLineNo">3091</span><a id="line.3091">            MessageKeys key = sd.orderIndex.get(tx, messageSequence);</a>
<span class="sourceLineNo">3092</span><a id="line.3092">            incrementAndAddSizeToStoreStat(kahaDest, subscriptionKey, key.location.getSize());</a>
<span class="sourceLineNo">3093</span><a id="line.3093">        }</a>
<span class="sourceLineNo">3094</span><a id="line.3094">    }</a>
<span class="sourceLineNo">3095</span><a id="line.3095"></a>
<span class="sourceLineNo">3096</span><a id="line.3096">    private void removeAckLocationsForSub(KahaSubscriptionCommand command,</a>
<span class="sourceLineNo">3097</span><a id="line.3097">            Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {</a>
<span class="sourceLineNo">3098</span><a id="line.3098">        if (!sd.ackPositions.isEmpty(tx)) {</a>
<span class="sourceLineNo">3099</span><a id="line.3099">            SequenceSet sequences = sd.ackPositions.remove(tx, subscriptionKey);</a>
<span class="sourceLineNo">3100</span><a id="line.3100">            if (sequences == null || sequences.isEmpty()) {</a>
<span class="sourceLineNo">3101</span><a id="line.3101">                return;</a>
<span class="sourceLineNo">3102</span><a id="line.3102">            }</a>
<span class="sourceLineNo">3103</span><a id="line.3103"></a>
<span class="sourceLineNo">3104</span><a id="line.3104">            ArrayList&lt;Long&gt; unreferenced = new ArrayList&lt;&gt;();</a>
<span class="sourceLineNo">3105</span><a id="line.3105"></a>
<span class="sourceLineNo">3106</span><a id="line.3106">            for(Long sequenceId : sequences) {</a>
<span class="sourceLineNo">3107</span><a id="line.3107">                if(!isSequenceReferenced(tx, sd, sequenceId)) {</a>
<span class="sourceLineNo">3108</span><a id="line.3108">                    unreferenced.add(sequenceId);</a>
<span class="sourceLineNo">3109</span><a id="line.3109">                }</a>
<span class="sourceLineNo">3110</span><a id="line.3110">            }</a>
<span class="sourceLineNo">3111</span><a id="line.3111"></a>
<span class="sourceLineNo">3112</span><a id="line.3112">            for(Long sequenceId : unreferenced) {</a>
<span class="sourceLineNo">3113</span><a id="line.3113">                // Find all the entries that need to get deleted.</a>
<span class="sourceLineNo">3114</span><a id="line.3114">                ArrayList&lt;Entry&lt;Long, MessageKeys&gt;&gt; deletes = new ArrayList&lt;&gt;();</a>
<span class="sourceLineNo">3115</span><a id="line.3115">                sd.orderIndex.getDeleteList(tx, deletes, sequenceId);</a>
<span class="sourceLineNo">3116</span><a id="line.3116"></a>
<span class="sourceLineNo">3117</span><a id="line.3117">                // Do the actual deletes.</a>
<span class="sourceLineNo">3118</span><a id="line.3118">                for (Entry&lt;Long, MessageKeys&gt; entry : deletes) {</a>
<span class="sourceLineNo">3119</span><a id="line.3119">                    sd.locationIndex.remove(tx, entry.getValue().location);</a>
<span class="sourceLineNo">3120</span><a id="line.3120">                    sd.messageIdIndex.remove(tx, entry.getValue().messageId);</a>
<span class="sourceLineNo">3121</span><a id="line.3121">                    sd.orderIndex.remove(tx, entry.getKey());</a>
<span class="sourceLineNo">3122</span><a id="line.3122">                    decrementAndSubSizeToStoreStat(tx, command.getDestination(), entry.getValue().location.getSize());</a>
<span class="sourceLineNo">3123</span><a id="line.3123">                }</a>
<span class="sourceLineNo">3124</span><a id="line.3124">            }</a>
<span class="sourceLineNo">3125</span><a id="line.3125">        }</a>
<span class="sourceLineNo">3126</span><a id="line.3126">    }</a>
<span class="sourceLineNo">3127</span><a id="line.3127"></a>
<span class="sourceLineNo">3128</span><a id="line.3128">    private boolean isSequenceReferenced(final Transaction tx, final StoredDestination sd, final Long sequenceId) throws IOException {</a>
<span class="sourceLineNo">3129</span><a id="line.3129">        for(String subscriptionKey : sd.subscriptionCache) {</a>
<span class="sourceLineNo">3130</span><a id="line.3130">            SequenceSet sequence = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3131</span><a id="line.3131">            if (sequence != null &amp;&amp; sequence.contains(sequenceId)) {</a>
<span class="sourceLineNo">3132</span><a id="line.3132">                return true;</a>
<span class="sourceLineNo">3133</span><a id="line.3133">            }</a>
<span class="sourceLineNo">3134</span><a id="line.3134">        }</a>
<span class="sourceLineNo">3135</span><a id="line.3135">        return false;</a>
<span class="sourceLineNo">3136</span><a id="line.3136">    }</a>
<span class="sourceLineNo">3137</span><a id="line.3137"></a>
<span class="sourceLineNo">3138</span><a id="line.3138">    /**</a>
<span class="sourceLineNo">3139</span><a id="line.3139">     * @param tx</a>
<span class="sourceLineNo">3140</span><a id="line.3140">     * @param sd</a>
<span class="sourceLineNo">3141</span><a id="line.3141">     * @param subscriptionKey</a>
<span class="sourceLineNo">3142</span><a id="line.3142">     * @param messageSequence</a>
<span class="sourceLineNo">3143</span><a id="line.3143">     * @throws IOException</a>
<span class="sourceLineNo">3144</span><a id="line.3144">     */</a>
<span class="sourceLineNo">3145</span><a id="line.3145">    private void removeAckLocation(KahaRemoveMessageCommand command,</a>
<span class="sourceLineNo">3146</span><a id="line.3146">            Transaction tx, StoredDestination sd, String subscriptionKey,</a>
<span class="sourceLineNo">3147</span><a id="line.3147">            Long messageSequence) throws IOException {</a>
<span class="sourceLineNo">3148</span><a id="line.3148">        // Remove the sub from the previous location set..</a>
<span class="sourceLineNo">3149</span><a id="line.3149">        if (messageSequence != null) {</a>
<span class="sourceLineNo">3150</span><a id="line.3150">            SequenceSet range = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3151</span><a id="line.3151">            if (range != null &amp;&amp; !range.isEmpty()) {</a>
<span class="sourceLineNo">3152</span><a id="line.3152">                range.remove(messageSequence);</a>
<span class="sourceLineNo">3153</span><a id="line.3153">                if (!range.isEmpty()) {</a>
<span class="sourceLineNo">3154</span><a id="line.3154">                    sd.ackPositions.put(tx, subscriptionKey, range);</a>
<span class="sourceLineNo">3155</span><a id="line.3155">                } else {</a>
<span class="sourceLineNo">3156</span><a id="line.3156">                    sd.ackPositions.remove(tx, subscriptionKey);</a>
<span class="sourceLineNo">3157</span><a id="line.3157">                }</a>
<span class="sourceLineNo">3158</span><a id="line.3158"></a>
<span class="sourceLineNo">3159</span><a id="line.3159">                MessageKeys key = sd.orderIndex.get(tx, messageSequence);</a>
<span class="sourceLineNo">3160</span><a id="line.3160">                decrementAndSubSizeToStoreStat(command.getDestination(), subscriptionKey,</a>
<span class="sourceLineNo">3161</span><a id="line.3161">                        key.location.getSize());</a>
<span class="sourceLineNo">3162</span><a id="line.3162"></a>
<span class="sourceLineNo">3163</span><a id="line.3163">                // Check if the message is reference by any other subscription.</a>
<span class="sourceLineNo">3164</span><a id="line.3164">                if (isSequenceReferenced(tx, sd, messageSequence)) {</a>
<span class="sourceLineNo">3165</span><a id="line.3165">                    return;</a>
<span class="sourceLineNo">3166</span><a id="line.3166">                }</a>
<span class="sourceLineNo">3167</span><a id="line.3167">                // Find all the entries that need to get deleted.</a>
<span class="sourceLineNo">3168</span><a id="line.3168">                ArrayList&lt;Entry&lt;Long, MessageKeys&gt;&gt; deletes = new ArrayList&lt;&gt;();</a>
<span class="sourceLineNo">3169</span><a id="line.3169">                sd.orderIndex.getDeleteList(tx, deletes, messageSequence);</a>
<span class="sourceLineNo">3170</span><a id="line.3170"></a>
<span class="sourceLineNo">3171</span><a id="line.3171">                // Do the actual deletes.</a>
<span class="sourceLineNo">3172</span><a id="line.3172">                for (Entry&lt;Long, MessageKeys&gt; entry : deletes) {</a>
<span class="sourceLineNo">3173</span><a id="line.3173">                    sd.locationIndex.remove(tx, entry.getValue().location);</a>
<span class="sourceLineNo">3174</span><a id="line.3174">                    sd.messageIdIndex.remove(tx, entry.getValue().messageId);</a>
<span class="sourceLineNo">3175</span><a id="line.3175">                    sd.orderIndex.remove(tx, entry.getKey());</a>
<span class="sourceLineNo">3176</span><a id="line.3176">                    decrementAndSubSizeToStoreStat(tx, command.getDestination(), entry.getValue().location.getSize());</a>
<span class="sourceLineNo">3177</span><a id="line.3177">                }</a>
<span class="sourceLineNo">3178</span><a id="line.3178">            }</a>
<span class="sourceLineNo">3179</span><a id="line.3179">        }</a>
<span class="sourceLineNo">3180</span><a id="line.3180">    }</a>
<span class="sourceLineNo">3181</span><a id="line.3181"></a>
<span class="sourceLineNo">3182</span><a id="line.3182">    public LastAck getLastAck(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {</a>
<span class="sourceLineNo">3183</span><a id="line.3183">        return sd.subscriptionAcks.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3184</span><a id="line.3184">    }</a>
<span class="sourceLineNo">3185</span><a id="line.3185"></a>
<span class="sourceLineNo">3186</span><a id="line.3186">    protected SequenceSet getSequenceSet(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {</a>
<span class="sourceLineNo">3187</span><a id="line.3187">        if (sd.ackPositions != null) {</a>
<span class="sourceLineNo">3188</span><a id="line.3188">            final SequenceSet messageSequences = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3189</span><a id="line.3189">            return messageSequences;</a>
<span class="sourceLineNo">3190</span><a id="line.3190">        }</a>
<span class="sourceLineNo">3191</span><a id="line.3191"></a>
<span class="sourceLineNo">3192</span><a id="line.3192">        return null;</a>
<span class="sourceLineNo">3193</span><a id="line.3193">    }</a>
<span class="sourceLineNo">3194</span><a id="line.3194"></a>
<span class="sourceLineNo">3195</span><a id="line.3195">    protected long getStoredMessageCount(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {</a>
<span class="sourceLineNo">3196</span><a id="line.3196">        if (sd.ackPositions != null) {</a>
<span class="sourceLineNo">3197</span><a id="line.3197">            SequenceSet messageSequences = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3198</span><a id="line.3198">            if (messageSequences != null) {</a>
<span class="sourceLineNo">3199</span><a id="line.3199">                long result = messageSequences.rangeSize();</a>
<span class="sourceLineNo">3200</span><a id="line.3200">                // if there's anything in the range the last value is always the nextMessage marker, so remove 1.</a>
<span class="sourceLineNo">3201</span><a id="line.3201">                return result &gt; 0 ? result - 1 : 0;</a>
<span class="sourceLineNo">3202</span><a id="line.3202">            }</a>
<span class="sourceLineNo">3203</span><a id="line.3203">        }</a>
<span class="sourceLineNo">3204</span><a id="line.3204"></a>
<span class="sourceLineNo">3205</span><a id="line.3205">        return 0;</a>
<span class="sourceLineNo">3206</span><a id="line.3206">    }</a>
<span class="sourceLineNo">3207</span><a id="line.3207"></a>
<span class="sourceLineNo">3208</span><a id="line.3208">    /**</a>
<span class="sourceLineNo">3209</span><a id="line.3209">     * Recovers durable subscription pending message size with only 1 pass over the order index on recovery</a>
<span class="sourceLineNo">3210</span><a id="line.3210">     * instead of iterating over the index once per subscription</a>
<span class="sourceLineNo">3211</span><a id="line.3211">     *</a>
<span class="sourceLineNo">3212</span><a id="line.3212">     * @param tx</a>
<span class="sourceLineNo">3213</span><a id="line.3213">     * @param sd</a>
<span class="sourceLineNo">3214</span><a id="line.3214">     * @param subscriptionKeys</a>
<span class="sourceLineNo">3215</span><a id="line.3215">     * @return</a>
<span class="sourceLineNo">3216</span><a id="line.3216">     * @throws IOException</a>
<span class="sourceLineNo">3217</span><a id="line.3217">     */</a>
<span class="sourceLineNo">3218</span><a id="line.3218">    protected Map&lt;String, AtomicLong&gt; getStoredMessageSize(Transaction tx, StoredDestination sd, List&lt;String&gt; subscriptionKeys) throws IOException {</a>
<span class="sourceLineNo">3219</span><a id="line.3219"></a>
<span class="sourceLineNo">3220</span><a id="line.3220">        final Map&lt;String, AtomicLong&gt; subPendingMessageSizes = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">3221</span><a id="line.3221">        final Map&lt;String, SequenceSet&gt; messageSequencesMap = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">3222</span><a id="line.3222"></a>
<span class="sourceLineNo">3223</span><a id="line.3223">        if (sd.ackPositions != null) {</a>
<span class="sourceLineNo">3224</span><a id="line.3224">            Long recoveryPosition = null;</a>
<span class="sourceLineNo">3225</span><a id="line.3225">            //Go through each subscription and find matching ackPositions and their first</a>
<span class="sourceLineNo">3226</span><a id="line.3226">            //position to find the initial recovery position which is the first message across all subs</a>
<span class="sourceLineNo">3227</span><a id="line.3227">            //that needs to still be acked</a>
<span class="sourceLineNo">3228</span><a id="line.3228">            for (String subscriptionKey : subscriptionKeys) {</a>
<span class="sourceLineNo">3229</span><a id="line.3229">                subPendingMessageSizes.put(subscriptionKey, new AtomicLong());</a>
<span class="sourceLineNo">3230</span><a id="line.3230">                final SequenceSet messageSequences = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3231</span><a id="line.3231">                if (messageSequences != null &amp;&amp; !messageSequences.isEmpty()) {</a>
<span class="sourceLineNo">3232</span><a id="line.3232">                    final long head = messageSequences.getHead().getFirst();</a>
<span class="sourceLineNo">3233</span><a id="line.3233">                    recoveryPosition = recoveryPosition != null ? Math.min(recoveryPosition, head) : head;</a>
<span class="sourceLineNo">3234</span><a id="line.3234">                    //cache the SequenceSet to speed up recovery of metrics below and avoid a second index hit</a>
<span class="sourceLineNo">3235</span><a id="line.3235">                    messageSequencesMap.put(subscriptionKey, messageSequences);</a>
<span class="sourceLineNo">3236</span><a id="line.3236">                }</a>
<span class="sourceLineNo">3237</span><a id="line.3237">            }</a>
<span class="sourceLineNo">3238</span><a id="line.3238">            recoveryPosition = recoveryPosition != null ? recoveryPosition : 0;</a>
<span class="sourceLineNo">3239</span><a id="line.3239"></a>
<span class="sourceLineNo">3240</span><a id="line.3240">            final Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt; iterator = sd.orderIndex.iterator(tx,</a>
<span class="sourceLineNo">3241</span><a id="line.3241">                    new MessageOrderCursor(recoveryPosition));</a>
<span class="sourceLineNo">3242</span><a id="line.3242"></a>
<span class="sourceLineNo">3243</span><a id="line.3243">            //iterate through all messages starting at the recovery position to recover metrics</a>
<span class="sourceLineNo">3244</span><a id="line.3244">            while (iterator.hasNext()) {</a>
<span class="sourceLineNo">3245</span><a id="line.3245">                final Entry&lt;Long, MessageKeys&gt; messageEntry = iterator.next();</a>
<span class="sourceLineNo">3246</span><a id="line.3246"></a>
<span class="sourceLineNo">3247</span><a id="line.3247">                //For each message in the index check if each subscription needs to ack the message still</a>
<span class="sourceLineNo">3248</span><a id="line.3248">                //if the ackPositions SequenceSet contains the message then it has not been acked and should be</a>
<span class="sourceLineNo">3249</span><a id="line.3249">                //added to the pending metrics for that subscription</a>
<span class="sourceLineNo">3250</span><a id="line.3250">                for (Entry&lt;String, SequenceSet&gt; seqEntry : messageSequencesMap.entrySet()) {</a>
<span class="sourceLineNo">3251</span><a id="line.3251">                    final String subscriptionKey = seqEntry.getKey();</a>
<span class="sourceLineNo">3252</span><a id="line.3252">                    final SequenceSet messageSequences = messageSequencesMap.get(subscriptionKey);</a>
<span class="sourceLineNo">3253</span><a id="line.3253">                    if (messageSequences.contains(messageEntry.getKey())) {</a>
<span class="sourceLineNo">3254</span><a id="line.3254">                        subPendingMessageSizes.get(subscriptionKey).addAndGet(messageEntry.getValue().location.getSize());</a>
<span class="sourceLineNo">3255</span><a id="line.3255">                    }</a>
<span class="sourceLineNo">3256</span><a id="line.3256">                }</a>
<span class="sourceLineNo">3257</span><a id="line.3257">            }</a>
<span class="sourceLineNo">3258</span><a id="line.3258">        }</a>
<span class="sourceLineNo">3259</span><a id="line.3259"></a>
<span class="sourceLineNo">3260</span><a id="line.3260">        return subPendingMessageSizes;</a>
<span class="sourceLineNo">3261</span><a id="line.3261">    }</a>
<span class="sourceLineNo">3262</span><a id="line.3262"></a>
<span class="sourceLineNo">3263</span><a id="line.3263">    protected long getStoredMessageSize(Transaction tx, StoredDestination sd, String subscriptionKey) throws IOException {</a>
<span class="sourceLineNo">3264</span><a id="line.3264">        long locationSize = 0;</a>
<span class="sourceLineNo">3265</span><a id="line.3265"></a>
<span class="sourceLineNo">3266</span><a id="line.3266">        if (sd.ackPositions != null) {</a>
<span class="sourceLineNo">3267</span><a id="line.3267">            //grab the messages attached to this subscription</a>
<span class="sourceLineNo">3268</span><a id="line.3268">            SequenceSet messageSequences = sd.ackPositions.get(tx, subscriptionKey);</a>
<span class="sourceLineNo">3269</span><a id="line.3269"></a>
<span class="sourceLineNo">3270</span><a id="line.3270">            if (messageSequences != null &amp;&amp; !messageSequences.isEmpty()) {</a>
<span class="sourceLineNo">3271</span><a id="line.3271">                final Sequence head = messageSequences.getHead();</a>
<span class="sourceLineNo">3272</span><a id="line.3272"></a>
<span class="sourceLineNo">3273</span><a id="line.3273">                //get an iterator over the order index starting at the first unacked message</a>
<span class="sourceLineNo">3274</span><a id="line.3274">                //and go over each message to add up the size</a>
<span class="sourceLineNo">3275</span><a id="line.3275">                Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt; iterator = sd.orderIndex.iterator(tx,</a>
<span class="sourceLineNo">3276</span><a id="line.3276">                        new MessageOrderCursor(head.getFirst()));</a>
<span class="sourceLineNo">3277</span><a id="line.3277"></a>
<span class="sourceLineNo">3278</span><a id="line.3278">                final boolean contiguousRange = messageSequences.size() == 1;</a>
<span class="sourceLineNo">3279</span><a id="line.3279">                while (iterator.hasNext()) {</a>
<span class="sourceLineNo">3280</span><a id="line.3280">                    Entry&lt;Long, MessageKeys&gt; entry = iterator.next();</a>
<span class="sourceLineNo">3281</span><a id="line.3281">                    //Verify sequence contains the key</a>
<span class="sourceLineNo">3282</span><a id="line.3282">                    //if contiguous we just add all starting with the first but if not</a>
<span class="sourceLineNo">3283</span><a id="line.3283">                    //we need to check if the id is part of the range - could happen if individual ack mode was used</a>
<span class="sourceLineNo">3284</span><a id="line.3284">                    if (contiguousRange || messageSequences.contains(entry.getKey())) {</a>
<span class="sourceLineNo">3285</span><a id="line.3285">                        locationSize += entry.getValue().location.getSize();</a>
<span class="sourceLineNo">3286</span><a id="line.3286">                    }</a>
<span class="sourceLineNo">3287</span><a id="line.3287">                }</a>
<span class="sourceLineNo">3288</span><a id="line.3288">            }</a>
<span class="sourceLineNo">3289</span><a id="line.3289">        }</a>
<span class="sourceLineNo">3290</span><a id="line.3290"></a>
<span class="sourceLineNo">3291</span><a id="line.3291">        return locationSize;</a>
<span class="sourceLineNo">3292</span><a id="line.3292">    }</a>
<span class="sourceLineNo">3293</span><a id="line.3293"></a>
<span class="sourceLineNo">3294</span><a id="line.3294">    protected String key(KahaDestination destination) {</a>
<span class="sourceLineNo">3295</span><a id="line.3295">        return destination.getType().getNumber() + ":" + destination.getName();</a>
<span class="sourceLineNo">3296</span><a id="line.3296">    }</a>
<span class="sourceLineNo">3297</span><a id="line.3297"></a>
<span class="sourceLineNo">3298</span><a id="line.3298">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">3299</span><a id="line.3299">    // Transaction related implementation methods.</a>
<span class="sourceLineNo">3300</span><a id="line.3300">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">3301</span><a id="line.3301">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">3302</span><a id="line.3302">    private final LinkedHashMap&lt;TransactionId, List&lt;Operation&gt;&gt; inflightTransactions = new LinkedHashMap&lt;&gt;();</a>
<span class="sourceLineNo">3303</span><a id="line.3303">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">3304</span><a id="line.3304">    protected final LinkedHashMap&lt;TransactionId, List&lt;Operation&gt;&gt; preparedTransactions = new LinkedHashMap&lt;&gt;();</a>
<span class="sourceLineNo">3305</span><a id="line.3305"></a>
<span class="sourceLineNo">3306</span><a id="line.3306">    @SuppressWarnings("rawtypes")</a>
<span class="sourceLineNo">3307</span><a id="line.3307">    private List&lt;Operation&gt; getInflightTx(KahaTransactionInfo info) {</a>
<span class="sourceLineNo">3308</span><a id="line.3308">        TransactionId key = TransactionIdConversion.convert(info);</a>
<span class="sourceLineNo">3309</span><a id="line.3309">        List&lt;Operation&gt; tx;</a>
<span class="sourceLineNo">3310</span><a id="line.3310">        synchronized (inflightTransactions) {</a>
<span class="sourceLineNo">3311</span><a id="line.3311">            tx = inflightTransactions.get(key);</a>
<span class="sourceLineNo">3312</span><a id="line.3312">            if (tx == null) {</a>
<span class="sourceLineNo">3313</span><a id="line.3313">                tx = Collections.synchronizedList(new ArrayList&lt;Operation&gt;());</a>
<span class="sourceLineNo">3314</span><a id="line.3314">                inflightTransactions.put(key, tx);</a>
<span class="sourceLineNo">3315</span><a id="line.3315">            }</a>
<span class="sourceLineNo">3316</span><a id="line.3316">        }</a>
<span class="sourceLineNo">3317</span><a id="line.3317">        return tx;</a>
<span class="sourceLineNo">3318</span><a id="line.3318">    }</a>
<span class="sourceLineNo">3319</span><a id="line.3319"></a>
<span class="sourceLineNo">3320</span><a id="line.3320">    @SuppressWarnings("unused")</a>
<span class="sourceLineNo">3321</span><a id="line.3321">    private TransactionId key(KahaTransactionInfo transactionInfo) {</a>
<span class="sourceLineNo">3322</span><a id="line.3322">        return TransactionIdConversion.convert(transactionInfo);</a>
<span class="sourceLineNo">3323</span><a id="line.3323">    }</a>
<span class="sourceLineNo">3324</span><a id="line.3324"></a>
<span class="sourceLineNo">3325</span><a id="line.3325">    abstract class Operation &lt;T extends JournalCommand&lt;T&gt;&gt; {</a>
<span class="sourceLineNo">3326</span><a id="line.3326">        final T command;</a>
<span class="sourceLineNo">3327</span><a id="line.3327">        final Location location;</a>
<span class="sourceLineNo">3328</span><a id="line.3328"></a>
<span class="sourceLineNo">3329</span><a id="line.3329">        public Operation(T command, Location location) {</a>
<span class="sourceLineNo">3330</span><a id="line.3330">            this.command = command;</a>
<span class="sourceLineNo">3331</span><a id="line.3331">            this.location = location;</a>
<span class="sourceLineNo">3332</span><a id="line.3332">        }</a>
<span class="sourceLineNo">3333</span><a id="line.3333"></a>
<span class="sourceLineNo">3334</span><a id="line.3334">        public Location getLocation() {</a>
<span class="sourceLineNo">3335</span><a id="line.3335">            return location;</a>
<span class="sourceLineNo">3336</span><a id="line.3336">        }</a>
<span class="sourceLineNo">3337</span><a id="line.3337"></a>
<span class="sourceLineNo">3338</span><a id="line.3338">        public T getCommand() {</a>
<span class="sourceLineNo">3339</span><a id="line.3339">            return command;</a>
<span class="sourceLineNo">3340</span><a id="line.3340">        }</a>
<span class="sourceLineNo">3341</span><a id="line.3341"></a>
<span class="sourceLineNo">3342</span><a id="line.3342">        abstract public void execute(Transaction tx) throws IOException;</a>
<span class="sourceLineNo">3343</span><a id="line.3343">    }</a>
<span class="sourceLineNo">3344</span><a id="line.3344"></a>
<span class="sourceLineNo">3345</span><a id="line.3345">    class AddOperation extends Operation&lt;KahaAddMessageCommand&gt; {</a>
<span class="sourceLineNo">3346</span><a id="line.3346">        final IndexAware runWithIndexLock;</a>
<span class="sourceLineNo">3347</span><a id="line.3347">        public AddOperation(KahaAddMessageCommand command, Location location, IndexAware runWithIndexLock) {</a>
<span class="sourceLineNo">3348</span><a id="line.3348">            super(command, location);</a>
<span class="sourceLineNo">3349</span><a id="line.3349">            this.runWithIndexLock = runWithIndexLock;</a>
<span class="sourceLineNo">3350</span><a id="line.3350">        }</a>
<span class="sourceLineNo">3351</span><a id="line.3351"></a>
<span class="sourceLineNo">3352</span><a id="line.3352">        @Override</a>
<span class="sourceLineNo">3353</span><a id="line.3353">        public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3354</span><a id="line.3354">            long seq = updateIndex(tx, command, location);</a>
<span class="sourceLineNo">3355</span><a id="line.3355">            if (runWithIndexLock != null) {</a>
<span class="sourceLineNo">3356</span><a id="line.3356">                runWithIndexLock.sequenceAssignedWithIndexLocked(seq);</a>
<span class="sourceLineNo">3357</span><a id="line.3357">            }</a>
<span class="sourceLineNo">3358</span><a id="line.3358">        }</a>
<span class="sourceLineNo">3359</span><a id="line.3359">    }</a>
<span class="sourceLineNo">3360</span><a id="line.3360"></a>
<span class="sourceLineNo">3361</span><a id="line.3361">    class RemoveOperation extends Operation&lt;KahaRemoveMessageCommand&gt; {</a>
<span class="sourceLineNo">3362</span><a id="line.3362"></a>
<span class="sourceLineNo">3363</span><a id="line.3363">        public RemoveOperation(KahaRemoveMessageCommand command, Location location) {</a>
<span class="sourceLineNo">3364</span><a id="line.3364">            super(command, location);</a>
<span class="sourceLineNo">3365</span><a id="line.3365">        }</a>
<span class="sourceLineNo">3366</span><a id="line.3366"></a>
<span class="sourceLineNo">3367</span><a id="line.3367">        @Override</a>
<span class="sourceLineNo">3368</span><a id="line.3368">        public void execute(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3369</span><a id="line.3369">            updateIndex(tx, command, location);</a>
<span class="sourceLineNo">3370</span><a id="line.3370">        }</a>
<span class="sourceLineNo">3371</span><a id="line.3371">    }</a>
<span class="sourceLineNo">3372</span><a id="line.3372"></a>
<span class="sourceLineNo">3373</span><a id="line.3373">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">3374</span><a id="line.3374">    // Initialization related implementation methods.</a>
<span class="sourceLineNo">3375</span><a id="line.3375">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">3376</span><a id="line.3376"></a>
<span class="sourceLineNo">3377</span><a id="line.3377">    private PageFile createPageFile() throws IOException {</a>
<span class="sourceLineNo">3378</span><a id="line.3378">        if (indexDirectory == null) {</a>
<span class="sourceLineNo">3379</span><a id="line.3379">            indexDirectory = directory;</a>
<span class="sourceLineNo">3380</span><a id="line.3380">        }</a>
<span class="sourceLineNo">3381</span><a id="line.3381">        IOHelper.mkdirs(indexDirectory);</a>
<span class="sourceLineNo">3382</span><a id="line.3382">        PageFile index = new PageFile(indexDirectory, "db");</a>
<span class="sourceLineNo">3383</span><a id="line.3383">        index.setEnableWriteThread(isEnableIndexWriteAsync());</a>
<span class="sourceLineNo">3384</span><a id="line.3384">        index.setWriteBatchSize(getIndexWriteBatchSize());</a>
<span class="sourceLineNo">3385</span><a id="line.3385">        index.setPageCacheSize(indexCacheSize);</a>
<span class="sourceLineNo">3386</span><a id="line.3386">        index.setUseLFRUEviction(isUseIndexLFRUEviction());</a>
<span class="sourceLineNo">3387</span><a id="line.3387">        index.setLFUEvictionFactor(getIndexLFUEvictionFactor());</a>
<span class="sourceLineNo">3388</span><a id="line.3388">        index.setEnableDiskSyncs(isEnableIndexDiskSyncs());</a>
<span class="sourceLineNo">3389</span><a id="line.3389">        index.setEnableRecoveryFile(isEnableIndexRecoveryFile());</a>
<span class="sourceLineNo">3390</span><a id="line.3390">        index.setEnablePageCaching(isEnableIndexPageCaching());</a>
<span class="sourceLineNo">3391</span><a id="line.3391">        return index;</a>
<span class="sourceLineNo">3392</span><a id="line.3392">    }</a>
<span class="sourceLineNo">3393</span><a id="line.3393"></a>
<span class="sourceLineNo">3394</span><a id="line.3394">    protected Journal createJournal() throws IOException {</a>
<span class="sourceLineNo">3395</span><a id="line.3395">        Journal manager = new Journal();</a>
<span class="sourceLineNo">3396</span><a id="line.3396">        manager.setDirectory(directory);</a>
<span class="sourceLineNo">3397</span><a id="line.3397">        manager.setMaxFileLength(getJournalMaxFileLength());</a>
<span class="sourceLineNo">3398</span><a id="line.3398">        manager.setCheckForCorruptionOnStartup(checkForCorruptJournalFiles);</a>
<span class="sourceLineNo">3399</span><a id="line.3399">        manager.setChecksum(checksumJournalFiles || checkForCorruptJournalFiles);</a>
<span class="sourceLineNo">3400</span><a id="line.3400">        manager.setWriteBatchSize(getJournalMaxWriteBatchSize());</a>
<span class="sourceLineNo">3401</span><a id="line.3401">        manager.setArchiveDataLogs(isArchiveDataLogs());</a>
<span class="sourceLineNo">3402</span><a id="line.3402">        manager.setSizeAccumulator(journalSize);</a>
<span class="sourceLineNo">3403</span><a id="line.3403">        manager.setEnableAsyncDiskSync(isEnableJournalDiskSyncs());</a>
<span class="sourceLineNo">3404</span><a id="line.3404">        manager.setPreallocationScope(Journal.PreallocationScope.valueOf(preallocationScope.trim().toUpperCase()));</a>
<span class="sourceLineNo">3405</span><a id="line.3405">        manager.setPreallocationStrategy(</a>
<span class="sourceLineNo">3406</span><a id="line.3406">                Journal.PreallocationStrategy.valueOf(preallocationStrategy.trim().toUpperCase()));</a>
<span class="sourceLineNo">3407</span><a id="line.3407">        manager.setJournalDiskSyncStrategy(journalDiskSyncStrategy);</a>
<span class="sourceLineNo">3408</span><a id="line.3408">        if (getDirectoryArchive() != null) {</a>
<span class="sourceLineNo">3409</span><a id="line.3409">            IOHelper.mkdirs(getDirectoryArchive());</a>
<span class="sourceLineNo">3410</span><a id="line.3410">            manager.setDirectoryArchive(getDirectoryArchive());</a>
<span class="sourceLineNo">3411</span><a id="line.3411">        }</a>
<span class="sourceLineNo">3412</span><a id="line.3412">        return manager;</a>
<span class="sourceLineNo">3413</span><a id="line.3413">    }</a>
<span class="sourceLineNo">3414</span><a id="line.3414"></a>
<span class="sourceLineNo">3415</span><a id="line.3415">    private Metadata createMetadata() {</a>
<span class="sourceLineNo">3416</span><a id="line.3416">        Metadata md = new Metadata();</a>
<span class="sourceLineNo">3417</span><a id="line.3417">        md.producerSequenceIdTracker.setAuditDepth(getFailoverProducersAuditDepth());</a>
<span class="sourceLineNo">3418</span><a id="line.3418">        md.producerSequenceIdTracker.setMaximumNumberOfProducersToTrack(getMaxFailoverProducersToTrack());</a>
<span class="sourceLineNo">3419</span><a id="line.3419">        return md;</a>
<span class="sourceLineNo">3420</span><a id="line.3420">    }</a>
<span class="sourceLineNo">3421</span><a id="line.3421"></a>
<span class="sourceLineNo">3422</span><a id="line.3422">    protected abstract void configureMetadata();</a>
<span class="sourceLineNo">3423</span><a id="line.3423"></a>
<span class="sourceLineNo">3424</span><a id="line.3424">    public int getJournalMaxWriteBatchSize() {</a>
<span class="sourceLineNo">3425</span><a id="line.3425">        return journalMaxWriteBatchSize;</a>
<span class="sourceLineNo">3426</span><a id="line.3426">    }</a>
<span class="sourceLineNo">3427</span><a id="line.3427"></a>
<span class="sourceLineNo">3428</span><a id="line.3428">    public void setJournalMaxWriteBatchSize(int journalMaxWriteBatchSize) {</a>
<span class="sourceLineNo">3429</span><a id="line.3429">        this.journalMaxWriteBatchSize = journalMaxWriteBatchSize;</a>
<span class="sourceLineNo">3430</span><a id="line.3430">    }</a>
<span class="sourceLineNo">3431</span><a id="line.3431"></a>
<span class="sourceLineNo">3432</span><a id="line.3432">    public File getDirectory() {</a>
<span class="sourceLineNo">3433</span><a id="line.3433">        return directory;</a>
<span class="sourceLineNo">3434</span><a id="line.3434">    }</a>
<span class="sourceLineNo">3435</span><a id="line.3435"></a>
<span class="sourceLineNo">3436</span><a id="line.3436">    public void setDirectory(File directory) {</a>
<span class="sourceLineNo">3437</span><a id="line.3437">        this.directory = directory;</a>
<span class="sourceLineNo">3438</span><a id="line.3438">    }</a>
<span class="sourceLineNo">3439</span><a id="line.3439"></a>
<span class="sourceLineNo">3440</span><a id="line.3440">    public boolean isDeleteAllMessages() {</a>
<span class="sourceLineNo">3441</span><a id="line.3441">        return deleteAllMessages;</a>
<span class="sourceLineNo">3442</span><a id="line.3442">    }</a>
<span class="sourceLineNo">3443</span><a id="line.3443"></a>
<span class="sourceLineNo">3444</span><a id="line.3444">    public void setDeleteAllMessages(boolean deleteAllMessages) {</a>
<span class="sourceLineNo">3445</span><a id="line.3445">        this.deleteAllMessages = deleteAllMessages;</a>
<span class="sourceLineNo">3446</span><a id="line.3446">    }</a>
<span class="sourceLineNo">3447</span><a id="line.3447"></a>
<span class="sourceLineNo">3448</span><a id="line.3448">    public void setIndexWriteBatchSize(int setIndexWriteBatchSize) {</a>
<span class="sourceLineNo">3449</span><a id="line.3449">        this.setIndexWriteBatchSize = setIndexWriteBatchSize;</a>
<span class="sourceLineNo">3450</span><a id="line.3450">    }</a>
<span class="sourceLineNo">3451</span><a id="line.3451"></a>
<span class="sourceLineNo">3452</span><a id="line.3452">    public int getIndexWriteBatchSize() {</a>
<span class="sourceLineNo">3453</span><a id="line.3453">        return setIndexWriteBatchSize;</a>
<span class="sourceLineNo">3454</span><a id="line.3454">    }</a>
<span class="sourceLineNo">3455</span><a id="line.3455"></a>
<span class="sourceLineNo">3456</span><a id="line.3456">    public void setEnableIndexWriteAsync(boolean enableIndexWriteAsync) {</a>
<span class="sourceLineNo">3457</span><a id="line.3457">        this.enableIndexWriteAsync = enableIndexWriteAsync;</a>
<span class="sourceLineNo">3458</span><a id="line.3458">    }</a>
<span class="sourceLineNo">3459</span><a id="line.3459"></a>
<span class="sourceLineNo">3460</span><a id="line.3460">    boolean isEnableIndexWriteAsync() {</a>
<span class="sourceLineNo">3461</span><a id="line.3461">        return enableIndexWriteAsync;</a>
<span class="sourceLineNo">3462</span><a id="line.3462">    }</a>
<span class="sourceLineNo">3463</span><a id="line.3463"></a>
<span class="sourceLineNo">3464</span><a id="line.3464">    /**</a>
<span class="sourceLineNo">3465</span><a id="line.3465">     * @deprecated use {@link #getJournalDiskSyncStrategyEnum} or {@link #getJournalDiskSyncStrategy} instead</a>
<span class="sourceLineNo">3466</span><a id="line.3466">     * @return</a>
<span class="sourceLineNo">3467</span><a id="line.3467">     */</a>
<span class="sourceLineNo">3468</span><a id="line.3468">    @Deprecated</a>
<span class="sourceLineNo">3469</span><a id="line.3469">    public boolean isEnableJournalDiskSyncs() {</a>
<span class="sourceLineNo">3470</span><a id="line.3470">        return journalDiskSyncStrategy == JournalDiskSyncStrategy.ALWAYS;</a>
<span class="sourceLineNo">3471</span><a id="line.3471">    }</a>
<span class="sourceLineNo">3472</span><a id="line.3472"></a>
<span class="sourceLineNo">3473</span><a id="line.3473">    /**</a>
<span class="sourceLineNo">3474</span><a id="line.3474">     * @deprecated use {@link #setEnableJournalDiskSyncs} instead</a>
<span class="sourceLineNo">3475</span><a id="line.3475">     * @param syncWrites</a>
<span class="sourceLineNo">3476</span><a id="line.3476">     */</a>
<span class="sourceLineNo">3477</span><a id="line.3477">    @Deprecated</a>
<span class="sourceLineNo">3478</span><a id="line.3478">    public void setEnableJournalDiskSyncs(boolean syncWrites) {</a>
<span class="sourceLineNo">3479</span><a id="line.3479">        if (syncWrites) {</a>
<span class="sourceLineNo">3480</span><a id="line.3480">            journalDiskSyncStrategy = JournalDiskSyncStrategy.ALWAYS;</a>
<span class="sourceLineNo">3481</span><a id="line.3481">        } else {</a>
<span class="sourceLineNo">3482</span><a id="line.3482">            journalDiskSyncStrategy = JournalDiskSyncStrategy.NEVER;</a>
<span class="sourceLineNo">3483</span><a id="line.3483">        }</a>
<span class="sourceLineNo">3484</span><a id="line.3484">    }</a>
<span class="sourceLineNo">3485</span><a id="line.3485"></a>
<span class="sourceLineNo">3486</span><a id="line.3486">    public JournalDiskSyncStrategy getJournalDiskSyncStrategyEnum() {</a>
<span class="sourceLineNo">3487</span><a id="line.3487">        return journalDiskSyncStrategy;</a>
<span class="sourceLineNo">3488</span><a id="line.3488">    }</a>
<span class="sourceLineNo">3489</span><a id="line.3489"></a>
<span class="sourceLineNo">3490</span><a id="line.3490">    public String getJournalDiskSyncStrategy() {</a>
<span class="sourceLineNo">3491</span><a id="line.3491">        return journalDiskSyncStrategy.name();</a>
<span class="sourceLineNo">3492</span><a id="line.3492">    }</a>
<span class="sourceLineNo">3493</span><a id="line.3493"></a>
<span class="sourceLineNo">3494</span><a id="line.3494">    public void setJournalDiskSyncStrategy(String journalDiskSyncStrategy) {</a>
<span class="sourceLineNo">3495</span><a id="line.3495">        this.journalDiskSyncStrategy = JournalDiskSyncStrategy.valueOf(journalDiskSyncStrategy.trim().toUpperCase());</a>
<span class="sourceLineNo">3496</span><a id="line.3496">    }</a>
<span class="sourceLineNo">3497</span><a id="line.3497"></a>
<span class="sourceLineNo">3498</span><a id="line.3498">    public long getJournalDiskSyncInterval() {</a>
<span class="sourceLineNo">3499</span><a id="line.3499">        return journalDiskSyncInterval;</a>
<span class="sourceLineNo">3500</span><a id="line.3500">    }</a>
<span class="sourceLineNo">3501</span><a id="line.3501"></a>
<span class="sourceLineNo">3502</span><a id="line.3502">    public void setJournalDiskSyncInterval(long journalDiskSyncInterval) {</a>
<span class="sourceLineNo">3503</span><a id="line.3503">        this.journalDiskSyncInterval = journalDiskSyncInterval;</a>
<span class="sourceLineNo">3504</span><a id="line.3504">    }</a>
<span class="sourceLineNo">3505</span><a id="line.3505"></a>
<span class="sourceLineNo">3506</span><a id="line.3506">    public long getCheckpointInterval() {</a>
<span class="sourceLineNo">3507</span><a id="line.3507">        return checkpointInterval;</a>
<span class="sourceLineNo">3508</span><a id="line.3508">    }</a>
<span class="sourceLineNo">3509</span><a id="line.3509"></a>
<span class="sourceLineNo">3510</span><a id="line.3510">    public void setCheckpointInterval(long checkpointInterval) {</a>
<span class="sourceLineNo">3511</span><a id="line.3511">        this.checkpointInterval = checkpointInterval;</a>
<span class="sourceLineNo">3512</span><a id="line.3512">    }</a>
<span class="sourceLineNo">3513</span><a id="line.3513"></a>
<span class="sourceLineNo">3514</span><a id="line.3514">    public long getCleanupInterval() {</a>
<span class="sourceLineNo">3515</span><a id="line.3515">        return cleanupInterval;</a>
<span class="sourceLineNo">3516</span><a id="line.3516">    }</a>
<span class="sourceLineNo">3517</span><a id="line.3517"></a>
<span class="sourceLineNo">3518</span><a id="line.3518">    public void setCleanupInterval(long cleanupInterval) {</a>
<span class="sourceLineNo">3519</span><a id="line.3519">        this.cleanupInterval = cleanupInterval;</a>
<span class="sourceLineNo">3520</span><a id="line.3520">    }</a>
<span class="sourceLineNo">3521</span><a id="line.3521"></a>
<span class="sourceLineNo">3522</span><a id="line.3522">    public boolean getCleanupOnStop() {</a>
<span class="sourceLineNo">3523</span><a id="line.3523">        return cleanupOnStop;</a>
<span class="sourceLineNo">3524</span><a id="line.3524">    }</a>
<span class="sourceLineNo">3525</span><a id="line.3525"></a>
<span class="sourceLineNo">3526</span><a id="line.3526">    public void setCleanupOnStop(boolean cleanupOnStop) {</a>
<span class="sourceLineNo">3527</span><a id="line.3527">        this.cleanupOnStop = cleanupOnStop;</a>
<span class="sourceLineNo">3528</span><a id="line.3528">    }</a>
<span class="sourceLineNo">3529</span><a id="line.3529"></a>
<span class="sourceLineNo">3530</span><a id="line.3530">    public void setJournalMaxFileLength(int journalMaxFileLength) {</a>
<span class="sourceLineNo">3531</span><a id="line.3531">        this.journalMaxFileLength = journalMaxFileLength;</a>
<span class="sourceLineNo">3532</span><a id="line.3532">    }</a>
<span class="sourceLineNo">3533</span><a id="line.3533"></a>
<span class="sourceLineNo">3534</span><a id="line.3534">    public int getJournalMaxFileLength() {</a>
<span class="sourceLineNo">3535</span><a id="line.3535">        return journalMaxFileLength;</a>
<span class="sourceLineNo">3536</span><a id="line.3536">    }</a>
<span class="sourceLineNo">3537</span><a id="line.3537"></a>
<span class="sourceLineNo">3538</span><a id="line.3538">    public void setMaxFailoverProducersToTrack(int maxFailoverProducersToTrack) {</a>
<span class="sourceLineNo">3539</span><a id="line.3539">        this.metadata.producerSequenceIdTracker.setMaximumNumberOfProducersToTrack(maxFailoverProducersToTrack);</a>
<span class="sourceLineNo">3540</span><a id="line.3540">    }</a>
<span class="sourceLineNo">3541</span><a id="line.3541"></a>
<span class="sourceLineNo">3542</span><a id="line.3542">    public int getMaxFailoverProducersToTrack() {</a>
<span class="sourceLineNo">3543</span><a id="line.3543">        return this.metadata.producerSequenceIdTracker.getMaximumNumberOfProducersToTrack();</a>
<span class="sourceLineNo">3544</span><a id="line.3544">    }</a>
<span class="sourceLineNo">3545</span><a id="line.3545"></a>
<span class="sourceLineNo">3546</span><a id="line.3546">    public void setFailoverProducersAuditDepth(int failoverProducersAuditDepth) {</a>
<span class="sourceLineNo">3547</span><a id="line.3547">        this.metadata.producerSequenceIdTracker.setAuditDepth(failoverProducersAuditDepth);</a>
<span class="sourceLineNo">3548</span><a id="line.3548">    }</a>
<span class="sourceLineNo">3549</span><a id="line.3549"></a>
<span class="sourceLineNo">3550</span><a id="line.3550">    public int getFailoverProducersAuditDepth() {</a>
<span class="sourceLineNo">3551</span><a id="line.3551">        return this.metadata.producerSequenceIdTracker.getAuditDepth();</a>
<span class="sourceLineNo">3552</span><a id="line.3552">    }</a>
<span class="sourceLineNo">3553</span><a id="line.3553"></a>
<span class="sourceLineNo">3554</span><a id="line.3554">    public PageFile getPageFile() throws IOException {</a>
<span class="sourceLineNo">3555</span><a id="line.3555">        if (pageFile == null) {</a>
<span class="sourceLineNo">3556</span><a id="line.3556">            pageFile = createPageFile();</a>
<span class="sourceLineNo">3557</span><a id="line.3557">        }</a>
<span class="sourceLineNo">3558</span><a id="line.3558">        return pageFile;</a>
<span class="sourceLineNo">3559</span><a id="line.3559">    }</a>
<span class="sourceLineNo">3560</span><a id="line.3560"></a>
<span class="sourceLineNo">3561</span><a id="line.3561">    public Journal getJournal() throws IOException {</a>
<span class="sourceLineNo">3562</span><a id="line.3562">        if (journal == null) {</a>
<span class="sourceLineNo">3563</span><a id="line.3563">            journal = createJournal();</a>
<span class="sourceLineNo">3564</span><a id="line.3564">        }</a>
<span class="sourceLineNo">3565</span><a id="line.3565">        return journal;</a>
<span class="sourceLineNo">3566</span><a id="line.3566">    }</a>
<span class="sourceLineNo">3567</span><a id="line.3567"></a>
<span class="sourceLineNo">3568</span><a id="line.3568">    protected Metadata getMetadata() {</a>
<span class="sourceLineNo">3569</span><a id="line.3569">        return metadata;</a>
<span class="sourceLineNo">3570</span><a id="line.3570">    }</a>
<span class="sourceLineNo">3571</span><a id="line.3571"></a>
<span class="sourceLineNo">3572</span><a id="line.3572">    public boolean isFailIfDatabaseIsLocked() {</a>
<span class="sourceLineNo">3573</span><a id="line.3573">        return failIfDatabaseIsLocked;</a>
<span class="sourceLineNo">3574</span><a id="line.3574">    }</a>
<span class="sourceLineNo">3575</span><a id="line.3575"></a>
<span class="sourceLineNo">3576</span><a id="line.3576">    public void setFailIfDatabaseIsLocked(boolean failIfDatabaseIsLocked) {</a>
<span class="sourceLineNo">3577</span><a id="line.3577">        this.failIfDatabaseIsLocked = failIfDatabaseIsLocked;</a>
<span class="sourceLineNo">3578</span><a id="line.3578">    }</a>
<span class="sourceLineNo">3579</span><a id="line.3579"></a>
<span class="sourceLineNo">3580</span><a id="line.3580">    public boolean isIgnoreMissingJournalfiles() {</a>
<span class="sourceLineNo">3581</span><a id="line.3581">        return ignoreMissingJournalfiles;</a>
<span class="sourceLineNo">3582</span><a id="line.3582">    }</a>
<span class="sourceLineNo">3583</span><a id="line.3583"></a>
<span class="sourceLineNo">3584</span><a id="line.3584">    public void setIgnoreMissingJournalfiles(boolean ignoreMissingJournalfiles) {</a>
<span class="sourceLineNo">3585</span><a id="line.3585">        this.ignoreMissingJournalfiles = ignoreMissingJournalfiles;</a>
<span class="sourceLineNo">3586</span><a id="line.3586">    }</a>
<span class="sourceLineNo">3587</span><a id="line.3587"></a>
<span class="sourceLineNo">3588</span><a id="line.3588">    public int getIndexCacheSize() {</a>
<span class="sourceLineNo">3589</span><a id="line.3589">        return indexCacheSize;</a>
<span class="sourceLineNo">3590</span><a id="line.3590">    }</a>
<span class="sourceLineNo">3591</span><a id="line.3591"></a>
<span class="sourceLineNo">3592</span><a id="line.3592">    public void setIndexCacheSize(int indexCacheSize) {</a>
<span class="sourceLineNo">3593</span><a id="line.3593">        this.indexCacheSize = indexCacheSize;</a>
<span class="sourceLineNo">3594</span><a id="line.3594">    }</a>
<span class="sourceLineNo">3595</span><a id="line.3595"></a>
<span class="sourceLineNo">3596</span><a id="line.3596">    public boolean isCheckForCorruptJournalFiles() {</a>
<span class="sourceLineNo">3597</span><a id="line.3597">        return checkForCorruptJournalFiles;</a>
<span class="sourceLineNo">3598</span><a id="line.3598">    }</a>
<span class="sourceLineNo">3599</span><a id="line.3599"></a>
<span class="sourceLineNo">3600</span><a id="line.3600">    public void setCheckForCorruptJournalFiles(boolean checkForCorruptJournalFiles) {</a>
<span class="sourceLineNo">3601</span><a id="line.3601">        this.checkForCorruptJournalFiles = checkForCorruptJournalFiles;</a>
<span class="sourceLineNo">3602</span><a id="line.3602">    }</a>
<span class="sourceLineNo">3603</span><a id="line.3603"></a>
<span class="sourceLineNo">3604</span><a id="line.3604">    public PurgeRecoveredXATransactionStrategy getPurgeRecoveredXATransactionStrategyEnum() {</a>
<span class="sourceLineNo">3605</span><a id="line.3605">        return purgeRecoveredXATransactionStrategy;</a>
<span class="sourceLineNo">3606</span><a id="line.3606">    }</a>
<span class="sourceLineNo">3607</span><a id="line.3607"></a>
<span class="sourceLineNo">3608</span><a id="line.3608">    public String getPurgeRecoveredXATransactionStrategy() {</a>
<span class="sourceLineNo">3609</span><a id="line.3609">        return purgeRecoveredXATransactionStrategy.name();</a>
<span class="sourceLineNo">3610</span><a id="line.3610">    }</a>
<span class="sourceLineNo">3611</span><a id="line.3611"></a>
<span class="sourceLineNo">3612</span><a id="line.3612">    public void setPurgeRecoveredXATransactionStrategy(String purgeRecoveredXATransactionStrategy) {</a>
<span class="sourceLineNo">3613</span><a id="line.3613">        this.purgeRecoveredXATransactionStrategy = PurgeRecoveredXATransactionStrategy.valueOf(</a>
<span class="sourceLineNo">3614</span><a id="line.3614">                purgeRecoveredXATransactionStrategy.trim().toUpperCase());</a>
<span class="sourceLineNo">3615</span><a id="line.3615">    }</a>
<span class="sourceLineNo">3616</span><a id="line.3616"></a>
<span class="sourceLineNo">3617</span><a id="line.3617">    public boolean isChecksumJournalFiles() {</a>
<span class="sourceLineNo">3618</span><a id="line.3618">        return checksumJournalFiles;</a>
<span class="sourceLineNo">3619</span><a id="line.3619">    }</a>
<span class="sourceLineNo">3620</span><a id="line.3620"></a>
<span class="sourceLineNo">3621</span><a id="line.3621">    public void setChecksumJournalFiles(boolean checksumJournalFiles) {</a>
<span class="sourceLineNo">3622</span><a id="line.3622">        this.checksumJournalFiles = checksumJournalFiles;</a>
<span class="sourceLineNo">3623</span><a id="line.3623">    }</a>
<span class="sourceLineNo">3624</span><a id="line.3624"></a>
<span class="sourceLineNo">3625</span><a id="line.3625">    @Override</a>
<span class="sourceLineNo">3626</span><a id="line.3626">    public void setBrokerService(BrokerService brokerService) {</a>
<span class="sourceLineNo">3627</span><a id="line.3627">        this.brokerService = brokerService;</a>
<span class="sourceLineNo">3628</span><a id="line.3628">    }</a>
<span class="sourceLineNo">3629</span><a id="line.3629"></a>
<span class="sourceLineNo">3630</span><a id="line.3630">    /**</a>
<span class="sourceLineNo">3631</span><a id="line.3631">     * @return the archiveDataLogs</a>
<span class="sourceLineNo">3632</span><a id="line.3632">     */</a>
<span class="sourceLineNo">3633</span><a id="line.3633">    public boolean isArchiveDataLogs() {</a>
<span class="sourceLineNo">3634</span><a id="line.3634">        return this.archiveDataLogs;</a>
<span class="sourceLineNo">3635</span><a id="line.3635">    }</a>
<span class="sourceLineNo">3636</span><a id="line.3636"></a>
<span class="sourceLineNo">3637</span><a id="line.3637">    /**</a>
<span class="sourceLineNo">3638</span><a id="line.3638">     * @param archiveDataLogs the archiveDataLogs to set</a>
<span class="sourceLineNo">3639</span><a id="line.3639">     */</a>
<span class="sourceLineNo">3640</span><a id="line.3640">    public void setArchiveDataLogs(boolean archiveDataLogs) {</a>
<span class="sourceLineNo">3641</span><a id="line.3641">        this.archiveDataLogs = archiveDataLogs;</a>
<span class="sourceLineNo">3642</span><a id="line.3642">    }</a>
<span class="sourceLineNo">3643</span><a id="line.3643"></a>
<span class="sourceLineNo">3644</span><a id="line.3644">    /**</a>
<span class="sourceLineNo">3645</span><a id="line.3645">     * @return the directoryArchive</a>
<span class="sourceLineNo">3646</span><a id="line.3646">     */</a>
<span class="sourceLineNo">3647</span><a id="line.3647">    public File getDirectoryArchive() {</a>
<span class="sourceLineNo">3648</span><a id="line.3648">        return this.directoryArchive;</a>
<span class="sourceLineNo">3649</span><a id="line.3649">    }</a>
<span class="sourceLineNo">3650</span><a id="line.3650"></a>
<span class="sourceLineNo">3651</span><a id="line.3651">    /**</a>
<span class="sourceLineNo">3652</span><a id="line.3652">     * @param directoryArchive the directoryArchive to set</a>
<span class="sourceLineNo">3653</span><a id="line.3653">     */</a>
<span class="sourceLineNo">3654</span><a id="line.3654">    public void setDirectoryArchive(File directoryArchive) {</a>
<span class="sourceLineNo">3655</span><a id="line.3655">        this.directoryArchive = directoryArchive;</a>
<span class="sourceLineNo">3656</span><a id="line.3656">    }</a>
<span class="sourceLineNo">3657</span><a id="line.3657"></a>
<span class="sourceLineNo">3658</span><a id="line.3658">    public boolean isArchiveCorruptedIndex() {</a>
<span class="sourceLineNo">3659</span><a id="line.3659">        return archiveCorruptedIndex;</a>
<span class="sourceLineNo">3660</span><a id="line.3660">    }</a>
<span class="sourceLineNo">3661</span><a id="line.3661"></a>
<span class="sourceLineNo">3662</span><a id="line.3662">    public void setArchiveCorruptedIndex(boolean archiveCorruptedIndex) {</a>
<span class="sourceLineNo">3663</span><a id="line.3663">        this.archiveCorruptedIndex = archiveCorruptedIndex;</a>
<span class="sourceLineNo">3664</span><a id="line.3664">    }</a>
<span class="sourceLineNo">3665</span><a id="line.3665"></a>
<span class="sourceLineNo">3666</span><a id="line.3666">    public float getIndexLFUEvictionFactor() {</a>
<span class="sourceLineNo">3667</span><a id="line.3667">        return indexLFUEvictionFactor;</a>
<span class="sourceLineNo">3668</span><a id="line.3668">    }</a>
<span class="sourceLineNo">3669</span><a id="line.3669"></a>
<span class="sourceLineNo">3670</span><a id="line.3670">    public void setIndexLFUEvictionFactor(float indexLFUEvictionFactor) {</a>
<span class="sourceLineNo">3671</span><a id="line.3671">        this.indexLFUEvictionFactor = indexLFUEvictionFactor;</a>
<span class="sourceLineNo">3672</span><a id="line.3672">    }</a>
<span class="sourceLineNo">3673</span><a id="line.3673"></a>
<span class="sourceLineNo">3674</span><a id="line.3674">    public boolean isUseIndexLFRUEviction() {</a>
<span class="sourceLineNo">3675</span><a id="line.3675">        return useIndexLFRUEviction;</a>
<span class="sourceLineNo">3676</span><a id="line.3676">    }</a>
<span class="sourceLineNo">3677</span><a id="line.3677"></a>
<span class="sourceLineNo">3678</span><a id="line.3678">    public void setUseIndexLFRUEviction(boolean useIndexLFRUEviction) {</a>
<span class="sourceLineNo">3679</span><a id="line.3679">        this.useIndexLFRUEviction = useIndexLFRUEviction;</a>
<span class="sourceLineNo">3680</span><a id="line.3680">    }</a>
<span class="sourceLineNo">3681</span><a id="line.3681"></a>
<span class="sourceLineNo">3682</span><a id="line.3682">    public void setEnableIndexDiskSyncs(boolean enableIndexDiskSyncs) {</a>
<span class="sourceLineNo">3683</span><a id="line.3683">        this.enableIndexDiskSyncs = enableIndexDiskSyncs;</a>
<span class="sourceLineNo">3684</span><a id="line.3684">    }</a>
<span class="sourceLineNo">3685</span><a id="line.3685"></a>
<span class="sourceLineNo">3686</span><a id="line.3686">    public void setEnableIndexRecoveryFile(boolean enableIndexRecoveryFile) {</a>
<span class="sourceLineNo">3687</span><a id="line.3687">        this.enableIndexRecoveryFile = enableIndexRecoveryFile;</a>
<span class="sourceLineNo">3688</span><a id="line.3688">    }</a>
<span class="sourceLineNo">3689</span><a id="line.3689"></a>
<span class="sourceLineNo">3690</span><a id="line.3690">    public void setEnableIndexPageCaching(boolean enableIndexPageCaching) {</a>
<span class="sourceLineNo">3691</span><a id="line.3691">        this.enableIndexPageCaching = enableIndexPageCaching;</a>
<span class="sourceLineNo">3692</span><a id="line.3692">    }</a>
<span class="sourceLineNo">3693</span><a id="line.3693"></a>
<span class="sourceLineNo">3694</span><a id="line.3694">    public boolean isEnableIndexDiskSyncs() {</a>
<span class="sourceLineNo">3695</span><a id="line.3695">        return enableIndexDiskSyncs;</a>
<span class="sourceLineNo">3696</span><a id="line.3696">    }</a>
<span class="sourceLineNo">3697</span><a id="line.3697"></a>
<span class="sourceLineNo">3698</span><a id="line.3698">    public boolean isEnableIndexRecoveryFile() {</a>
<span class="sourceLineNo">3699</span><a id="line.3699">        return enableIndexRecoveryFile;</a>
<span class="sourceLineNo">3700</span><a id="line.3700">    }</a>
<span class="sourceLineNo">3701</span><a id="line.3701"></a>
<span class="sourceLineNo">3702</span><a id="line.3702">    public boolean isEnableIndexPageCaching() {</a>
<span class="sourceLineNo">3703</span><a id="line.3703">        return enableIndexPageCaching;</a>
<span class="sourceLineNo">3704</span><a id="line.3704">    }</a>
<span class="sourceLineNo">3705</span><a id="line.3705"></a>
<span class="sourceLineNo">3706</span><a id="line.3706">    public PersistenceAdapterStatistics getPersistenceAdapterStatistics() {</a>
<span class="sourceLineNo">3707</span><a id="line.3707">        return this.persistenceAdapterStatistics;</a>
<span class="sourceLineNo">3708</span><a id="line.3708">    }</a>
<span class="sourceLineNo">3709</span><a id="line.3709"></a>
<span class="sourceLineNo">3710</span><a id="line.3710">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">3711</span><a id="line.3711">    // Internal conversion methods.</a>
<span class="sourceLineNo">3712</span><a id="line.3712">    // /////////////////////////////////////////////////////////////////</a>
<span class="sourceLineNo">3713</span><a id="line.3713"></a>
<span class="sourceLineNo">3714</span><a id="line.3714">    class MessageOrderCursor{</a>
<span class="sourceLineNo">3715</span><a id="line.3715">        long defaultCursorPosition;</a>
<span class="sourceLineNo">3716</span><a id="line.3716">        long lowPriorityCursorPosition;</a>
<span class="sourceLineNo">3717</span><a id="line.3717">        long highPriorityCursorPosition;</a>
<span class="sourceLineNo">3718</span><a id="line.3718">        MessageOrderCursor(){</a>
<span class="sourceLineNo">3719</span><a id="line.3719">        }</a>
<span class="sourceLineNo">3720</span><a id="line.3720"></a>
<span class="sourceLineNo">3721</span><a id="line.3721">        MessageOrderCursor(long position){</a>
<span class="sourceLineNo">3722</span><a id="line.3722">            this.defaultCursorPosition=position;</a>
<span class="sourceLineNo">3723</span><a id="line.3723">            this.lowPriorityCursorPosition=position;</a>
<span class="sourceLineNo">3724</span><a id="line.3724">            this.highPriorityCursorPosition=position;</a>
<span class="sourceLineNo">3725</span><a id="line.3725">        }</a>
<span class="sourceLineNo">3726</span><a id="line.3726"></a>
<span class="sourceLineNo">3727</span><a id="line.3727">        MessageOrderCursor(MessageOrderCursor other){</a>
<span class="sourceLineNo">3728</span><a id="line.3728">            this.defaultCursorPosition=other.defaultCursorPosition;</a>
<span class="sourceLineNo">3729</span><a id="line.3729">            this.lowPriorityCursorPosition=other.lowPriorityCursorPosition;</a>
<span class="sourceLineNo">3730</span><a id="line.3730">            this.highPriorityCursorPosition=other.highPriorityCursorPosition;</a>
<span class="sourceLineNo">3731</span><a id="line.3731">        }</a>
<span class="sourceLineNo">3732</span><a id="line.3732"></a>
<span class="sourceLineNo">3733</span><a id="line.3733">        MessageOrderCursor copy() {</a>
<span class="sourceLineNo">3734</span><a id="line.3734">            return new MessageOrderCursor(this);</a>
<span class="sourceLineNo">3735</span><a id="line.3735">        }</a>
<span class="sourceLineNo">3736</span><a id="line.3736"></a>
<span class="sourceLineNo">3737</span><a id="line.3737">        void reset() {</a>
<span class="sourceLineNo">3738</span><a id="line.3738">            this.defaultCursorPosition=0;</a>
<span class="sourceLineNo">3739</span><a id="line.3739">            this.highPriorityCursorPosition=0;</a>
<span class="sourceLineNo">3740</span><a id="line.3740">            this.lowPriorityCursorPosition=0;</a>
<span class="sourceLineNo">3741</span><a id="line.3741">        }</a>
<span class="sourceLineNo">3742</span><a id="line.3742"></a>
<span class="sourceLineNo">3743</span><a id="line.3743">        void increment() {</a>
<span class="sourceLineNo">3744</span><a id="line.3744">            if (defaultCursorPosition!=0) {</a>
<span class="sourceLineNo">3745</span><a id="line.3745">                defaultCursorPosition++;</a>
<span class="sourceLineNo">3746</span><a id="line.3746">            }</a>
<span class="sourceLineNo">3747</span><a id="line.3747">            if (highPriorityCursorPosition!=0) {</a>
<span class="sourceLineNo">3748</span><a id="line.3748">                highPriorityCursorPosition++;</a>
<span class="sourceLineNo">3749</span><a id="line.3749">            }</a>
<span class="sourceLineNo">3750</span><a id="line.3750">            if (lowPriorityCursorPosition!=0) {</a>
<span class="sourceLineNo">3751</span><a id="line.3751">                lowPriorityCursorPosition++;</a>
<span class="sourceLineNo">3752</span><a id="line.3752">            }</a>
<span class="sourceLineNo">3753</span><a id="line.3753">        }</a>
<span class="sourceLineNo">3754</span><a id="line.3754"></a>
<span class="sourceLineNo">3755</span><a id="line.3755">        @Override</a>
<span class="sourceLineNo">3756</span><a id="line.3756">        public String toString() {</a>
<span class="sourceLineNo">3757</span><a id="line.3757">           return "MessageOrderCursor:[def:" + defaultCursorPosition</a>
<span class="sourceLineNo">3758</span><a id="line.3758">                   + ", low:" + lowPriorityCursorPosition</a>
<span class="sourceLineNo">3759</span><a id="line.3759">                   + ", high:" +  highPriorityCursorPosition + "]";</a>
<span class="sourceLineNo">3760</span><a id="line.3760">        }</a>
<span class="sourceLineNo">3761</span><a id="line.3761"></a>
<span class="sourceLineNo">3762</span><a id="line.3762">        public void sync(MessageOrderCursor other) {</a>
<span class="sourceLineNo">3763</span><a id="line.3763">            this.defaultCursorPosition=other.defaultCursorPosition;</a>
<span class="sourceLineNo">3764</span><a id="line.3764">            this.lowPriorityCursorPosition=other.lowPriorityCursorPosition;</a>
<span class="sourceLineNo">3765</span><a id="line.3765">            this.highPriorityCursorPosition=other.highPriorityCursorPosition;</a>
<span class="sourceLineNo">3766</span><a id="line.3766">        }</a>
<span class="sourceLineNo">3767</span><a id="line.3767">    }</a>
<span class="sourceLineNo">3768</span><a id="line.3768"></a>
<span class="sourceLineNo">3769</span><a id="line.3769">    class MessageOrderIndex {</a>
<span class="sourceLineNo">3770</span><a id="line.3770">        static final byte HI = 9;</a>
<span class="sourceLineNo">3771</span><a id="line.3771">        static final byte LO = 0;</a>
<span class="sourceLineNo">3772</span><a id="line.3772">        static final byte DEF = 4;</a>
<span class="sourceLineNo">3773</span><a id="line.3773"></a>
<span class="sourceLineNo">3774</span><a id="line.3774">        long nextMessageId;</a>
<span class="sourceLineNo">3775</span><a id="line.3775">        BTreeIndex&lt;Long, MessageKeys&gt; defaultPriorityIndex;</a>
<span class="sourceLineNo">3776</span><a id="line.3776">        BTreeIndex&lt;Long, MessageKeys&gt; lowPriorityIndex;</a>
<span class="sourceLineNo">3777</span><a id="line.3777">        BTreeIndex&lt;Long, MessageKeys&gt; highPriorityIndex;</a>
<span class="sourceLineNo">3778</span><a id="line.3778">        final MessageOrderCursor cursor = new MessageOrderCursor();</a>
<span class="sourceLineNo">3779</span><a id="line.3779">        Long lastDefaultKey;</a>
<span class="sourceLineNo">3780</span><a id="line.3780">        Long lastHighKey;</a>
<span class="sourceLineNo">3781</span><a id="line.3781">        Long lastLowKey;</a>
<span class="sourceLineNo">3782</span><a id="line.3782">        byte lastGetPriority;</a>
<span class="sourceLineNo">3783</span><a id="line.3783">        final List&lt;Long&gt; pendingAdditions = new LinkedList&lt;&gt;();</a>
<span class="sourceLineNo">3784</span><a id="line.3784">        final MessageKeysMarshaller messageKeysMarshaller = new MessageKeysMarshaller();</a>
<span class="sourceLineNo">3785</span><a id="line.3785"></a>
<span class="sourceLineNo">3786</span><a id="line.3786">        MessageKeys remove(Transaction tx, Long key) throws IOException {</a>
<span class="sourceLineNo">3787</span><a id="line.3787">            MessageKeys result = defaultPriorityIndex.remove(tx, key);</a>
<span class="sourceLineNo">3788</span><a id="line.3788">            if (result == null &amp;&amp; highPriorityIndex!=null) {</a>
<span class="sourceLineNo">3789</span><a id="line.3789">                result = highPriorityIndex.remove(tx, key);</a>
<span class="sourceLineNo">3790</span><a id="line.3790">                if (result ==null &amp;&amp; lowPriorityIndex!=null) {</a>
<span class="sourceLineNo">3791</span><a id="line.3791">                    result = lowPriorityIndex.remove(tx, key);</a>
<span class="sourceLineNo">3792</span><a id="line.3792">                }</a>
<span class="sourceLineNo">3793</span><a id="line.3793">            }</a>
<span class="sourceLineNo">3794</span><a id="line.3794">            return result;</a>
<span class="sourceLineNo">3795</span><a id="line.3795">        }</a>
<span class="sourceLineNo">3796</span><a id="line.3796"></a>
<span class="sourceLineNo">3797</span><a id="line.3797">        void load(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3798</span><a id="line.3798">            defaultPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">3799</span><a id="line.3799">            defaultPriorityIndex.setValueMarshaller(messageKeysMarshaller);</a>
<span class="sourceLineNo">3800</span><a id="line.3800">            defaultPriorityIndex.load(tx);</a>
<span class="sourceLineNo">3801</span><a id="line.3801">            lowPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">3802</span><a id="line.3802">            lowPriorityIndex.setValueMarshaller(messageKeysMarshaller);</a>
<span class="sourceLineNo">3803</span><a id="line.3803">            lowPriorityIndex.load(tx);</a>
<span class="sourceLineNo">3804</span><a id="line.3804">            highPriorityIndex.setKeyMarshaller(LongMarshaller.INSTANCE);</a>
<span class="sourceLineNo">3805</span><a id="line.3805">            highPriorityIndex.setValueMarshaller(messageKeysMarshaller);</a>
<span class="sourceLineNo">3806</span><a id="line.3806">            highPriorityIndex.load(tx);</a>
<span class="sourceLineNo">3807</span><a id="line.3807">        }</a>
<span class="sourceLineNo">3808</span><a id="line.3808"></a>
<span class="sourceLineNo">3809</span><a id="line.3809">        void allocate(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3810</span><a id="line.3810">            defaultPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">3811</span><a id="line.3811">            if (metadata.version &gt;= 2) {</a>
<span class="sourceLineNo">3812</span><a id="line.3812">                lowPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">3813</span><a id="line.3813">                highPriorityIndex = new BTreeIndex&lt;&gt;(pageFile, tx.allocate());</a>
<span class="sourceLineNo">3814</span><a id="line.3814">            }</a>
<span class="sourceLineNo">3815</span><a id="line.3815">        }</a>
<span class="sourceLineNo">3816</span><a id="line.3816"></a>
<span class="sourceLineNo">3817</span><a id="line.3817">        void configureLast(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3818</span><a id="line.3818">            // Figure out the next key using the last entry in the destination.</a>
<span class="sourceLineNo">3819</span><a id="line.3819">            TreeSet&lt;Long&gt; orderedSet = new TreeSet&lt;&gt;();</a>
<span class="sourceLineNo">3820</span><a id="line.3820"></a>
<span class="sourceLineNo">3821</span><a id="line.3821">            addLast(orderedSet, highPriorityIndex, tx);</a>
<span class="sourceLineNo">3822</span><a id="line.3822">            addLast(orderedSet, defaultPriorityIndex, tx);</a>
<span class="sourceLineNo">3823</span><a id="line.3823">            addLast(orderedSet, lowPriorityIndex, tx);</a>
<span class="sourceLineNo">3824</span><a id="line.3824"></a>
<span class="sourceLineNo">3825</span><a id="line.3825">            if (!orderedSet.isEmpty()) {</a>
<span class="sourceLineNo">3826</span><a id="line.3826">                nextMessageId = orderedSet.last() + 1;</a>
<span class="sourceLineNo">3827</span><a id="line.3827">            }</a>
<span class="sourceLineNo">3828</span><a id="line.3828">        }</a>
<span class="sourceLineNo">3829</span><a id="line.3829"></a>
<span class="sourceLineNo">3830</span><a id="line.3830">        private void addLast(TreeSet&lt;Long&gt; orderedSet, BTreeIndex&lt;Long, MessageKeys&gt; index, Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3831</span><a id="line.3831">            if (index != null) {</a>
<span class="sourceLineNo">3832</span><a id="line.3832">                Entry&lt;Long, MessageKeys&gt; lastEntry = index.getLast(tx);</a>
<span class="sourceLineNo">3833</span><a id="line.3833">                if (lastEntry != null) {</a>
<span class="sourceLineNo">3834</span><a id="line.3834">                    orderedSet.add(lastEntry.getKey());</a>
<span class="sourceLineNo">3835</span><a id="line.3835">                }</a>
<span class="sourceLineNo">3836</span><a id="line.3836">            }</a>
<span class="sourceLineNo">3837</span><a id="line.3837">        }</a>
<span class="sourceLineNo">3838</span><a id="line.3838"></a>
<span class="sourceLineNo">3839</span><a id="line.3839">        void clear(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3840</span><a id="line.3840">            this.remove(tx);</a>
<span class="sourceLineNo">3841</span><a id="line.3841">            this.resetCursorPosition();</a>
<span class="sourceLineNo">3842</span><a id="line.3842">            this.allocate(tx);</a>
<span class="sourceLineNo">3843</span><a id="line.3843">            this.load(tx);</a>
<span class="sourceLineNo">3844</span><a id="line.3844">            this.configureLast(tx);</a>
<span class="sourceLineNo">3845</span><a id="line.3845">        }</a>
<span class="sourceLineNo">3846</span><a id="line.3846"></a>
<span class="sourceLineNo">3847</span><a id="line.3847">        void remove(Transaction tx) throws IOException {</a>
<span class="sourceLineNo">3848</span><a id="line.3848">            defaultPriorityIndex.clear(tx);</a>
<span class="sourceLineNo">3849</span><a id="line.3849">            defaultPriorityIndex.unload(tx);</a>
<span class="sourceLineNo">3850</span><a id="line.3850">            tx.free(defaultPriorityIndex.getPageId());</a>
<span class="sourceLineNo">3851</span><a id="line.3851">            if (lowPriorityIndex != null) {</a>
<span class="sourceLineNo">3852</span><a id="line.3852">                lowPriorityIndex.clear(tx);</a>
<span class="sourceLineNo">3853</span><a id="line.3853">                lowPriorityIndex.unload(tx);</a>
<span class="sourceLineNo">3854</span><a id="line.3854"></a>
<span class="sourceLineNo">3855</span><a id="line.3855">                tx.free(lowPriorityIndex.getPageId());</a>
<span class="sourceLineNo">3856</span><a id="line.3856">            }</a>
<span class="sourceLineNo">3857</span><a id="line.3857">            if (highPriorityIndex != null) {</a>
<span class="sourceLineNo">3858</span><a id="line.3858">                highPriorityIndex.clear(tx);</a>
<span class="sourceLineNo">3859</span><a id="line.3859">                highPriorityIndex.unload(tx);</a>
<span class="sourceLineNo">3860</span><a id="line.3860">                tx.free(highPriorityIndex.getPageId());</a>
<span class="sourceLineNo">3861</span><a id="line.3861">            }</a>
<span class="sourceLineNo">3862</span><a id="line.3862">        }</a>
<span class="sourceLineNo">3863</span><a id="line.3863"></a>
<span class="sourceLineNo">3864</span><a id="line.3864">        void resetCursorPosition() {</a>
<span class="sourceLineNo">3865</span><a id="line.3865">            this.cursor.reset();</a>
<span class="sourceLineNo">3866</span><a id="line.3866">            lastDefaultKey = null;</a>
<span class="sourceLineNo">3867</span><a id="line.3867">            lastHighKey = null;</a>
<span class="sourceLineNo">3868</span><a id="line.3868">            lastLowKey = null;</a>
<span class="sourceLineNo">3869</span><a id="line.3869">        }</a>
<span class="sourceLineNo">3870</span><a id="line.3870"></a>
<span class="sourceLineNo">3871</span><a id="line.3871">        void setBatch(Transaction tx, Long sequence) throws IOException {</a>
<span class="sourceLineNo">3872</span><a id="line.3872">            if (sequence != null) {</a>
<span class="sourceLineNo">3873</span><a id="line.3873">                Long nextPosition = Long.valueOf(sequence.longValue() + 1);</a>
<span class="sourceLineNo">3874</span><a id="line.3874">                lastDefaultKey = sequence;</a>
<span class="sourceLineNo">3875</span><a id="line.3875">                cursor.defaultCursorPosition = nextPosition.longValue();</a>
<span class="sourceLineNo">3876</span><a id="line.3876">                lastHighKey = sequence;</a>
<span class="sourceLineNo">3877</span><a id="line.3877">                cursor.highPriorityCursorPosition = nextPosition.longValue();</a>
<span class="sourceLineNo">3878</span><a id="line.3878">                lastLowKey = sequence;</a>
<span class="sourceLineNo">3879</span><a id="line.3879">                cursor.lowPriorityCursorPosition = nextPosition.longValue();</a>
<span class="sourceLineNo">3880</span><a id="line.3880">            }</a>
<span class="sourceLineNo">3881</span><a id="line.3881">        }</a>
<span class="sourceLineNo">3882</span><a id="line.3882"></a>
<span class="sourceLineNo">3883</span><a id="line.3883">        void setBatch(Transaction tx, LastAck last) throws IOException {</a>
<span class="sourceLineNo">3884</span><a id="line.3884">            setBatch(tx, last.lastAckedSequence);</a>
<span class="sourceLineNo">3885</span><a id="line.3885">            if (cursor.defaultCursorPosition == 0</a>
<span class="sourceLineNo">3886</span><a id="line.3886">                    &amp;&amp; cursor.highPriorityCursorPosition == 0</a>
<span class="sourceLineNo">3887</span><a id="line.3887">                    &amp;&amp; cursor.lowPriorityCursorPosition == 0) {</a>
<span class="sourceLineNo">3888</span><a id="line.3888">                long next = last.lastAckedSequence + 1;</a>
<span class="sourceLineNo">3889</span><a id="line.3889">                switch (last.priority) {</a>
<span class="sourceLineNo">3890</span><a id="line.3890">                    case DEF:</a>
<span class="sourceLineNo">3891</span><a id="line.3891">                        cursor.defaultCursorPosition = next;</a>
<span class="sourceLineNo">3892</span><a id="line.3892">                        cursor.highPriorityCursorPosition = next;</a>
<span class="sourceLineNo">3893</span><a id="line.3893">                        break;</a>
<span class="sourceLineNo">3894</span><a id="line.3894">                    case HI:</a>
<span class="sourceLineNo">3895</span><a id="line.3895">                        cursor.highPriorityCursorPosition = next;</a>
<span class="sourceLineNo">3896</span><a id="line.3896">                        break;</a>
<span class="sourceLineNo">3897</span><a id="line.3897">                    case LO:</a>
<span class="sourceLineNo">3898</span><a id="line.3898">                        cursor.lowPriorityCursorPosition = next;</a>
<span class="sourceLineNo">3899</span><a id="line.3899">                        cursor.defaultCursorPosition = next;</a>
<span class="sourceLineNo">3900</span><a id="line.3900">                        cursor.highPriorityCursorPosition = next;</a>
<span class="sourceLineNo">3901</span><a id="line.3901">                        break;</a>
<span class="sourceLineNo">3902</span><a id="line.3902">                }</a>
<span class="sourceLineNo">3903</span><a id="line.3903">            }</a>
<span class="sourceLineNo">3904</span><a id="line.3904">        }</a>
<span class="sourceLineNo">3905</span><a id="line.3905"></a>
<span class="sourceLineNo">3906</span><a id="line.3906">        void stoppedIterating() {</a>
<span class="sourceLineNo">3907</span><a id="line.3907">            if (lastDefaultKey!=null) {</a>
<span class="sourceLineNo">3908</span><a id="line.3908">                cursor.defaultCursorPosition=lastDefaultKey.longValue()+1;</a>
<span class="sourceLineNo">3909</span><a id="line.3909">            }</a>
<span class="sourceLineNo">3910</span><a id="line.3910">            if (lastHighKey!=null) {</a>
<span class="sourceLineNo">3911</span><a id="line.3911">                cursor.highPriorityCursorPosition=lastHighKey.longValue()+1;</a>
<span class="sourceLineNo">3912</span><a id="line.3912">            }</a>
<span class="sourceLineNo">3913</span><a id="line.3913">            if (lastLowKey!=null) {</a>
<span class="sourceLineNo">3914</span><a id="line.3914">                cursor.lowPriorityCursorPosition=lastLowKey.longValue()+1;</a>
<span class="sourceLineNo">3915</span><a id="line.3915">            }</a>
<span class="sourceLineNo">3916</span><a id="line.3916">            lastDefaultKey = null;</a>
<span class="sourceLineNo">3917</span><a id="line.3917">            lastHighKey = null;</a>
<span class="sourceLineNo">3918</span><a id="line.3918">            lastLowKey = null;</a>
<span class="sourceLineNo">3919</span><a id="line.3919">        }</a>
<span class="sourceLineNo">3920</span><a id="line.3920"></a>
<span class="sourceLineNo">3921</span><a id="line.3921">        void getDeleteList(Transaction tx, ArrayList&lt;Entry&lt;Long, MessageKeys&gt;&gt; deletes, Long sequenceId)</a>
<span class="sourceLineNo">3922</span><a id="line.3922">                throws IOException {</a>
<span class="sourceLineNo">3923</span><a id="line.3923">            if (defaultPriorityIndex.containsKey(tx, sequenceId)) {</a>
<span class="sourceLineNo">3924</span><a id="line.3924">                getDeleteList(tx, deletes, defaultPriorityIndex, sequenceId);</a>
<span class="sourceLineNo">3925</span><a id="line.3925">            } else if (highPriorityIndex != null &amp;&amp; highPriorityIndex.containsKey(tx, sequenceId)) {</a>
<span class="sourceLineNo">3926</span><a id="line.3926">                getDeleteList(tx, deletes, highPriorityIndex, sequenceId);</a>
<span class="sourceLineNo">3927</span><a id="line.3927">            } else if (lowPriorityIndex != null &amp;&amp; lowPriorityIndex.containsKey(tx, sequenceId)) {</a>
<span class="sourceLineNo">3928</span><a id="line.3928">                getDeleteList(tx, deletes, lowPriorityIndex, sequenceId);</a>
<span class="sourceLineNo">3929</span><a id="line.3929">            }</a>
<span class="sourceLineNo">3930</span><a id="line.3930">        }</a>
<span class="sourceLineNo">3931</span><a id="line.3931"></a>
<span class="sourceLineNo">3932</span><a id="line.3932">        void getDeleteList(Transaction tx, ArrayList&lt;Entry&lt;Long, MessageKeys&gt;&gt; deletes,</a>
<span class="sourceLineNo">3933</span><a id="line.3933">                BTreeIndex&lt;Long, MessageKeys&gt; index, Long sequenceId) throws IOException {</a>
<span class="sourceLineNo">3934</span><a id="line.3934"></a>
<span class="sourceLineNo">3935</span><a id="line.3935">            Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt; iterator = index.iterator(tx, sequenceId, null);</a>
<span class="sourceLineNo">3936</span><a id="line.3936">            deletes.add(iterator.next());</a>
<span class="sourceLineNo">3937</span><a id="line.3937">        }</a>
<span class="sourceLineNo">3938</span><a id="line.3938"></a>
<span class="sourceLineNo">3939</span><a id="line.3939">        long getNextMessageId() {</a>
<span class="sourceLineNo">3940</span><a id="line.3940">            return nextMessageId++;</a>
<span class="sourceLineNo">3941</span><a id="line.3941">        }</a>
<span class="sourceLineNo">3942</span><a id="line.3942"></a>
<span class="sourceLineNo">3943</span><a id="line.3943">        void revertNextMessageId() {</a>
<span class="sourceLineNo">3944</span><a id="line.3944">            nextMessageId--;</a>
<span class="sourceLineNo">3945</span><a id="line.3945">        }</a>
<span class="sourceLineNo">3946</span><a id="line.3946"></a>
<span class="sourceLineNo">3947</span><a id="line.3947">        MessageKeys get(Transaction tx, Long key) throws IOException {</a>
<span class="sourceLineNo">3948</span><a id="line.3948">            MessageKeys result = defaultPriorityIndex.get(tx, key);</a>
<span class="sourceLineNo">3949</span><a id="line.3949">            if (result == null) {</a>
<span class="sourceLineNo">3950</span><a id="line.3950">                result = highPriorityIndex.get(tx, key);</a>
<span class="sourceLineNo">3951</span><a id="line.3951">                if (result == null) {</a>
<span class="sourceLineNo">3952</span><a id="line.3952">                    result = lowPriorityIndex.get(tx, key);</a>
<span class="sourceLineNo">3953</span><a id="line.3953">                    lastGetPriority = LO;</a>
<span class="sourceLineNo">3954</span><a id="line.3954">                } else {</a>
<span class="sourceLineNo">3955</span><a id="line.3955">                    lastGetPriority = HI;</a>
<span class="sourceLineNo">3956</span><a id="line.3956">                }</a>
<span class="sourceLineNo">3957</span><a id="line.3957">            } else {</a>
<span class="sourceLineNo">3958</span><a id="line.3958">                lastGetPriority = DEF;</a>
<span class="sourceLineNo">3959</span><a id="line.3959">            }</a>
<span class="sourceLineNo">3960</span><a id="line.3960">            return result;</a>
<span class="sourceLineNo">3961</span><a id="line.3961">        }</a>
<span class="sourceLineNo">3962</span><a id="line.3962"></a>
<span class="sourceLineNo">3963</span><a id="line.3963">        MessageKeys put(Transaction tx, int priority, Long key, MessageKeys value) throws IOException {</a>
<span class="sourceLineNo">3964</span><a id="line.3964">            if (priority == javax.jms.Message.DEFAULT_PRIORITY) {</a>
<span class="sourceLineNo">3965</span><a id="line.3965">                return defaultPriorityIndex.put(tx, key, value);</a>
<span class="sourceLineNo">3966</span><a id="line.3966">            } else if (priority &gt; javax.jms.Message.DEFAULT_PRIORITY) {</a>
<span class="sourceLineNo">3967</span><a id="line.3967">                return highPriorityIndex.put(tx, key, value);</a>
<span class="sourceLineNo">3968</span><a id="line.3968">            } else {</a>
<span class="sourceLineNo">3969</span><a id="line.3969">                return lowPriorityIndex.put(tx, key, value);</a>
<span class="sourceLineNo">3970</span><a id="line.3970">            }</a>
<span class="sourceLineNo">3971</span><a id="line.3971">        }</a>
<span class="sourceLineNo">3972</span><a id="line.3972"></a>
<span class="sourceLineNo">3973</span><a id="line.3973">        Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt; iterator(Transaction tx) throws IOException{</a>
<span class="sourceLineNo">3974</span><a id="line.3974">            return new MessageOrderIterator(tx,cursor,this);</a>
<span class="sourceLineNo">3975</span><a id="line.3975">        }</a>
<span class="sourceLineNo">3976</span><a id="line.3976"></a>
<span class="sourceLineNo">3977</span><a id="line.3977">        Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt; iterator(Transaction tx, MessageOrderCursor m) throws IOException{</a>
<span class="sourceLineNo">3978</span><a id="line.3978">            return new MessageOrderIterator(tx,m,this);</a>
<span class="sourceLineNo">3979</span><a id="line.3979">        }</a>
<span class="sourceLineNo">3980</span><a id="line.3980"></a>
<span class="sourceLineNo">3981</span><a id="line.3981">        public byte lastGetPriority() {</a>
<span class="sourceLineNo">3982</span><a id="line.3982">            return lastGetPriority;</a>
<span class="sourceLineNo">3983</span><a id="line.3983">        }</a>
<span class="sourceLineNo">3984</span><a id="line.3984"></a>
<span class="sourceLineNo">3985</span><a id="line.3985">        public boolean alreadyDispatched(Long sequence) {</a>
<span class="sourceLineNo">3986</span><a id="line.3986">            return (cursor.highPriorityCursorPosition &gt; 0 &amp;&amp; cursor.highPriorityCursorPosition &gt;= sequence) ||</a>
<span class="sourceLineNo">3987</span><a id="line.3987">                    (cursor.defaultCursorPosition &gt; 0 &amp;&amp; cursor.defaultCursorPosition &gt;= sequence) ||</a>
<span class="sourceLineNo">3988</span><a id="line.3988">                    (cursor.lowPriorityCursorPosition &gt; 0 &amp;&amp; cursor.lowPriorityCursorPosition &gt;= sequence);</a>
<span class="sourceLineNo">3989</span><a id="line.3989">        }</a>
<span class="sourceLineNo">3990</span><a id="line.3990"></a>
<span class="sourceLineNo">3991</span><a id="line.3991">        public void trackPendingAdd(Long seq) {</a>
<span class="sourceLineNo">3992</span><a id="line.3992">            synchronized (pendingAdditions) {</a>
<span class="sourceLineNo">3993</span><a id="line.3993">                pendingAdditions.add(seq);</a>
<span class="sourceLineNo">3994</span><a id="line.3994">            }</a>
<span class="sourceLineNo">3995</span><a id="line.3995">        }</a>
<span class="sourceLineNo">3996</span><a id="line.3996"></a>
<span class="sourceLineNo">3997</span><a id="line.3997">        public void trackPendingAddComplete(Long seq) {</a>
<span class="sourceLineNo">3998</span><a id="line.3998">            synchronized (pendingAdditions) {</a>
<span class="sourceLineNo">3999</span><a id="line.3999">                pendingAdditions.remove(seq);</a>
<span class="sourceLineNo">4000</span><a id="line.4000">            }</a>
<span class="sourceLineNo">4001</span><a id="line.4001">        }</a>
<span class="sourceLineNo">4002</span><a id="line.4002"></a>
<span class="sourceLineNo">4003</span><a id="line.4003">        public Long minPendingAdd() {</a>
<span class="sourceLineNo">4004</span><a id="line.4004">            synchronized (pendingAdditions) {</a>
<span class="sourceLineNo">4005</span><a id="line.4005">                if (!pendingAdditions.isEmpty()) {</a>
<span class="sourceLineNo">4006</span><a id="line.4006">                    return pendingAdditions.get(0);</a>
<span class="sourceLineNo">4007</span><a id="line.4007">                } else {</a>
<span class="sourceLineNo">4008</span><a id="line.4008">                    return null;</a>
<span class="sourceLineNo">4009</span><a id="line.4009">                }</a>
<span class="sourceLineNo">4010</span><a id="line.4010">            }</a>
<span class="sourceLineNo">4011</span><a id="line.4011">        }</a>
<span class="sourceLineNo">4012</span><a id="line.4012"></a>
<span class="sourceLineNo">4013</span><a id="line.4013">        class MessageOrderIterator implements Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt;{</a>
<span class="sourceLineNo">4014</span><a id="line.4014">            Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt;currentIterator;</a>
<span class="sourceLineNo">4015</span><a id="line.4015">            final Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt;highIterator;</a>
<span class="sourceLineNo">4016</span><a id="line.4016">            final Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt;defaultIterator;</a>
<span class="sourceLineNo">4017</span><a id="line.4017">            final Iterator&lt;Entry&lt;Long, MessageKeys&gt;&gt;lowIterator;</a>
<span class="sourceLineNo">4018</span><a id="line.4018"></a>
<span class="sourceLineNo">4019</span><a id="line.4019">            MessageOrderIterator(Transaction tx, MessageOrderCursor m, MessageOrderIndex messageOrderIndex) throws IOException {</a>
<span class="sourceLineNo">4020</span><a id="line.4020">                Long pendingAddLimiter = messageOrderIndex.minPendingAdd();</a>
<span class="sourceLineNo">4021</span><a id="line.4021">                this.defaultIterator = defaultPriorityIndex.iterator(tx, m.defaultCursorPosition, pendingAddLimiter);</a>
<span class="sourceLineNo">4022</span><a id="line.4022">                if (highPriorityIndex != null) {</a>
<span class="sourceLineNo">4023</span><a id="line.4023">                    this.highIterator = highPriorityIndex.iterator(tx, m.highPriorityCursorPosition, pendingAddLimiter);</a>
<span class="sourceLineNo">4024</span><a id="line.4024">                } else {</a>
<span class="sourceLineNo">4025</span><a id="line.4025">                    this.highIterator = null;</a>
<span class="sourceLineNo">4026</span><a id="line.4026">                }</a>
<span class="sourceLineNo">4027</span><a id="line.4027">                if (lowPriorityIndex != null) {</a>
<span class="sourceLineNo">4028</span><a id="line.4028">                    this.lowIterator = lowPriorityIndex.iterator(tx, m.lowPriorityCursorPosition, pendingAddLimiter);</a>
<span class="sourceLineNo">4029</span><a id="line.4029">                } else {</a>
<span class="sourceLineNo">4030</span><a id="line.4030">                    this.lowIterator = null;</a>
<span class="sourceLineNo">4031</span><a id="line.4031">                }</a>
<span class="sourceLineNo">4032</span><a id="line.4032">            }</a>
<span class="sourceLineNo">4033</span><a id="line.4033"></a>
<span class="sourceLineNo">4034</span><a id="line.4034">            @Override</a>
<span class="sourceLineNo">4035</span><a id="line.4035">            public boolean hasNext() {</a>
<span class="sourceLineNo">4036</span><a id="line.4036">                if (currentIterator == null) {</a>
<span class="sourceLineNo">4037</span><a id="line.4037">                    if (highIterator != null) {</a>
<span class="sourceLineNo">4038</span><a id="line.4038">                        if (highIterator.hasNext()) {</a>
<span class="sourceLineNo">4039</span><a id="line.4039">                            currentIterator = highIterator;</a>
<span class="sourceLineNo">4040</span><a id="line.4040">                            return currentIterator.hasNext();</a>
<span class="sourceLineNo">4041</span><a id="line.4041">                        }</a>
<span class="sourceLineNo">4042</span><a id="line.4042">                        if (defaultIterator.hasNext()) {</a>
<span class="sourceLineNo">4043</span><a id="line.4043">                            currentIterator = defaultIterator;</a>
<span class="sourceLineNo">4044</span><a id="line.4044">                            return currentIterator.hasNext();</a>
<span class="sourceLineNo">4045</span><a id="line.4045">                        }</a>
<span class="sourceLineNo">4046</span><a id="line.4046">                        if (lowIterator.hasNext()) {</a>
<span class="sourceLineNo">4047</span><a id="line.4047">                            currentIterator = lowIterator;</a>
<span class="sourceLineNo">4048</span><a id="line.4048">                            return currentIterator.hasNext();</a>
<span class="sourceLineNo">4049</span><a id="line.4049">                        }</a>
<span class="sourceLineNo">4050</span><a id="line.4050">                        return false;</a>
<span class="sourceLineNo">4051</span><a id="line.4051">                    } else {</a>
<span class="sourceLineNo">4052</span><a id="line.4052">                        currentIterator = defaultIterator;</a>
<span class="sourceLineNo">4053</span><a id="line.4053">                        return currentIterator.hasNext();</a>
<span class="sourceLineNo">4054</span><a id="line.4054">                    }</a>
<span class="sourceLineNo">4055</span><a id="line.4055">                }</a>
<span class="sourceLineNo">4056</span><a id="line.4056">                if (highIterator != null) {</a>
<span class="sourceLineNo">4057</span><a id="line.4057">                    if (currentIterator.hasNext()) {</a>
<span class="sourceLineNo">4058</span><a id="line.4058">                        return true;</a>
<span class="sourceLineNo">4059</span><a id="line.4059">                    }</a>
<span class="sourceLineNo">4060</span><a id="line.4060">                    if (currentIterator == highIterator) {</a>
<span class="sourceLineNo">4061</span><a id="line.4061">                        if (defaultIterator.hasNext()) {</a>
<span class="sourceLineNo">4062</span><a id="line.4062">                            currentIterator = defaultIterator;</a>
<span class="sourceLineNo">4063</span><a id="line.4063">                            return currentIterator.hasNext();</a>
<span class="sourceLineNo">4064</span><a id="line.4064">                        }</a>
<span class="sourceLineNo">4065</span><a id="line.4065">                        if (lowIterator.hasNext()) {</a>
<span class="sourceLineNo">4066</span><a id="line.4066">                            currentIterator = lowIterator;</a>
<span class="sourceLineNo">4067</span><a id="line.4067">                            return currentIterator.hasNext();</a>
<span class="sourceLineNo">4068</span><a id="line.4068">                        }</a>
<span class="sourceLineNo">4069</span><a id="line.4069">                        return false;</a>
<span class="sourceLineNo">4070</span><a id="line.4070">                    }</a>
<span class="sourceLineNo">4071</span><a id="line.4071"></a>
<span class="sourceLineNo">4072</span><a id="line.4072">                    if (currentIterator == defaultIterator) {</a>
<span class="sourceLineNo">4073</span><a id="line.4073">                        if (lowIterator.hasNext()) {</a>
<span class="sourceLineNo">4074</span><a id="line.4074">                            currentIterator = lowIterator;</a>
<span class="sourceLineNo">4075</span><a id="line.4075">                            return currentIterator.hasNext();</a>
<span class="sourceLineNo">4076</span><a id="line.4076">                        }</a>
<span class="sourceLineNo">4077</span><a id="line.4077">                        return false;</a>
<span class="sourceLineNo">4078</span><a id="line.4078">                    }</a>
<span class="sourceLineNo">4079</span><a id="line.4079">                }</a>
<span class="sourceLineNo">4080</span><a id="line.4080">                return currentIterator.hasNext();</a>
<span class="sourceLineNo">4081</span><a id="line.4081">            }</a>
<span class="sourceLineNo">4082</span><a id="line.4082"></a>
<span class="sourceLineNo">4083</span><a id="line.4083">            @Override</a>
<span class="sourceLineNo">4084</span><a id="line.4084">            public Entry&lt;Long, MessageKeys&gt; next() {</a>
<span class="sourceLineNo">4085</span><a id="line.4085">                Entry&lt;Long, MessageKeys&gt; result = currentIterator.next();</a>
<span class="sourceLineNo">4086</span><a id="line.4086">                if (result != null) {</a>
<span class="sourceLineNo">4087</span><a id="line.4087">                    Long key = result.getKey();</a>
<span class="sourceLineNo">4088</span><a id="line.4088">                    if (highIterator != null) {</a>
<span class="sourceLineNo">4089</span><a id="line.4089">                        if (currentIterator == defaultIterator) {</a>
<span class="sourceLineNo">4090</span><a id="line.4090">                            lastDefaultKey = key;</a>
<span class="sourceLineNo">4091</span><a id="line.4091">                        } else if (currentIterator == highIterator) {</a>
<span class="sourceLineNo">4092</span><a id="line.4092">                            lastHighKey = key;</a>
<span class="sourceLineNo">4093</span><a id="line.4093">                        } else {</a>
<span class="sourceLineNo">4094</span><a id="line.4094">                            lastLowKey = key;</a>
<span class="sourceLineNo">4095</span><a id="line.4095">                        }</a>
<span class="sourceLineNo">4096</span><a id="line.4096">                    } else {</a>
<span class="sourceLineNo">4097</span><a id="line.4097">                        lastDefaultKey = key;</a>
<span class="sourceLineNo">4098</span><a id="line.4098">                    }</a>
<span class="sourceLineNo">4099</span><a id="line.4099">                }</a>
<span class="sourceLineNo">4100</span><a id="line.4100">                return result;</a>
<span class="sourceLineNo">4101</span><a id="line.4101">            }</a>
<span class="sourceLineNo">4102</span><a id="line.4102"></a>
<span class="sourceLineNo">4103</span><a id="line.4103">            @Override</a>
<span class="sourceLineNo">4104</span><a id="line.4104">            public void remove() {</a>
<span class="sourceLineNo">4105</span><a id="line.4105">                throw new UnsupportedOperationException();</a>
<span class="sourceLineNo">4106</span><a id="line.4106">            }</a>
<span class="sourceLineNo">4107</span><a id="line.4107">        }</a>
<span class="sourceLineNo">4108</span><a id="line.4108">    }</a>
<span class="sourceLineNo">4109</span><a id="line.4109"></a>
<span class="sourceLineNo">4110</span><a id="line.4110">    private static class HashSetStringMarshaller extends VariableMarshaller&lt;HashSet&lt;String&gt;&gt; {</a>
<span class="sourceLineNo">4111</span><a id="line.4111">        final static HashSetStringMarshaller INSTANCE = new HashSetStringMarshaller();</a>
<span class="sourceLineNo">4112</span><a id="line.4112"></a>
<span class="sourceLineNo">4113</span><a id="line.4113">        @Override</a>
<span class="sourceLineNo">4114</span><a id="line.4114">        public void writePayload(HashSet&lt;String&gt; object, DataOutput dataOut) throws IOException {</a>
<span class="sourceLineNo">4115</span><a id="line.4115">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</a>
<span class="sourceLineNo">4116</span><a id="line.4116">            ObjectOutputStream oout = new ObjectOutputStream(baos);</a>
<span class="sourceLineNo">4117</span><a id="line.4117">            oout.writeObject(object);</a>
<span class="sourceLineNo">4118</span><a id="line.4118">            oout.flush();</a>
<span class="sourceLineNo">4119</span><a id="line.4119">            oout.close();</a>
<span class="sourceLineNo">4120</span><a id="line.4120">            byte[] data = baos.toByteArray();</a>
<span class="sourceLineNo">4121</span><a id="line.4121">            dataOut.writeInt(data.length);</a>
<span class="sourceLineNo">4122</span><a id="line.4122">            dataOut.write(data);</a>
<span class="sourceLineNo">4123</span><a id="line.4123">        }</a>
<span class="sourceLineNo">4124</span><a id="line.4124"></a>
<span class="sourceLineNo">4125</span><a id="line.4125">        @Override</a>
<span class="sourceLineNo">4126</span><a id="line.4126">        @SuppressWarnings("unchecked")</a>
<span class="sourceLineNo">4127</span><a id="line.4127">        public HashSet&lt;String&gt; readPayload(DataInput dataIn) throws IOException {</a>
<span class="sourceLineNo">4128</span><a id="line.4128">            int dataLen = dataIn.readInt();</a>
<span class="sourceLineNo">4129</span><a id="line.4129">            byte[] data = new byte[dataLen];</a>
<span class="sourceLineNo">4130</span><a id="line.4130">            dataIn.readFully(data);</a>
<span class="sourceLineNo">4131</span><a id="line.4131">            ByteArrayInputStream bais = new ByteArrayInputStream(data);</a>
<span class="sourceLineNo">4132</span><a id="line.4132">            ObjectInputStream oin = new MessageDatabaseObjectInputStream(bais);</a>
<span class="sourceLineNo">4133</span><a id="line.4133">            try {</a>
<span class="sourceLineNo">4134</span><a id="line.4134">                return (HashSet&lt;String&gt;) oin.readObject();</a>
<span class="sourceLineNo">4135</span><a id="line.4135">            } catch (ClassNotFoundException cfe) {</a>
<span class="sourceLineNo">4136</span><a id="line.4136">                IOException ioe = new IOException("Failed to read HashSet&lt;String&gt;: " + cfe);</a>
<span class="sourceLineNo">4137</span><a id="line.4137">                ioe.initCause(cfe);</a>
<span class="sourceLineNo">4138</span><a id="line.4138">                throw ioe;</a>
<span class="sourceLineNo">4139</span><a id="line.4139">            }</a>
<span class="sourceLineNo">4140</span><a id="line.4140">        }</a>
<span class="sourceLineNo">4141</span><a id="line.4141">    }</a>
<span class="sourceLineNo">4142</span><a id="line.4142"></a>
<span class="sourceLineNo">4143</span><a id="line.4143">    public File getIndexDirectory() {</a>
<span class="sourceLineNo">4144</span><a id="line.4144">        return indexDirectory;</a>
<span class="sourceLineNo">4145</span><a id="line.4145">    }</a>
<span class="sourceLineNo">4146</span><a id="line.4146"></a>
<span class="sourceLineNo">4147</span><a id="line.4147">    public void setIndexDirectory(File indexDirectory) {</a>
<span class="sourceLineNo">4148</span><a id="line.4148">        this.indexDirectory = indexDirectory;</a>
<span class="sourceLineNo">4149</span><a id="line.4149">    }</a>
<span class="sourceLineNo">4150</span><a id="line.4150"></a>
<span class="sourceLineNo">4151</span><a id="line.4151">    interface IndexAware {</a>
<span class="sourceLineNo">4152</span><a id="line.4152">        public void sequenceAssignedWithIndexLocked(long index);</a>
<span class="sourceLineNo">4153</span><a id="line.4153">    }</a>
<span class="sourceLineNo">4154</span><a id="line.4154"></a>
<span class="sourceLineNo">4155</span><a id="line.4155">    public String getPreallocationScope() {</a>
<span class="sourceLineNo">4156</span><a id="line.4156">        return preallocationScope;</a>
<span class="sourceLineNo">4157</span><a id="line.4157">    }</a>
<span class="sourceLineNo">4158</span><a id="line.4158"></a>
<span class="sourceLineNo">4159</span><a id="line.4159">    public void setPreallocationScope(String preallocationScope) {</a>
<span class="sourceLineNo">4160</span><a id="line.4160">        this.preallocationScope = preallocationScope;</a>
<span class="sourceLineNo">4161</span><a id="line.4161">    }</a>
<span class="sourceLineNo">4162</span><a id="line.4162"></a>
<span class="sourceLineNo">4163</span><a id="line.4163">    public String getPreallocationStrategy() {</a>
<span class="sourceLineNo">4164</span><a id="line.4164">        return preallocationStrategy;</a>
<span class="sourceLineNo">4165</span><a id="line.4165">    }</a>
<span class="sourceLineNo">4166</span><a id="line.4166"></a>
<span class="sourceLineNo">4167</span><a id="line.4167">    public void setPreallocationStrategy(String preallocationStrategy) {</a>
<span class="sourceLineNo">4168</span><a id="line.4168">        this.preallocationStrategy = preallocationStrategy;</a>
<span class="sourceLineNo">4169</span><a id="line.4169">    }</a>
<span class="sourceLineNo">4170</span><a id="line.4170"></a>
<span class="sourceLineNo">4171</span><a id="line.4171">    public int getCompactAcksAfterNoGC() {</a>
<span class="sourceLineNo">4172</span><a id="line.4172">        return compactAcksAfterNoGC;</a>
<span class="sourceLineNo">4173</span><a id="line.4173">    }</a>
<span class="sourceLineNo">4174</span><a id="line.4174"></a>
<span class="sourceLineNo">4175</span><a id="line.4175">    /**</a>
<span class="sourceLineNo">4176</span><a id="line.4176">     * Sets the number of GC cycles where no journal logs were removed before an attempt to</a>
<span class="sourceLineNo">4177</span><a id="line.4177">     * move forward all the acks in the last log that contains them and is otherwise unreferenced.</a>
<span class="sourceLineNo">4178</span><a id="line.4178">     * &lt;p&gt;</a>
<span class="sourceLineNo">4179</span><a id="line.4179">     * A value of -1 will disable this feature.</a>
<span class="sourceLineNo">4180</span><a id="line.4180">     *</a>
<span class="sourceLineNo">4181</span><a id="line.4181">     * @param compactAcksAfterNoGC</a>
<span class="sourceLineNo">4182</span><a id="line.4182">     *      Number of empty GC cycles before we rewrite old ACKS.</a>
<span class="sourceLineNo">4183</span><a id="line.4183">     */</a>
<span class="sourceLineNo">4184</span><a id="line.4184">    public void setCompactAcksAfterNoGC(int compactAcksAfterNoGC) {</a>
<span class="sourceLineNo">4185</span><a id="line.4185">        this.compactAcksAfterNoGC = compactAcksAfterNoGC;</a>
<span class="sourceLineNo">4186</span><a id="line.4186">    }</a>
<span class="sourceLineNo">4187</span><a id="line.4187"></a>
<span class="sourceLineNo">4188</span><a id="line.4188">    /**</a>
<span class="sourceLineNo">4189</span><a id="line.4189">     * Returns whether Ack compaction will ignore that the store is still growing</a>
<span class="sourceLineNo">4190</span><a id="line.4190">     * and run more often.</a>
<span class="sourceLineNo">4191</span><a id="line.4191">     *</a>
<span class="sourceLineNo">4192</span><a id="line.4192">     * @return the compactAcksIgnoresStoreGrowth current value.</a>
<span class="sourceLineNo">4193</span><a id="line.4193">     */</a>
<span class="sourceLineNo">4194</span><a id="line.4194">    public boolean isCompactAcksIgnoresStoreGrowth() {</a>
<span class="sourceLineNo">4195</span><a id="line.4195">        return compactAcksIgnoresStoreGrowth;</a>
<span class="sourceLineNo">4196</span><a id="line.4196">    }</a>
<span class="sourceLineNo">4197</span><a id="line.4197"></a>
<span class="sourceLineNo">4198</span><a id="line.4198">    /**</a>
<span class="sourceLineNo">4199</span><a id="line.4199">     * Configure if Ack compaction will occur regardless of continued growth of the</a>
<span class="sourceLineNo">4200</span><a id="line.4200">     * journal logs meaning that the store has not run out of space yet.  Because the</a>
<span class="sourceLineNo">4201</span><a id="line.4201">     * compaction operation can be costly this value is defaulted to off and the Ack</a>
<span class="sourceLineNo">4202</span><a id="line.4202">     * compaction is only done when it seems that the store cannot grow and larger.</a>
<span class="sourceLineNo">4203</span><a id="line.4203">     *</a>
<span class="sourceLineNo">4204</span><a id="line.4204">     * @param compactAcksIgnoresStoreGrowth the compactAcksIgnoresStoreGrowth to set</a>
<span class="sourceLineNo">4205</span><a id="line.4205">     */</a>
<span class="sourceLineNo">4206</span><a id="line.4206">    public void setCompactAcksIgnoresStoreGrowth(boolean compactAcksIgnoresStoreGrowth) {</a>
<span class="sourceLineNo">4207</span><a id="line.4207">        this.compactAcksIgnoresStoreGrowth = compactAcksIgnoresStoreGrowth;</a>
<span class="sourceLineNo">4208</span><a id="line.4208">    }</a>
<span class="sourceLineNo">4209</span><a id="line.4209"></a>
<span class="sourceLineNo">4210</span><a id="line.4210">    /**</a>
<span class="sourceLineNo">4211</span><a id="line.4211">     * Returns whether Ack compaction is enabled</a>
<span class="sourceLineNo">4212</span><a id="line.4212">     *</a>
<span class="sourceLineNo">4213</span><a id="line.4213">     * @return enableAckCompaction</a>
<span class="sourceLineNo">4214</span><a id="line.4214">     */</a>
<span class="sourceLineNo">4215</span><a id="line.4215">    public boolean isEnableAckCompaction() {</a>
<span class="sourceLineNo">4216</span><a id="line.4216">        return enableAckCompaction;</a>
<span class="sourceLineNo">4217</span><a id="line.4217">    }</a>
<span class="sourceLineNo">4218</span><a id="line.4218"></a>
<span class="sourceLineNo">4219</span><a id="line.4219">    /**</a>
<span class="sourceLineNo">4220</span><a id="line.4220">     * Configure if the Ack compaction task should be enabled to run</a>
<span class="sourceLineNo">4221</span><a id="line.4221">     *</a>
<span class="sourceLineNo">4222</span><a id="line.4222">     * @param enableAckCompaction</a>
<span class="sourceLineNo">4223</span><a id="line.4223">     */</a>
<span class="sourceLineNo">4224</span><a id="line.4224">    public void setEnableAckCompaction(boolean enableAckCompaction) {</a>
<span class="sourceLineNo">4225</span><a id="line.4225">        this.enableAckCompaction = enableAckCompaction;</a>
<span class="sourceLineNo">4226</span><a id="line.4226">    }</a>
<span class="sourceLineNo">4227</span><a id="line.4227"></a>
<span class="sourceLineNo">4228</span><a id="line.4228">    /**</a>
<span class="sourceLineNo">4229</span><a id="line.4229">     * @return</a>
<span class="sourceLineNo">4230</span><a id="line.4230">     */</a>
<span class="sourceLineNo">4231</span><a id="line.4231">    public boolean isEnableSubscriptionStatistics() {</a>
<span class="sourceLineNo">4232</span><a id="line.4232">        return enableSubscriptionStatistics;</a>
<span class="sourceLineNo">4233</span><a id="line.4233">    }</a>
<span class="sourceLineNo">4234</span><a id="line.4234"></a>
<span class="sourceLineNo">4235</span><a id="line.4235">    /**</a>
<span class="sourceLineNo">4236</span><a id="line.4236">     * Enable caching statistics for each subscription to allow non-blocking</a>
<span class="sourceLineNo">4237</span><a id="line.4237">     * retrieval of metrics.  This could incur some overhead to compute if there are a lot</a>
<span class="sourceLineNo">4238</span><a id="line.4238">     * of subscriptions.</a>
<span class="sourceLineNo">4239</span><a id="line.4239">     *</a>
<span class="sourceLineNo">4240</span><a id="line.4240">     * @param enableSubscriptionStatistics</a>
<span class="sourceLineNo">4241</span><a id="line.4241">     */</a>
<span class="sourceLineNo">4242</span><a id="line.4242">    public void setEnableSubscriptionStatistics(boolean enableSubscriptionStatistics) {</a>
<span class="sourceLineNo">4243</span><a id="line.4243">        this.enableSubscriptionStatistics = enableSubscriptionStatistics;</a>
<span class="sourceLineNo">4244</span><a id="line.4244">    }</a>
<span class="sourceLineNo">4245</span><a id="line.4245"></a>
<span class="sourceLineNo">4246</span><a id="line.4246">    private static class MessageDatabaseObjectInputStream extends ObjectInputStream {</a>
<span class="sourceLineNo">4247</span><a id="line.4247"></a>
<span class="sourceLineNo">4248</span><a id="line.4248">        public MessageDatabaseObjectInputStream(InputStream is) throws IOException {</a>
<span class="sourceLineNo">4249</span><a id="line.4249">            super(is);</a>
<span class="sourceLineNo">4250</span><a id="line.4250">        }</a>
<span class="sourceLineNo">4251</span><a id="line.4251"></a>
<span class="sourceLineNo">4252</span><a id="line.4252">        @Override</a>
<span class="sourceLineNo">4253</span><a id="line.4253">        protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException {</a>
<span class="sourceLineNo">4254</span><a id="line.4254">            if (!(desc.getName().startsWith("java.lang.")</a>
<span class="sourceLineNo">4255</span><a id="line.4255">                    || desc.getName().startsWith("com.thoughtworks.xstream")</a>
<span class="sourceLineNo">4256</span><a id="line.4256">                    || desc.getName().startsWith("java.util.")</a>
<span class="sourceLineNo">4257</span><a id="line.4257">                    || desc.getName().length() &gt; 2 &amp;&amp; desc.getName().substring(2).startsWith("java.util.") // Allow arrays</a>
<span class="sourceLineNo">4258</span><a id="line.4258">                    || desc.getName().startsWith("org.apache.activemq."))) {</a>
<span class="sourceLineNo">4259</span><a id="line.4259">                throw new InvalidClassException("Unauthorized deserialization attempt", desc.getName());</a>
<span class="sourceLineNo">4260</span><a id="line.4260">            }</a>
<span class="sourceLineNo">4261</span><a id="line.4261">            return super.resolveClass(desc);</a>
<span class="sourceLineNo">4262</span><a id="line.4262">        }</a>
<span class="sourceLineNo">4263</span><a id="line.4263"></a>
<span class="sourceLineNo">4264</span><a id="line.4264">    }</a>
<span class="sourceLineNo">4265</span><a id="line.4265">}</a>




























































</pre>
</div>
</main>
</body>
</html>
